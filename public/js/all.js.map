{"version":3,"sources":["setup.js","utils.js","shims.js","Strings.js","Collection.js","Events.js","Reqres.js","Box.js","Module.js","Looper.js","Promise.js","Ajax.js","Associator.js","DOMM.js","Element.js","View.js","Buster.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACj7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3pBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/nFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9oBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"all.js","sourcesContent":["\n(function (win, where) {\n    'use strict';\n    function Application(name, parent) {\n        this.version = name;\n        this.scoped = true;\n        this.global = false;\n        return this;\n    }\n    var makeParody = function (parent, fn) {\n        return function () {\n            return fn.apply(parent, arguments);\n        };\n    };\n    Application.prototype.extend = function (obj) {\n        var n, app = this;\n        for (n in obj) {\n            if (obj.hasOwnProperty(n)) {\n                app[n] = obj[n];\n            }\n        }\n        return app;\n    };\n    Application.prototype.parody = function (list) {\n        var i = 0,\n            extendor = {},\n            parent = this.parent;\n        for (; i < list[lengthString]; i++) {\n            extendor[list[i]] = makeParody(parent, parent[list[i]]);\n        }\n        this.extend(extendor);\n        return this;\n    };\n    var topmostDoc, makeScriptString = 'makeScript',\n        lengthString = 'length',\n        application = win[where] = win[where] || {\n        versions: {},\n        versionOrder: [],\n        global: true,\n        scoped: false,\n        registerVersion: function (name) {\n            var application = this,\n                cachedOrCreated = application.versions[name],\n                newApp = application.versions[name] = cachedOrCreated || new Application(name, application);\n            newApp.parent = application;\n            application.upsetDefaultVersion(name);\n            if (!cachedOrCreated) {\n                application.versionOrder.push(name);\n            }\n            return newApp;\n        },\n        upsetDefaultVersion: function (version) {\n            var application = this;\n            if (application.defaultVersion) {\n                // keyword version only works the first time then it's set for the lifespan\n                if (+application.defaultVersion === +application.defaultVersion) {\n                    // keyword version overwrites default (dev / hotfix)\n                    if (+version !== +version) {\n                        application.defaultVersion = version;\n                    }\n                }\n            } else {\n                application.defaultVersion = version;\n            }\n        },\n        unRegisterVersion: function (name) {\n            var application = this,\n                saved = application.versions[name],\n                orderIdx = application.versionOrder.indexOf(name);\n            if (orderIdx !== -1) {\n                application.versionOrder.splice(orderIdx, 1);\n            }\n            saved.parent = void 0;\n            application.versions[name] = void 0;\n            return saved;\n        },\n        scope: function (name_, fn_) {\n            var ret, app = this,\n                hash = app.versions,\n                name = fn_ ? name_ : app.defaultVersion,\n                fn = fn_ ? fn_ : name_;\n            if (typeof name_ === 'string') {\n                app.currentVersion = name_;\n            }\n            app.registerVersion(name);\n            ret = typeof fn === 'function' && fn(hash[name]);\n            return hash[name];\n        },\n        map: function (arra, fn, ctx) {\n            var i = 0,\n                len = arra[lengthString],\n                arr = [];\n            while (len > i) {\n                arr[i] = fn.call(ctx, i, arra[i], arra);\n                i++;\n            }\n            return arr;\n        },\n        registerScopedMethod: function (name, expects_) {\n            var application = this,\n                expects = expects_ || 3,\n                method = application[name] = application[name] || function () {\n                    var version, i = 1,\n                        args = arguments,\n                        args_ = args,\n                        argLen = args[lengthString];\n                    // expects is equivalent to what it would be if the version was passed in\n                    if (argLen < expects) {\n                        version = application.defaultVersion;\n                    } else {\n                        args_ = [];\n                        version = args[1];\n                        for (; i < args[lengthString]; i++) {\n                            args_.push(args[i]);\n                        }\n                    }\n                    application.applyTo(version, name, args_);\n                };\n            return application;\n        },\n        get: function (version) {\n            return this.versions[version];\n        },\n        applyTo: function (which, method, args) {\n            var application = this,\n                app = application.get(which);\n            if (app) {\n                return app[method].apply(app, args);\n            }\n        },\n        getCurrentScript: function (d) {\n            var allScripts = (d || doc).scripts,\n                currentScript = d.currentScript,\n                lastScript = allScripts[allScripts[lengthString] - 1];\n            return currentScript || lastScript;\n        },\n        loadScript: function (url, callback, docu_) {\n            var scriptTag, application = this,\n                // allow top doc to be overwritten\n                docu = docu_ || topmostDoc || doc;\n            scriptTag = application[makeScriptString](url, callback);\n            docu.head.appendChild(scriptTag);\n            return application;\n        },\n        makeScript: function (src, onload, docu_) {\n            var docu = docu_ || topmostDoc || doc,\n                script = docu.createElement('script');\n            script.type = 'text/javascript';\n            docu.head.appendChild(script);\n            if (src) {\n                if (onload) {\n                    script.onload = onload;\n                }\n                // src applied last for ie\n                script.src = src;\n            }\n            return script;\n        },\n        touchTop: function (win) {\n            // assume you have top access\n            var href, topAccess = 1,\n                application = this;\n            if (application.topAccess === void 0) {\n                try {\n                    href = win.top.location.href;\n                    // safari bug where unfriendly frame returns undefined\n                    if (href) {\n                        topAccess = 0;\n                        application = win.top[where];\n                    }\n                } catch (e) {\n                    topAccess = 1;\n                }\n                if (win === win.top) {\n                    topAccess = 0;\n                }\n                if (!topAccess) {\n                    topmostDoc = win.top.document;\n                    win.top[where] = application;\n                }\n                application.topAccess = !topAccess;\n            }\n            win[where] = application;\n            return application;\n        },\n    };\n}(window, 'application'));","application.scope('dev', function (app) {\n    var blank, _, object = Object,\n        extendFrom = {},\n        factories = {},\n        fn = Function,\n        array = Array,\n        string = String,\n        toStringString = 'toString',\n        PROTOTYPE_STRING = 'prototype',\n        constructorString = 'constructor',\n        lengthString = 'length',\n        CONSTRUCTOR_ID = '__constructorId',\n        CONSTRUCTOR_KEY = '__constructor__',\n        stringProto = string[PROTOTYPE_STRING],\n        objectProto = object[PROTOTYPE_STRING],\n        arrayProto = array[PROTOTYPE_STRING],\n        // shiftArray = arrayProto.shift,\n        funcProto = fn[PROTOTYPE_STRING],\n        nativeKeys = object.keys,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        hasEnumBug = !{\n            toString: null\n        }.propertyIsEnumerable(toStringString),\n        /**\n         * @func\n         */\n        slice = function (obj, one, two) {\n            return stringProto.slice.call(obj, one, two);\n        },\n        listSlice = function (obj, one, two) {\n            return arrayProto.slice.call(obj, one, two);\n        },\n        /**\n         * @func\n         */\n        split = function (obj, str) {\n            return stringProto.split.call(obj, str);\n        },\n        /**\n         * @func\n         */\n        join = function (obj, str) {\n            return arrayProto.join.call(obj, str);\n        },\n        /**\n         * @func\n         */\n        pop = function (obj) {\n            return arrayProto.pop.call(obj);\n        },\n        /**\n         * @func\n         */\n        push = function (obj, item) {\n            var args = splice(arguments, 1);\n            return arrayProto.push.apply(obj, args);\n        },\n        /**\n         * @func\n         */\n        isNegative1 = function (num) {\n            return (num === -1);\n        },\n        /**\n         * @func\n         */\n        listHas = function (list, item) {\n            return (!isNegative1(indexOf(list, item)));\n        },\n        /**\n         * @func\n         */\n        shift = function (o) {\n            return arrayProto.shift.call(o);\n        },\n        /**\n         * @func\n         */\n        indexOfNaN = function (array, fromIndex, fromRight) {\n            var length = array[lengthString],\n                index = fromIndex + (fromRight ? 0 : -1);\n            while ((fromRight ? index-- : ++index < length)) {\n                var other = array[index];\n                if (other !== other) {\n                    return index;\n                }\n            }\n            return -1;\n        },\n        indexOf = function (array, value, fromIndex) {\n            if (value !== value) {\n                return indexOfNaN(array, fromIndex);\n            }\n            if (array) {\n                var index = (fromIndex || 0) - 1,\n                    length = array[lengthString];\n                while (++index < length) {\n                    if (array[index] === value) {\n                        return index;\n                    }\n                }\n            }\n            return -1;\n        },\n        /**\n         * @func\n         */\n        splice = function () {\n            var ctx = shift(arguments);\n            return arrayProto.splice.apply(ctx, arguments);\n        },\n        reverse = function (arr) {\n            return arrayProto.reverse.call(arr);\n        },\n        /**\n         * @func\n         */\n        toString = function (obj) {\n            return (obj === null || obj === blank) ? '' : (obj + '');\n        },\n        /**\n         * @func\n         */\n        sort = function (obj, fn) {\n            var _fn;\n            if (isFunction(fn)) {\n                _fn = fn;\n                // normalization for safari\n                fn = function () {\n                    var res = +_fn.apply(this, arguments);\n                    if (isNaN(res)) {\n                        res = 0;\n                    }\n                    if (res > 1) {\n                        res = 1;\n                    }\n                    if (res < -1) {\n                        res = -1;\n                    }\n                    return res;\n                };\n            }\n            return arrayProto.sort.call(obj, fn);\n        },\n        /**\n         * @func\n         */\n        has = function (obj, prop) {\n            var val = !1;\n            if (obj && isFunction(obj.hasOwnProperty)) {\n                val = obj.hasOwnProperty(prop);\n            }\n            return val;\n        },\n        /**\n         * @func\n         */\n        nativeIsInstance = function (instance, constructor) {\n            var result = BOOLEAN_FALSE;\n            if (constructor) {\n                return instance instanceof constructor;\n            }\n        },\n        isInstance = function (instance, constructor_) {\n            var result = BOOLEAN_FALSE,\n                constructor = constructor_;\n            while (has(constructor, 'constructor')) {\n                constructor = constructor.constructor;\n            }\n            if (constructor && constructor[CONSTRUCTOR_ID] && instance && instance[CONSTRUCTOR_ID]) {\n                result = constructor[CONSTRUCTOR_ID] === instance[CONSTRUCTOR_ID];\n            } else {\n                result = nativeIsInstance(instance, constructor);\n            }\n            return result;\n        },\n        /**\n         * @func\n         */\n        splitGen = function (delimiter) {\n            return function (list) {\n                if (isString(list)) {\n                    list = split(list, delimiter);\n                }\n                return list;\n            };\n        },\n        /**\n         * @func\n         */\n        joinGen = function (delimiter) {\n            return function (arr) {\n                return join(arr, delimiter);\n            };\n        },\n        /**\n         * @func\n         */\n        gapJoin = joinGen(' '),\n        /**\n         * @func\n         */\n        gapSplit = splitGen(' '),\n        /**\n         * @func\n         */\n        isWrap = function (type, fn) {\n            if (!fn) {\n                fn = function () {\n                    return 1;\n                };\n            }\n            return function (thing) {\n                var ret = 0;\n                if (typeof thing === type && fn(thing)) {\n                    ret = 1;\n                }\n                return !!ret;\n            };\n        },\n        /**\n         * @func\n         */\n        isFunction = isWrap('function'),\n        /**\n         * @func\n         */\n        isBoolean = isWrap('boolean'),\n        /**\n         * @func\n         */\n        isString = isWrap('string'),\n        /**\n         * @func\n         */\n        // isBlank = isWrap('undefined', function (thing) {\n        //     return thing === null;\n        // }),\n        isNull = function (thing) {\n            return thing === null;\n        },\n        isBlank = function (thing) {\n            return thing === void 0 || isNull(thing);\n        },\n        /**\n         * @func\n         */\n        isNaN = function (thing) {\n            return thing !== thing;\n        },\n        negate = function (fn) {\n            return function () {\n                return !fn.apply(this, arguments);\n            };\n        },\n        isNumber = isWrap('number', negate(isNaN)),\n        isFinite_ = window.isFinite,\n        isFinite = function (thing) {\n            return isNumber(thing) && isFinite_(thing);\n        },\n        /**\n         * @func\n         */\n        isObject = isWrap('object', function (thing) {\n            return !!thing;\n        }),\n        /**\n         * @func\n         */\n        isArray = Array.isArray,\n        /**\n         * @func\n         */\n        isEmpty = function (obj) {\n            return !keys(obj)[lengthString];\n        },\n        nonEnumerableProps = gapSplit('valueOf isPrototypeOf ' + toStringString + ' propertyIsEnumerable hasOwnProperty toLocaleString'),\n        /**\n         * @func\n         */\n        invert = function (obj) {\n            var i = 0,\n                result = {},\n                objKeys = keys(obj),\n                length = getLength(objKeys);\n            for (; i < length; i++) {\n                result[obj[objKeys[i]]] = objKeys[i];\n            }\n            return result;\n        },\n        /**\n         * @func\n         */\n        collectNonEnumProps = function (obj, keys) {\n            var nonEnumIdx = nonEnumerableProps[lengthString];\n            var constructor = obj.constructor;\n            var proto = (isFunction(constructor) && constructor.prototype) || ObjProto;\n            // Constructor is a special case.\n            var prop = 'constructor';\n            if (has(obj, prop) && !contains(keys, prop)) keys.push(prop);\n            while (nonEnumIdx--) {\n                prop = nonEnumerableProps[nonEnumIdx];\n                if (prop in obj && obj[prop] !== proto[prop] && !contains(keys, prop)) {\n                    keys.push(prop);\n                }\n            }\n        },\n        /**\n         * @func\n         */\n        stringify = function (obj) {\n            if (isObject(obj)) {\n                obj = JSON.stringify(obj);\n            }\n            if (isFunction(obj)) {\n                obj = obj.toString();\n            }\n            return obj + '';\n        },\n        /**\n         * @func\n         */\n        uniqueId = (function () {\n            var cache = {},\n                global = 0;\n            return function (prefix, isInt) {\n                var val;\n                if (!prefix) {\n                    prefix = '';\n                }\n                prefix += '';\n                val = cache[prefix];\n                if (!val) {\n                    val = cache[prefix] = 0;\n                }\n                cache[prefix]++;\n                if (!isInt) {\n                    val = prefix + val;\n                }\n                return val;\n            };\n        }()),\n        nowish = function () {\n            return +(new Date());\n        },\n        allKeys = function (obj) {\n            var key, keys = [];\n            if (isObject(obj)) {\n                for (key in obj) {\n                    keys.push(key);\n                }\n                // Ahem, IE < 9.\n                if (hasEnumBug) {\n                    collectNonEnumProps(obj, keys);\n                }\n            }\n            return keys;\n        },\n        /**\n         * @func\n         */\n        extend = function () {\n            var deep, source, keys, length, l, key, args = toArray(arguments),\n                base = args.shift(),\n                index = 0,\n                i = 0;\n            if (base === BOOLEAN_TRUE) {\n                deep = base;\n                base = args.shift();\n            }\n            base = base || {};\n            length = getLength(args);\n            if (length) {\n                for (; index < length; index++) {\n                    merge(base, args[index], deep);\n                }\n            }\n            return base;\n        },\n        merge = function (obj1, obj2, deep) {\n            var key, val, attach, i = 0,\n                keys = allKeys(obj2),\n                l = getLength(keys);\n            for (; i < l; i++) {\n                key = keys[i];\n                // ignore undefined\n                if (obj2[key] !== blank) {\n                    attach = BOOLEAN_FALSE;\n                    val = obj2[key];\n                    if (deep) {\n                        if (isObject(obj1[key]) && isObject(obj2[key])) {\n                            merge(obj1[key], obj2[key], deep);\n                            attach = BOOLEAN_FALSE;\n                        } else {\n                            attach = BOOLEAN_TRUE;\n                        }\n                    } else {\n                        attach = BOOLEAN_TRUE;\n                    }\n                    if (attach) {\n                        obj1[key] = val;\n                    }\n                }\n            }\n            return obj1;\n        },\n        /**\n         * @func\n         */\n        property = function (key) {\n            return function (obj) {\n                return obj === blank ? blank : obj[key];\n            };\n        },\n        // Helper for collection methods to determine whether a collection\n        // should be iterated as an array or as an object\n        // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n        // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n        MAX_ARRAY_INDEX = Math.pow(2, 53) - 1,\n        getLength = property('length'),\n        /**\n         * @func\n         */\n        isArrayLike = function (collection) {\n            var length = !!collection && getLength(collection);\n            return isArray(collection) || (isNumber(length) && !isString(collection) && length >= 0 && length <= MAX_ARRAY_INDEX && !isFunction(collection));\n        },\n        /**\n         * @func\n         */\n        // each = function (obj, iteratee, context, direction) {\n        //     var length, objKeys, i = 0,\n        //         args = [obj, iteratee, context, direction];\n        //     if (obj) {\n        //         if (!isArrayLike(obj)) {\n        //             args[0] = objKeys = keys(obj);\n        //             length = getLength(objKeys);\n        //             iteratee = bind(iteratee, context);\n        //             args[2] = null;\n        //             args[1] = function (idx, key, all) {\n        //                 // gives you the key, use that to get the value\n        //                 return iteratee(obj[key], key, obj);\n        //             };\n        //         }\n        //         duff.apply(this, args);\n        //     }\n        //     return obj;\n        // },\n        eachProxy = function (fn) {\n            return function (obj_, iteratee_, context_, direction_) {\n                var ret, obj = obj_,\n                    list = obj,\n                    iteratee = iteratee_,\n                    iterator = iteratee,\n                    context = context_,\n                    direction = direction_;\n                if (obj) {\n                    if (!isArrayLike(obj)) {\n                        list = keys(obj);\n                        iteratee = bindTo(iterator, context);\n                        context = null;\n                        iterator = function (key, idx, list) {\n                            // gives you the key, use that to get the value\n                            return iteratee(obj[key], key, obj);\n                        };\n                    }\n                    return fn(list, iterator, context, direction);\n                }\n            };\n        },\n        /**\n         * @func\n         */\n        createPredicateIndexFinder = function (dir) {\n            return eachProxy(function (array, predicate, context, index_) {\n                var length = getLength(array),\n                    callback = bindTo(predicate, context),\n                    index = index_ || (dir > 0 ? 0 : length - 1);\n                for (; index >= 0 && index < length; index += dir) {\n                    if (callback(array[index], index, array)) {\n                        return index;\n                    }\n                }\n                return -1;\n            });\n        },\n        /**\n         * @func\n         */\n        // Returns the first index on an array-like that passes a predicate test\n        findIndex = createPredicateIndexFinder(1),\n        /**\n         * @func\n         */\n        findLastIndex = createPredicateIndexFinder(-1),\n        /**\n         * @func\n         */\n        validKey = function (key) {\n            return key !== -1 && key !== blank && key !== null && key !== BOOLEAN_FALSE && key !== BOOLEAN_TRUE;\n        },\n        finder = function (findHelper) {\n            return function (obj, predicate, context) {\n                var key = findHelper(obj, predicate, context);\n                if (validKey(key)) {\n                    return obj[key];\n                }\n            };\n        },\n        find = finder(findIndex),\n        findLast = finder(findLastIndex),\n        bind = function (fn, ctx) {\n            return fn.bind(ctx);\n        },\n        bindTo = function (fn, ctx) {\n            if (ctx && isObject(ctx)) {\n                fn = bind(fn, ctx);\n            }\n            return fn;\n        },\n        duff = function (values, process, context, direction) {\n            var iterations, val, i, leftover, deltaFn;\n            if (values && isFunction(process)) {\n                i = 0;\n                val = values[lengthString];\n                leftover = val % 8;\n                iterations = Math.floor(val / 8);\n                deltaFn = function () {\n                    i += direction;\n                };\n                if (direction < 0) {\n                    i = val - 1;\n                }\n                direction = direction || 1;\n                process = bindTo(process, context);\n                if (leftover > 0) {\n                    do {\n                        deltaFn(process(values[i], i, values));\n                    } while (--leftover > 0);\n                }\n                if (iterations) {\n                    do {\n                        deltaFn(process(values[i], i, values));\n                        deltaFn(process(values[i], i, values));\n                        deltaFn(process(values[i], i, values));\n                        deltaFn(process(values[i], i, values));\n                        deltaFn(process(values[i], i, values));\n                        deltaFn(process(values[i], i, values));\n                        deltaFn(process(values[i], i, values));\n                        deltaFn(process(values[i], i, values));\n                    } while (--iterations > 0);\n                }\n            }\n        },\n        each = eachProxy(duff),\n        /**\n         * @func\n         */\n        parseBool = function (thing) {\n            var ret, thingMod = thing + '';\n            thingMod = thingMod.trim();\n            if (thingMod === BOOLEAN_FALSE + '') {\n                ret = BOOLEAN_FALSE;\n            }\n            if (thingMod === BOOLEAN_TRUE + '') {\n                ret = BOOLEAN_TRUE;\n            }\n            if (ret === blank) {\n                ret = thing;\n            }\n            return ret;\n        },\n        /**\n         * @func\n         */\n        parseDecimal = function (num) {\n            return parseFloat(num) || 0;\n        },\n        pI = function (num) {\n            return parseInt(num, 10) || 0;\n        },\n        // math = Math,\n        // mathMix = function (method) {\n        //     return function (arr) {\n        //         return math[method].apply(math, arr);\n        //     };\n        // },\n        // random = function () {\n        //     return math.random();\n        // },\n        // mathMixCaller = function (method) {\n        //     return function (num) {\n        //         math[method](num);\n        //     };\n        // },\n        // mathMixComparer = function (method) {\n        //     return function (num, num2) {\n        //         math[method](num, num2);\n        //     };\n        // },\n        // min = mathMix('min'),\n        // max = mathMix('max'),\n        // abs = mathMixCaller('abs'),\n        // acos = mathMixCaller('acos'),\n        // asin = mathMixCaller('asin'),\n        // atan = mathMixCaller('atan'),\n        // ceil = mathMixCaller('ceil'),\n        // cos = mathMixCaller('cos'),\n        // exp = mathMixCaller('exp'),\n        // floor = mathMixCaller('floor'),\n        // log = mathMixCaller('log'),\n        // round = mathMixCaller('round'),\n        // sin = mathMixCaller('sin'),\n        // sqrt = mathMixCaller('sqrt'),\n        // tan = mathMixCaller('tan'),\n        /**\n         * @func\n         */\n        keys = function (obj) {\n            var key, keys = [];\n            if (!obj || (!isObject(obj) && !isFunction(obj))) {\n                return keys;\n            }\n            if (nativeKeys) {\n                return nativeKeys(obj);\n            }\n            for (key in obj) {\n                if (has(obj, key)) {\n                    keys.push(key);\n                }\n            }\n            // Ahem, IE < 9.\n            if (hasEnumBug) {\n                collectNonEnumProps(obj, keys);\n            }\n            return keys;\n        },\n        /**\n         * @func\n         */\n        constructorExtend = function (name, protoProps, attach) {\n            var constructorId, nameString, child, passedParent, hasConstructor, constructor, parent = this,\n                nameIsStr = isString(name);\n            if (!nameIsStr) {\n                protoProps = name;\n            }\n            hasConstructor = has(protoProps, constructorString);\n            if (protoProps && hasConstructor) {\n                child = protoProps[constructorString];\n            }\n            if (nameIsStr) {\n                // nameString = name;\n                passedParent = parent;\n                if (child) {\n                    passedParent = child;\n                }\n                child = new Function.constructor('var parent=arguments[0];return function ' + name + '(){return parent.apply(this,arguments);}')(passedParent);\n                factories[name] = child;\n            } else {\n                child = function () {\n                    return parent.apply(this, arguments);\n                };\n            }\n            extend(child, parent);\n            constructorId = uniqueId('con');\n            child[CONSTRUCTOR_ID] = constructorId;\n            child.extend = (this[CONSTRUCTOR_KEY] && this[CONSTRUCTOR_KEY].extend) || constructorExtend;\n            var Surrogate = function () {\n                this[constructorString] = child;\n            };\n            Surrogate[PROTOTYPE_STRING] = parent[PROTOTYPE_STRING];\n            child[PROTOTYPE_STRING] = new Surrogate;\n            if (protoProps) {\n                extend(child[PROTOTYPE_STRING], protoProps);\n            }\n            constructor = child;\n            child = constructorWrapper(constructor);\n            if (!isFunction(protoProps.Model) || !has(protoProps, 'Model')) {\n                constructor[PROTOTYPE_STRING].Model = child;\n            }\n            // child.constructor = constructor;\n            child.__super__ = parent[PROTOTYPE_STRING];\n            constructor[CONSTRUCTOR_ID] = constructorId;\n            constructor[PROTOTYPE_STRING][CONSTRUCTOR_KEY] = child;\n            if (nameIsStr) {\n                makeExtendFrom(name, constructor);\n                // this is good when _ / utils object is your global app object\n                if (attach) {\n                    _[name] = child;\n                }\n            }\n            return constructor;\n        },\n        constructorWrapper = function (Ch) {\n            var __ = function (attributes, options) {\n                if (isInstance(attributes, Ch)) {\n                    return attributes;\n                }\n                return new Ch(attributes, options);\n            };\n            __.constructor = Ch;\n            return __;\n        },\n        /**\n         * @func\n         */\n        makeExtendFrom = function (name, child) {\n            extendFrom[name] = function () {\n                return child.extend.apply(child, arguments);\n            };\n        },\n        /**\n         * @func\n         */\n        once = function (fn) {\n            var doIt;\n            return function () {\n                if (!doIt) {\n                    doIt = 1;\n                    fn.apply(this, arguments);\n                }\n            };\n        },\n        /**\n         * @func\n         */\n        // camelCase = (function () {\n        //     var cached = {};\n        //     return function (str, splitter) {\n        //         var i, s, val;\n        //         if (splitter === undefined) {\n        //             splitter = '-';\n        //         }\n        //         if (!cached[splitter]) {\n        //             cached[splitter] = {};\n        //         }\n        //         val = cached[splitter][str];\n        //         if (!val && isString(str)) {\n        //             if (str[0] === '-') {\n        //                 str = slice(str, 1);\n        //             }\n        //             s = split(str, splitter);\n        //             for (i = getLength(s) - 1; i >= 1; i--) {\n        //                 if (s[i]) {\n        //                     s[i] = upCase(s[i]);\n        //                 }\n        //             }\n        //             val = join(s, '');\n        //         }\n        //         cached[splitter][str] = val;\n        //         cached[splitter][val] = val;\n        //         return val;\n        //     };\n        // }()),\n        /**\n         * @func\n         */\n        // upCase = function (s) {\n        //     return s[0].toUpperCase() + slice(s, 1);\n        // },\n        // cacheable = function (fn) {\n        //     var cache = {};\n        //     return function (input) {\n        //         if (!has(cache, input)) {\n        //             cache[input] = fn.apply(this, arguments);\n        //         }\n        //         return cache[input];\n        //     };\n        // },\n        // categoricallyCacheable = function (fn) {\n        //     return function () {};\n        // },\n        /**\n         * @func\n         */\n        // unCamelCase = (function () {\n        //     var cached = {};\n        //     return function (str, splitter) {\n        //         var val;\n        //         if (!splitter) {\n        //             splitter = '-';\n        //         }\n        //         if (!cached[splitter]) {\n        //             cached[splitter] = {};\n        //         }\n        //         val = cached[splitter][str];\n        //         if (!val) {\n        //             if (str) {\n        //                 val = str.replace(/([a-z])([A-Z])/g, '$1' + splitter + '$2').replace(/[A-Z]/g, function (s) {\n        //                     return s.toLowerCase();\n        //                 });\n        //             }\n        //         }\n        //         cached[splitter][str] = val;\n        //         cached[splitter][val] = val;\n        //         return val;\n        //     };\n        // }()),\n        /**\n         * @func\n         */\n        // Internal recursive comparison function for `isEqual`.\n        eq = function (a, b, aStack, bStack) {\n            // Identical objects are equal. `0 === -0`, but they aren't identical.\n            // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n            if (a === b) {\n                return a !== 0 || 1 / a === 1 / b;\n            }\n            // A strict comparison is necessary because `null == undefined`.\n            if (a === null || a === blank || b === blank || b === null) {\n                return a === b;\n            }\n            // Unwrap any wrapped objects.\n            // if (a instanceof _) a = a._wrapped;\n            // if (b instanceof _) b = b._wrapped;\n            // Compare `[[Class]]` names.\n            var className = toString.call(a);\n            if (className !== toString.call(b)) return BOOLEAN_FALSE;\n            switch (className) {\n                // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n            case '[object RegExp]':\n                // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n            case '[object String]':\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n                // equivalent to `new String(\"5\")`.\n                return '' + a === '' + b;\n            case '[object Number]':\n                // `NaN`s are equivalent, but non-reflexive.\n                // Object(NaN) is equivalent to NaN\n                if (+a !== +a) return +b !== +b;\n                // An `egal` comparison is performed for other numeric values.\n                return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n            case '[object Date]':\n            case '[object Boolean]':\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n                // millisecond representations. Note that invalid dates with millisecond representations\n                // of `NaN` are not equivalent.\n                return +a === +b;\n            }\n            var areArrays = className === '[object Array]';\n            if (!areArrays) {\n                if (typeof a != 'object' || typeof b != 'object') return BOOLEAN_FALSE;\n                // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n                // from different frames are.\n                var aCtor = a.constructor,\n                    bCtor = b.constructor;\n                if (aCtor !== bCtor && !(isFunction(aCtor) && nativeIsInstance(aCtor, aCtor) && isFunction(bCtor) && nativeIsInstance(bCtor, bCtor)) && ('constructor' in a && 'constructor' in b)) {\n                    return BOOLEAN_FALSE;\n                }\n            }\n            // Assume equality for cyclic structures. The algorithm for detecting cyclic\n            // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n            // Initializing stack of traversed objects.\n            // It's done here since we only need them for objects and arrays comparison.\n            // aStack = aStack || [];\n            // bStack = bStack || [];\n            var length = aStack[lengthString];\n            while (length--) {\n                // Linear search. Performance is inversely proportional to the number of\n                // unique nested structures.\n                if (aStack[length] === a) {\n                    return bStack[length] === b;\n                }\n            }\n            // Add the first object to the stack of traversed objects.\n            aStack.push(a);\n            bStack.push(b);\n            // Recursively compare objects and arrays.\n            if (areArrays) {\n                // Compare array lengths to determine if a deep comparison is necessary.\n                length = a[lengthString];\n                if (length !== b[lengthString]) {\n                    return BOOLEAN_FALSE;\n                }\n                // Deep compare the contents, ignoring non-numeric properties.\n                while (length--) {\n                    if (!eq(a[length], b[length], aStack, bStack)) {\n                        return BOOLEAN_FALSE;\n                    }\n                }\n            } else {\n                // Deep compare objects.\n                var objKeys = keys(a),\n                    key;\n                length = objKeys[lengthString];\n                // Ensure that both objects contain the same number of properties before comparing deep equality.\n                if (keys(b)[lengthString] !== length) return BOOLEAN_FALSE;\n                while (length--) {\n                    // Deep compare each member\n                    key = objKeys[length];\n                    if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return BOOLEAN_FALSE;\n                }\n            }\n            // Remove the first object from the stack of traversed objects.\n            aStack.pop();\n            bStack.pop();\n            return BOOLEAN_TRUE;\n        },\n        /**\n         * @func\n         */\n        // Perform a deep comparison to check if two objects are equal.\n        isEqual = function (a, b) {\n            return eq(a, b, [], []);\n        },\n        /**\n         * @func\n         */\n        // very shallow clone\n        clone = function (a) {\n            return map(a, function (value, key) {\n                return value;\n            });\n        },\n        fullClone = function (obj) {\n            return parse(stringify(obj));\n        },\n        /**\n         * @func\n         */\n        wrap = function (obj, fn, noExecute) {\n            var newObj = {},\n                _isArray = isArray(obj),\n                wasfunction = isFunction(fn);\n            each(obj, function (value, key) {\n                if (_isArray) {\n                    if (!wasfunction || noExecute) {\n                        newObj[value] = fn;\n                    } else {\n                        newObj[value] = fn(value);\n                    }\n                } else {\n                    newObj[key] = fn(obj[key], key);\n                }\n            });\n            return newObj;\n        },\n        /**\n         * @func\n         */\n        unshift = function (thing) {\n            var ret, items = [];\n            duff(arguments, function (arg, idx) {\n                if (idx) {\n                    items.push(arg);\n                }\n            });\n            return [].unshift.apply(thing, items);\n        },\n        /**\n         * @func\n         */\n        exports = function (obj) {\n            return extend(_, obj);\n        },\n        mix = function () {},\n        // cachable = function (fn) {\n        //     var cache = {};\n        //     return function () {\n        //         var key = JSON.stringify(arguments);\n        //         if (!cache[key]) {\n        //             cache[key] = JSON.stringify(fn.apply(this, arguments));\n        //         }\n        //         return JSON.parse(cache[key]);\n        //     };\n        // },\n        /**\n         * @func\n         */\n        Image = window.Image,\n        fetch = function (url, callback) {\n            var img = new Image();\n            url = stringifyQuery(url);\n            if (callback) {\n                img.onload = function () {\n                    _.unshift(arguments, url);\n                    callback.apply(this, arguments);\n                };\n            }\n            img.src = url;\n            return img;\n        },\n        /**\n         * @func\n         */\n        // returnBuild = function (obj, array, def) {\n        //     var attach, last, depth = obj;\n        //     duff(gapSplit(array), function (key, idx) {\n        //         last = key;\n        //         if (!isObject(depth[key])) {\n        //             if (def[idx] === blank) {\n        //                 depth[key] = {};\n        //             } else {\n        //                 depth[key] = def[idx];\n        //             }\n        //             attach = 1;\n        //         }\n        //         depth = depth[key];\n        //     });\n        //     return depth;\n        // },\n        log = function (type, args) {\n            if (!_.isFunction(console[type])) {\n                type = 'log';\n            }\n            console[type].apply(console, args);\n        },\n        /**\n         * @func\n         */\n        parse = function (val_) {\n            var val = val_;\n            if (isString(val)) {\n                val = val.trim();\n                if (val[0] === '{' || val[0] === '[') {\n                    try {\n                        val = JSON.parse(val);\n                    } catch (e) {\n                        log('error', ['could not parse', val]);\n                    }\n                }\n            }\n            return val;\n        },\n        debounce = function (func, wait, immediate) {\n            var timeout;\n            return function () {\n                var context = this,\n                    args = arguments,\n                    callNow = immediate && !timeout,\n                    later = function () {\n                        timeout = null;\n                        if (!immediate) {\n                            func.apply(context, args);\n                        }\n                    };\n                clearTimeout(timeout);\n                timeout = setTimeout(later, wait);\n                if (callNow) {\n                    func.apply(context, args);\n                }\n                return timeout;\n            };\n        },\n        returnDismorphicBase = function (obj) {\n            return isArrayLike(obj) ? [] : {};\n        },\n        map = function (objs, iteratee, context) {\n            var collection = returnDismorphicBase(objs);\n            var bound = bindTo(iteratee, context);\n            each(objs, function (item, index) {\n                collection[index] = bound(item, index, objs);\n            });\n            return collection;\n        },\n        toArray = function (obj) {\n            var array = [];\n            each(obj, function (value, key) {\n                array.push(value);\n            });\n            return array;\n        },\n        /**\n         * @func\n         */\n        throttle = function (fn, threshold, scope) {\n            var last,\n                deferTimer;\n            if (!threshold) {\n                threshold = 250;\n            }\n            return function () {\n                var context = scope || this,\n                    _nowish = nowish(),\n                    args = arguments;\n                if (last && _nowish < last + threshold) {\n                    // hold on to it\n                    clearTimeout(deferTimer);\n                    deferTimer = setTimeout(function () {\n                        last = _nowish;\n                        fn.apply(context, args);\n                    }, threshold);\n                } else {\n                    last = _nowish;\n                    fn.apply(context, args);\n                }\n            };\n        },\n        /**\n         * @func\n         */\n        pngString = function () {\n            return \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGP6zwAAAgcBApocMXEAAAAASUVORK5CYII=\";\n        },\n        /**\n         * @func\n         */\n        // this should really be it's own factory\n        stringifyQuery = function (obj) {\n            var val, n, base = obj.url,\n                query = [];\n            if (isObject(obj)) {\n                for (n in obj.query) {\n                    val = obj.query[n];\n                    if (val !== blank) {\n                        val = encodeURIComponent(_.stringify(val));\n                        query.push(n + '=' + val);\n                    }\n                }\n                if (query[lengthString]) {\n                    base += '?';\n                }\n                base += query.join('&');\n                if (obj.hash) {\n                    obj.hash = _.stringify(obj.hash);\n                    base += ('#' + obj.hash);\n                }\n            } else {\n                base = obj;\n            }\n            return base;\n        },\n        protoProp = function (instance, key, farDown) {\n            var val, proto, constructor = instance.constructor;\n            farDown = farDown || 1;\n            do {\n                proto = constructor.prototype;\n                val = proto[key];\n                constructor = proto.constructor;\n            } while (--farDown > 0 && constructor && isFinite(farDown));\n            return val;\n        },\n        /**\n         * @func\n         */\n        makeId = (function () {\n            var global = -1,\n                cache = {};\n            return function (prefix) {\n                var prefixStr, retVal;\n                if (!prefix) {\n                    prefixStr = '';\n                }\n                if (prefix) {\n                    prefixStr = prefix.toString();\n                }\n                if (cache[prefixStr] === blank) {\n                    cache[prefixStr] = -1;\n                }\n                cache[prefixStr]++;\n                global++;\n                retVal = prefix + cache[prefixStr];\n                if (!prefix) {\n                    retVal = global;\n                    if (prefix === '') {\n                        retVal = '' + global;\n                    }\n                }\n                return retVal;\n            };\n        }()),\n        /**\n         * @func\n         */\n        uuid = function () {\n            var blank, cryptoCheck = 'crypto' in window && 'getRandomValues' in crypto,\n                sid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n                    var rnd, r, v;\n                    if (cryptoCheck) {\n                        rnd = window.crypto.getRandomValues(new Uint32Array(1));\n                        if (rnd === blank) {\n                            cryptoCheck = false;\n                        }\n                    }\n                    if (!cryptoCheck) {\n                        rnd = [Math.floor(Math.random() * 10000000000)];\n                    }\n                    rnd = rnd[0];\n                    r = rnd % 16;\n                    v = (c === 'x') ? r : (r & 0x3 | 0x8);\n                    return v.toString(16);\n                });\n            return cryptoCheck ? sid : 'SF' + sid;\n        },\n        intendedObject = function (key, value, fn_, ctx) {\n            var fn = fn_,\n                obj = isObject(key) ? key : BOOLEAN_FALSE;\n            if (obj) {\n                each(obj, reverseParams(fn), ctx);\n            } else {\n                if (ctx) {\n                    fn = bindTo(fn, ctx);\n                }\n                fn(key, value);\n            }\n        },\n        /**\n         * @func\n         */\n        /** wrapper for advisibility to be calculated by outside framework */\n        adVisibility = function (adObj) {\n            adObj.set(app.modules.visibility(adObj.el));\n        },\n        /**\n         * @func\n         */\n        getReference = function (str) {\n            var match;\n            if (!isString(str)) {\n                str = str.referrer;\n            }\n            match = str.match(/^https?:\\/\\/.*?\\//);\n            if (match) {\n                match = match[0];\n            }\n            return match || '';\n        },\n        /**\n         * @func\n         */\n        roundFloat = function (val, power, base) {\n            var mult;\n            if (!isNumber(power)) {\n                power = 1;\n            }\n            mult = Math.pow(base || 10, power);\n            return (parseInt((mult * val), 10) / mult);\n        },\n        /**\n         * @func\n         */\n        cssTemplater = function (str, obj) {\n            str += '';\n            each(obj, function (key, val) {\n                str = str.split('\\\\\\\\' + key + '\\\\\\\\').join(val);\n            });\n            return str;\n        },\n        png = pngString,\n        /**\n         * @func\n         */\n        simpleObject = function (key, value) {\n            var obj = {};\n            obj[key] = value;\n            return obj;\n        },\n        objCondense = function () {\n            var skip = 0,\n                obj = {};\n            duff(arguments, function (arg, idx, args) {\n                if (!skip) {\n                    skip++;\n                    if (isString(arg)) {\n                        skip++;\n                        obj[arg] = args[idx + 1];\n                    }\n                    if (isObject(arg)) {\n                        extend(obj, arg);\n                    }\n                }\n                skip--;\n            });\n            return obj;\n        },\n        reverseParams = function (iteratorFn) {\n            return function (value, key, third) {\n                iteratorFn(key, value, third);\n            };\n        },\n        /**\n         * @func\n         */\n        rip = function (list, ripped) {\n            var obj = {};\n            duff(gapSplit(list), function (val, key) {\n                obj[val] = ripped[val];\n            });\n            return obj;\n        },\n        result = function (obj, str, args) {\n            var rez = obj;\n            if (isObject(obj)) {\n                rez = obj[str];\n                if (isFunction(rez)) {\n                    rez = obj[str].apply(obj, args || []);\n                }\n            }\n            return rez;\n        },\n        resultOf = function (item, ctx, args) {\n            return _.isFunction(item) ? item.apply(ctx, args || []) : item;\n        },\n        maths = Math,\n        mathArray = function (method) {\n            return function (args) {\n                return maths[method].apply(maths, args);\n            };\n        },\n        mathMix = function (key) {\n            var doIt = function (x, mult) {\n                var ret;\n                if (isArrayLike(x)) {\n                    ret = Math[key].apply(Math, x);\n                } else {\n                    ret = Math[key](x * mult);\n                    ret = ret / mult;\n                }\n                return ret;\n            };\n            return function (thing, mult) {\n                if (!isNumber(mult)) {\n                    mult = 1;\n                }\n                if (isNumber(thing) || isString(thing)) {\n                    return doIt(thing, mult);\n                } else {\n                    return duff(thing, function (val, key, obj) {\n                        obj[key] = doIt(val, mult);\n                    });\n                }\n            };\n        },\n        floor = mathMix('floor'),\n        ceil = mathMix('ceil'),\n        ensureFunction = function (fn) {\n            return function (_fn) {\n                _fn = _fn || function () {};\n                return fn.call(this, _fn);\n            };\n        };\n    // cssResetString = 'a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:\"\";content:none}table{border-collapse:collapse;border-spacing:0}'\n    /**\n     * @class Model\n     */\n    function Model(attributes, secondary) {\n        return this;\n    }\n    factories.Model = Model;\n    Model.prototype = {};\n    makeExtendFrom('Model', factories.Model);\n    Model.extend = constructorExtend;\n    _ = app._ = {\n        noop: function () {},\n        monthNames: gapSplit('january feburary march april may june july august september october november december'),\n        possibleEvents: gapSplit('context timings impression impression_image delivered_impression viewable_impression asset_impression goal timer expanded_time auto_expand auto_contract auto_close auto_video_play auto_video_stop counter'),\n        possibleInteractions: gapSplit('click hover_count hover_time expand contract close open_panel exit video_play video_stop'),\n        weekdays: gapSplit('sunday monday tuesday wednesday thursday friday saturday'),\n        ignoreAssetTags: gapSplit('script link style meta title head'),\n        constructorWrapper: constructorWrapper,\n        stringifyQuery: stringifyQuery,\n        intendedObject: intendedObject,\n        ensureFunction: ensureFunction,\n        objectCondense: objCondense,\n        parseDecimal: parseDecimal,\n        adVisibility: adVisibility,\n        getReference: getReference,\n        cssTemplater: cssTemplater,\n        simpleObject: simpleObject,\n        isArrayLike: isArrayLike,\n        objCondense: objCondense,\n        isInstance: isInstance,\n        hasEnumBug: hasEnumBug,\n        roundFloat: roundFloat,\n        extendFrom: extendFrom,\n        factories: factories,\n        listSlice: listSlice,\n        fullClone: fullClone,\n        pngString: pngString,\n        parseBool: parseBool,\n        stringify: stringify,\n        getLen: getLength,\n        splitGen: splitGen,\n        gapSplit: gapSplit,\n        uniqueId: uniqueId,\n        property: property,\n        toString: toString,\n        throttle: throttle,\n        debounce: debounce,\n        protoProp: protoProp,\n        reverse: reverse,\n        indexOf: indexOf,\n        joinGen: joinGen,\n        toArray: toArray,\n        isEqual: isEqual,\n        unshift: unshift,\n        gapJoin: gapJoin,\n        isArray: isArray,\n        isEmpty: isEmpty,\n        modules: {},\n        listHas: listHas,\n        isBlank: isBlank,\n        isUndefined: isBlank,\n        splice: splice,\n        isBoolean: isBoolean,\n        invert: invert,\n        extend: extend,\n        makeId: makeId,\n        nowish: nowish,\n        now: nowish,\n        map: map,\n        result: result,\n        isNull: isNull,\n        merge: merge,\n        fetch: fetch,\n        split: split,\n        clone: clone,\n        isObject: isObject,\n        isNaN: isNaN,\n        isNumber: isNumber,\n        isFinite: isFinite,\n        isString: isString,\n        parse: parse,\n        shift: shift,\n        eachProxy: eachProxy,\n        exports: exports,\n        slice: slice,\n        bind: bind,\n        bindTo: bindTo,\n        duff: duff,\n        sort: sort,\n        join: join,\n        wrap: wrap,\n        isFunction: isFunction,\n        uuid: uuid,\n        allKeys: allKeys,\n        keys: keys,\n        once: once,\n        each: each,\n        push: push,\n        pop: pop,\n        len: getLength,\n        has: has,\n        rip: rip,\n        png: png,\n        negate: negate,\n        pI: pI,\n        math: {},\n        resultOf: resultOf,\n        createPredicateIndexFinder: createPredicateIndexFinder,\n        findIndex: findIndex,\n        findLastIndex: findLastIndex,\n        validKey: validKey,\n        finder: finder,\n        find: find,\n        findLast: findLast\n    };\n    duff(gapSplit('E LN2 LN10 LOG2E LOG10E PI SQRT1_2 SQRT2 abs acos acosh asin asinh atan atan2 atanh cbrt ceil clz32 cos cosh exp expm1 floor fround hypot imul log log1p log2 log10 max min pow random round sign sin sinh sqrt tan tanh trunc'), function (key) {\n        _[key] = _.math[key] = Math[key];\n    });\n    exports({\n        floor: floor,\n        ceil: ceil,\n        min: mathArray('min'),\n        max: mathArray('max')\n    });\n});","application.scope(function (app) {\n    app.shims = function (win) {\n        var fn = function () {\n            var win = this,\n                lengthString = 'length';\n            win.performance = win.performance || {};\n            win.performance.now = (function () {\n                var performance = win.performance;\n                return performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {\n                    return new Date().getTime();\n                };\n            })();\n\n            function f(n) {\n                return n < 10 ? \"0\" + n : n;\n            }\n\n            function quote(string) {\n                escapable.lastIndex = 0;\n                return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n                    var c = meta[a];\n                    return typeof c === \"string\" ? c : \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n                }) + '\"' : '\"' + string + '\"';\n            }\n\n            function str(key, holder) {\n                var i, k, v, length, mind = gap,\n                    partial, value = holder[key];\n                if (value && typeof value === \"object\" && typeof value.toJSON === \"function\") {\n                    value = value.toJSON(key);\n                }\n                if (typeof rep === \"function\") {\n                    value = rep.call(holder, key, value);\n                }\n                switch (typeof value) {\n                case \"string\":\n                    return quote(value);\n                case \"number\":\n                    return isFinite(value) ? String(value) : \"null\";\n                case \"boolean\":\n                case \"null\":\n                    return String(value);\n                case \"object\":\n                    if (!value) {\n                        return \"null\";\n                    }\n                    gap += indent;\n                    partial = [];\n                    if (Object.prototype.toString.apply(value) === \"[object Array]\") {\n                        length = value[lengthString];\n                        for (i = 0; i < length; i += 1) {\n                            partial[i] = str(i, value) || \"null\";\n                        }\n                        v = partial[lengthString] === 0 ? \"[]\" : gap ? \"[\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"]\" : \"[\" + partial.join(\",\") + \"]\";\n                        gap = mind;\n                        return v;\n                    }\n                    if (rep && typeof rep === \"object\") {\n                        length = rep[lengthString];\n                        for (i = 0; i < length; i += 1) {\n                            if (typeof rep[i] === \"string\") {\n                                k = rep[i];\n                                v = str(k, value);\n                                if (v) {\n                                    partial.push(quote(k) + (gap ? \": \" : \":\") + v);\n                                }\n                            }\n                        }\n                    } else {\n                        for (k in value) {\n                            if (Object.prototype.hasOwnProperty.call(value, k)) {\n                                v = str(k, value);\n                                if (v) {\n                                    partial.push(quote(k) + (gap ? \": \" : \":\") + v);\n                                }\n                            }\n                        }\n                    }\n                    v = partial[lengthString] === 0 ? \"{}\" : gap ? \"{\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"}\" : \"{\" + partial.join(\",\") + \"}\";\n                    gap = mind;\n                    return v;\n                }\n            }\n            if (!JSON) {\n                if (typeof Date.prototype.toJSON !== \"function\") {\n                    Date.prototype.toJSON = function (key) {\n                        return isFinite(this.valueOf()) ? this.getUTCFullYear() + \"-\" + f(this.getUTCMonth() + 1) + \"-\" + f(this.getUTCDate()) + \"T\" + f(this.getUTCHours()) + \":\" + f(this.getUTCMinutes()) + \":\" + f(this.getUTCSeconds()) + \"Z\" : null;\n                    };\n                    String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function (key) {\n                        return this.valueOf();\n                    };\n                }\n                var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n                    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n                    gap, indent, meta = {\n                        \"\\b\": \"\\\\b\",\n                        \"\\t\": \"\\\\t\",\n                        \"\\n\": \"\\\\n\",\n                        \"\\f\": \"\\\\f\",\n                        \"\\r\": \"\\\\r\",\n                        '\"': '\\\\\"',\n                        \"\\\\\": \"\\\\\\\\\"\n                    },\n                    rep;\n                if (typeof JSON.stringify !== \"function\") {\n                    JSON.stringify = function (value, replacer, space) {\n                        var i;\n                        gap = \"\";\n                        indent = \"\";\n                        if (typeof space === \"number\") {\n                            for (i = 0; i < space; i += 1) {\n                                indent += \" \";\n                            }\n                        } else {\n                            if (typeof space === \"string\") {\n                                indent = space;\n                            }\n                        }\n                        rep = replacer;\n                        if (replacer && typeof replacer !== \"function\" && (typeof replacer !== \"object\" || typeof replacer[lengthString] !== \"number\")) {\n                            throw new Error(\"JSON.stringify\");\n                        }\n                        return str(\"\", {\n                            \"\": value\n                        });\n                    };\n                }\n                if (typeof JSON.parse !== \"function\") {\n                    JSON.parse = function (text, reviver) {\n                        var j;\n\n                        function walk(holder, key) {\n                            var k, v, value = holder[key];\n                            if (value && typeof value === \"object\") {\n                                for (k in value) {\n                                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                                        v = walk(value, k);\n                                        if (v !== undefined) {\n                                            value[k] = v;\n                                        } else {\n                                            delete value[k];\n                                        }\n                                    }\n                                }\n                            }\n                            return reviver.call(holder, key, value);\n                        }\n                        text = String(text);\n                        cx.lastIndex = 0;\n                        if (cx.test(text)) {\n                            text = text.replace(cx, function (a) {\n                                return \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n                            });\n                        }\n                        if (/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, \"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, \"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g, \"\"))) {\n                            j = Function.prototype.constructor(\"(\" + text + \")\");\n                            return typeof reviver === \"function\" ? walk({\n                                \"\": j\n                            }, \"\") : j;\n                        }\n                        throw new SyntaxError(\"JSON.parse\");\n                    };\n                }\n            }\n            if (!Function.prototype.bind) {\n                Function.prototype.bind = function (oThis) {\n                    if (typeof this !== 'function') {\n                        // closest thing possible to the ECMAScript 5\n                        // internal IsCallable function\n                        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n                    }\n                    var aArgs = Array.prototype.slice.call(arguments, 1),\n                        fToBind = this,\n                        FNOP = function () {},\n                        fBound = function () {\n                            return fToBind.apply(this instanceof FNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n                        };\n                    if (this.prototype) {\n                        // native functions don't have a prototype\n                        FNOP.prototype = this.prototype;\n                    }\n                    fBound.prototype = new FNOP();\n                    return fBound;\n                };\n            }\n            window.matchMedia = window.matchMedia || function () {\n                // \"use strict\";\n                // For browsers that support matchMedium api such as IE 9 and webkit\n                var styleMedia = (window.styleMedia || window.media);\n                // For those that don't support matchMedium\n                if (!styleMedia) {\n                    var style = document.createElement('style'),\n                        script = document.getElementsByTagName('script')[0],\n                        info = null;\n                    style.type = 'text/css';\n                    style.id = 'matchmediajs-test';\n                    script.parentNode.insertBefore(style, script);\n                    // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n                    info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;\n                    styleMedia = {\n                        matchMedium: function (media) {\n                            var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\n                            // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n                            if (style.styleSheet) {\n                                style.styleSheet.cssText = text;\n                            } else {\n                                style.textContent = text;\n                            }\n                            // Test if media query is true or false\n                            return info.width === '1px';\n                        }\n                    };\n                }\n                return function (media) {\n                    media = media || 'all';\n                    return {\n                        matches: styleMedia.matchMedium(media),\n                        media: media\n                    };\n                };\n            }();\n        };\n        fn.call(win);\n    };\n    app.shims(window);\n});","application.scope(function (app) {\n    var blank, _ = app._,\n        toArray = _.toArray,\n        map = _.map,\n        indexOf = _.indexOf,\n        gapSplit = _.gapSplit,\n        isString = _.isString,\n        slice = _.slice,\n        split = _.split,\n        getLength = _.len,\n        lengthString = 'length',\n        falseBool = false,\n        has = _.has,\n        join = _.join,\n        cacheable = function (fn) {\n            var cache = {};\n            return function (input) {\n                if (!has(cache, input)) {\n                    cache[input] = fn.apply(this, arguments);\n                }\n                return cache[input];\n            };\n        },\n        categoricallyCacheable = function (fn, baseCategory) {\n            var cache = {};\n            return function (string, category) {\n                var cacher;\n                category = category || baseCategory;\n                cacher = cache[category] = cache[category] || cacheable(fn(category));\n                return cacher(string);\n            };\n        },\n        string = _.extend(_.wrap(gapSplit('toLowerCase toUpperCase trim'), function (method) {\n            return cacheable(function (item) {\n                return item[method]();\n            });\n        }), _.wrap(gapSplit('indexOf match search'), function (method) {\n            return categoricallyCacheable(function (input) {\n                return function (item) {\n                    return item[method](input);\n                };\n            });\n        })),\n        wrapAll = function (fn) {\n            return function () {\n                var args = toArray(arguments),\n                    ctx = this;\n                return map(args[0], function (thing) {\n                    args[0] = thing;\n                    return fn.apply(ctx, args);\n                });\n            };\n        },\n        deprefix = function (str, prefix, unUpcase) {\n            var nuStr = str.slice(getLength(prefix)),\n                first = nuStr[0];\n            if (unUpcase) {\n                first = nuStr[0].toLowerCase();\n            }\n            nuStr = first + nuStr.slice(1);\n            return nuStr;\n        },\n        deprefixAll = wrapAll(deprefix),\n        prefix = function (str, prefix, camelcase, splitter) {\n            var myStr = prefix + str;\n            if (camelcase !== blank) {\n                myStr = prefix + (splitter || '-') + str;\n                if (camelcase) {\n                    myStr = camelCase(myStr, splitter);\n                } else {\n                    myStr = unCamelCase(myStr, splitter);\n                }\n            }\n            return myStr;\n        },\n        prefixAll = wrapAll(prefix),\n        parseObject = (function () {\n            var cache = {};\n            return function (string) {\n                var found = cache[string];\n                if (!found) {\n                    cache[string] = found = new Function.constructor('return ' + string);\n                }\n                return found();\n            };\n        }()),\n        /**\n         * @func\n         */\n        camelCase = categoricallyCacheable(function (splitter) {\n            return function (str) {\n                var i, s, val;\n                if (isString(str)) {\n                    if (str[0] === splitter) {\n                        str = slice(str, 1);\n                    }\n                    s = split(str, splitter);\n                    for (i = getLength(s) - 1; i >= 1; i--) {\n                        if (s[i]) {\n                            s[i] = upCase(s[i]);\n                        }\n                    }\n                    val = join(s, '');\n                }\n                return val;\n            };\n        }, '-'),\n        /**\n         * @func\n         */\n        upCase = cacheable(function (s) {\n            return s[0].toUpperCase() + slice(s, 1);\n        }),\n        /**\n         * @func\n         */\n        unCamelCase = categoricallyCacheable(function (splitter) {\n            return function (str) {\n                return str.replace(/([a-z])([A-Z])/g, '$1' + splitter + '$2').replace(/[A-Z]/g, function (s) {\n                    return s.toLowerCase();\n                });\n            };\n        }, '-'),\n        /**\n         * @func\n         */\n        customUnits = categoricallyCacheable(function (unitList_) {\n            var unitList = gapSplit(unitList_);\n            return function (str) {\n                var i, ch, unitStr, unit = [];\n                // make sure it's a string\n                str += '';\n                // make sure there is no trailing whitespace\n                str = str.trim();\n                i = str[lengthString];\n                // work from the back\n                while (str[--i]) {\n                    // for (i = str[lengthString] - 1; i >= 0; i--) {\n                    unit.unshift(str[i]);\n                    unitStr = unit.join('');\n                    if (indexOf(unitList, unitStr) >= 0) {\n                        if (unitStr === 'em') {\n                            if (str[i - 1] === 'r') {\n                                unitStr = 'rem';\n                            }\n                        }\n                        if (unitStr === 'in') {\n                            if (str[i - 2] === 'v' && str[i - 1] === 'm') {\n                                unitStr = 'vmin';\n                            }\n                        }\n                        return unitStr;\n                    }\n                }\n                return falseBool;\n            };\n        }),\n        baseUnitList = gapSplit('px em ex in cm % vh vw pc pt mm vmax vmin'),\n        units = function (str) {\n            return customUnits(str, baseUnitList);\n        },\n        isHttp = function (str) {\n            var ret = !1;\n            if ((str.indexOf('http') === 0 && str.split('//').length >= 2) || str.indexOf('//') === 0) {\n                ret = !0;\n            }\n            return ret;\n        },\n        parseHash = function (url) {\n            var hash = '',\n                hashIdx = indexOf(url, '#') + 1;\n            if (hashIdx) {\n                hash = url.slice(hashIdx - 1);\n            }\n            return hash;\n        },\n        parseURL = function (url) {\n            var firstSlash, hostSplit, originNoProtocol, search = '',\n                hash = '',\n                host = '',\n                pathname = '',\n                protocol = '',\n                port = '',\n                hostname = '',\n                origin = url,\n                searchIdx = indexOf(url, '?') + 1,\n                searchObject = {},\n                protocols = ['http', 'https', 'file', 'about'],\n                protocolLength = protocols.length,\n                doubleSlash = '//';\n            if (searchIdx) {\n                search = url.slice(searchIdx - 1);\n                origin = origin.split(search).join('');\n                hash = parseHash(search);\n                search = search.split(hash).join('');\n                searchObject = app.parseSearch(search);\n            } else {\n                hash = parseHash(url);\n                origin = origin.split(hash).join('');\n            }\n            if (url[0] === '/' && url[1] === '/') {\n                protocol = window.location.protocol;\n                url = protocol + url;\n                origin = protocol + origin;\n            } else {\n                while (protocolLength-- && !protocol) {\n                    if (url.slice(0, protocols[protocolLength].length) === protocols[protocolLength]) {\n                        protocol = protocols[protocolLength];\n                    }\n                }\n                if (!protocol) {\n                    protocol = 'http';\n                }\n                protocol += ':';\n                if (origin.slice(0, protocol.length) + doubleSlash !== protocol + doubleSlash) {\n                    url = protocol + doubleSlash + url;\n                    origin = protocol + doubleSlash + origin;\n                }\n            }\n            originNoProtocol = origin.split(protocol + doubleSlash).join('');\n            firstSlash = indexOf(originNoProtocol, '/') + 1;\n            pathname = originNoProtocol.slice(firstSlash - 1);\n            host = originNoProtocol.slice(0, firstSlash - 1);\n            origin = origin.split(pathname).join('');\n            hostSplit = host.split(':');\n            hostname = hostSplit.shift();\n            port = hostSplit.join(':');\n            return {\n                port: port,\n                hostname: hostname,\n                pathname: pathname,\n                search: search,\n                host: host,\n                hash: hash,\n                href: url,\n                protocol: protocol,\n                origin: origin,\n                searchObject: searchObject\n            };\n        };\n    _.exports({\n        deprefix: deprefix,\n        deprefixAll: deprefixAll,\n        prefix: prefix,\n        prefixAll: prefixAll,\n        upCase: upCase,\n        unCamelCase: unCamelCase,\n        camelCase: camelCase,\n        cacheable: cacheable,\n        categoricallyCacheable: categoricallyCacheable,\n        units: units,\n        string: string,\n        baseUnitList: baseUnitList,\n        customUnits: customUnits,\n        isHttp: isHttp,\n        parseHash: parseHash,\n        parseURL: parseURL,\n        parseObject: parseObject\n    });\n});","application.scope(function (app) {\n    var blank, _ = app._,\n        extendFrom = _.extendFrom,\n        factories = _.factories,\n        isObject = _.isObject,\n        isNumber = _.isNumber,\n        isFunction = _.isFunction,\n        lengthString = 'length',\n        itemsString = '_items',\n        previousString = '_previous',\n        each = _.each,\n        duff = _.duff,\n        push = _.push,\n        wrap = _.wrap,\n        keys = _.keys,\n        find = _.find,\n        map = _.map,\n        stringify = _.stringify,\n        findLast = _.findLast,\n        allKeys = _.allKeys,\n        splice = _.splice,\n        toArray = _.toArray,\n        gapSplit = _.gapSplit,\n        getLength = _.getLen,\n        sort = _.sort,\n        bindTo = _.bindTo,\n        isArrayLike = _.isArrayLike,\n        eachCall = function (array, method) {\n            return duff(array, function (item) {\n                _.result(item, method);\n            });\n        },\n        eachRevCall = function (array, method) {\n            return duff(array, function (item) {\n                _.result(item, method);\n            }, null, -1);\n        },\n        unshiftContext = function (fn, ctx) {\n            return function () {\n                var args = toArray(arguments);\n                args.unshift(this);\n                return fn.call(ctx || this, args, arguments);\n            };\n        },\n        doToEverything = function (doLater, direction) {\n            return function () {\n                var args = _.toArray(arguments);\n                var one = args.shift();\n                duff(args, function (items) {\n                    duff(items, function (item) {\n                        doLater.call(_, one, item);\n                    }, null, direction || 1);\n                });\n                return one;\n            };\n        },\n        /**\n         * @func\n         */\n        remove = function (list, item, lookAfter) {\n            var index = posit(list, item, lookAfter);\n            if (index) {\n                removeAt(list, index - 1);\n            }\n            return !!index;\n        },\n        removeAll = doToEverything(remove, -1),\n        removeAt = function (list, index) {\n            return splice(list, index, 1)[0];\n        },\n        add = function (list, item) {\n            var val = 0,\n                index = posit(list, item);\n            if (!index) {\n                val = push(list, item);\n            }\n            return !!val;\n        },\n        addAll = doToEverything(add),\n        addAt = function (list, item, index) {\n            var len = list[lengthString],\n                lastIdx = len || 0;\n            splice(list, index || 0, 0, item);\n            return len !== list[lengthString];\n        },\n        range = function (start, stop, step, inclusive) {\n            var length, range, idx;\n            if (stop === null || stop === void 0) {\n                stop = start || 0;\n                start = 0;\n            }\n            if (!isFinite(start) || !_.isNumber(start)) {\n                start = 0;\n            }\n            step = +step || 1;\n            length = Math.max(Math.ceil((stop - start) / step), 0) + (+inclusive || 0);\n            range = [];\n            idx = 0;\n            while (idx < length) {\n                range[idx] = start;\n                idx++;\n                start += step;\n            }\n            return range;\n        },\n        count = function (list, start, end, runner) {\n            var obj, idx, ctx = this;\n            if (start < end && _.isNumber(start) && _.isNumber(end) && isFinite(start) && isFinite(end)) {\n                end = Math.abs(end);\n                idx = start;\n                while (idx < end) {\n                    obj = null;\n                    if (_.has(list, idx)) {\n                        obj = list[idx];\n                    }\n                    runner.call(ctx, obj, idx, list);\n                    idx++;\n                }\n            }\n            return list;\n        },\n        // array, startIndex, endIndex\n        subset = function (list, startIdx, endIdx) {\n            var ret = [];\n            find(list, function (idx, item) {\n                if (startIdx === idx) {\n                    open = true;\n                    startIdx = idx;\n                }\n                if (idx >= startIdx + limit) {\n                    return true;\n                }\n                if (open) {\n                    ret.push(model);\n                }\n            });\n            // return foldl(list, function(memo,item,idx){\n            //     return memo;\n            // },[]);\n        },\n        listFromMixed = function (obj) {\n            if (!hasArrayNature(obj)) {\n                return [obj];\n            } else if (Array.isArray(obj)) {\n                return obj.slice();\n            } else {\n                return toArray(obj);\n            }\n        },\n        /**\n         * @func\n         */\n        closest = function (list, target) {\n            var match, path, diff, valuesLen, possible, i = 0,\n                previousAbs = Infinity;\n            // trying to avoid running through 20 matchs\n            // when i'm already at the exact one\n            if (isArrayLike(list)) {\n                valuesLen = getLength(list);\n                if (valuesLen === 1) {\n                    match = list[0];\n                }\n                if (_.indexOf(list, target) !== -1) {\n                    match = target;\n                }\n                if (!match) {\n                    // try doing this later with no sorting\n                    sort(list);\n                    for (i = valuesLen - 1;\n                        (i >= 0 && !match); i--) {\n                        path = list[i];\n                        diff = Math.abs(target - path);\n                        if (diff < previousAbs) {\n                            possible = path;\n                            previousAbs = diff;\n                        }\n                    }\n                    match = possible;\n                }\n                if (!match) {\n                    match = target;\n                }\n            }\n            return match;\n        },\n        countTo = function (list, num, runner) {\n            return count(list, 0, num, runner);\n        },\n        countFrom = function (list, num, runner) {\n            return count(list, num, list.length, runner);\n        },\n        /**\n         * @func\n         */\n        posit = function (list, item, lookAfter) {\n            return _.indexOf(list, item, lookAfter) + 1;\n        },\n        /**\n         * @func\n         */\n        concat = function () {\n            var array = [];\n            duff(arguments, function (arg) {\n                duff(arg, function (item) {\n                    array.push(item);\n                });\n            });\n            return array;\n        },\n        /**\n         * @func\n         */\n        concatUnique = function () {\n            var array = [],\n                all = concat.apply(null, arguments);\n            duff(all, function (item) {\n                if (!posit(array, item)) {\n                    array.push(item);\n                }\n            });\n            return array;\n        },\n        cycle = function (arr, num) {\n            var piece, len = getLength(arr);\n            if (_.isNumber(len)) {\n                num = num % len;\n                piece = arr.splice(num);\n                arr.unshift.apply(arr, piece);\n            }\n            return arr;\n        },\n        internalMambo = function (fn) {\n            return function (arr) {\n                arr.reverse();\n                fn.apply(this, arguments);\n                arr.reverse();\n                return arr;\n            };\n        },\n        // Returns whether an object has a given set of `key:value` pairs.\n        isMatch = function (object, attrs) {\n            var key, i = 0,\n                keys = _.keys(attrs),\n                obj = Object(object);\n            return !find(keys, function (val) {\n                if (attrs[val] !== obj[val] || !(val in obj)) {\n                    return true;\n                }\n            });\n        },\n        // Returns a predicate for checking whether an object has a given set of\n        // `key:value` pairs.\n        matches = function (obj1) {\n            return function (obj2) {\n                return isMatch(obj2, obj1);\n            };\n        },\n        uncycle = internalMambo(cycle),\n        externalMambo = internalMambo(function (list, fn) {\n            return fn.apply(this, arguments);\n        }),\n        pluck = function (arr, key) {\n            var items = [];\n            duff(arr, function (item) {\n                if (isObject(item)) {\n                    if (item[key] !== void 0) {\n                        items.push(item[key]);\n                    }\n                }\n            });\n            return items;\n        },\n        // Convenience version of a common use case of `filter`: selecting only objects\n        // containing specific `key:value` pairs.\n        where = function (obj, attrs) {\n            return filter(obj, matches(attrs));\n        },\n        // Convenience version of a common use case of `find`: getting the first object\n        // containing specific `key:value` pairs.\n        findWhere = function (obj, attrs) {\n            return find(obj, matches(attrs));\n        },\n        // Convenience version of a common use case of `find`: getting the first object\n        // containing specific `key:value` pairs.\n        findLastWhere = function (obj, attrs) {\n            return findLast(obj, matches(attrs));\n        },\n        whereNot = function (obj, attrs) {\n            return filter(obj, _.negate(matches(attrs)));\n        },\n        flatten = function () {\n            return foldl(arguments, function (memo, item) {\n                if (isArrayLike(item)) {\n                    memo = memo.concat(flatten.apply(null, item));\n                } else {\n                    memo.push(item);\n                }\n                return memo;\n            }, []);\n        },\n        splat = function (fn, spliceat) {\n            spliceat = spliceat || 0;\n            return function () {\n                var ctx = this,\n                    arr = toArray(arguments),\n                    args = splice(arr, spliceat);\n                // return duff(args, fn, this, arr);\n                duff(args, function (idx, item, list) {\n                    fn.apply(ctx, arr.concat([idx, item, list]));\n                });\n            };\n        },\n        merge = splat(function (item, idx, list) {\n            var len, collection = this,\n                last = getLength(collection);\n            if (isArrayLike(item)) {\n                len = getLength(item);\n                duff(item, function (key, val) {\n                    if (val !== void 0) {\n                        // removes any undefined items\n                        len = key + 1;\n                        collection[key] = val;\n                    }\n                });\n                if (len > (last || 0)) {\n                    collection[lengthString] = len;\n                }\n            }\n        }),\n        eq = function (list, num) {\n            var n, thisNum, items = [],\n                numb = num || 0,\n                evaluatedIsNumber = isNumber(numb),\n                isArray = isArrayLike(numb);\n            if (numb < 0) {\n                evaluatedIsNumber = !1;\n            }\n            if (getLength(list)) {\n                if (evaluatedIsNumber) {\n                    items = [list[numb]];\n                }\n                if (isArray) {\n                    items = _.clone(numb);\n                }\n                if (!isArray && !evaluatedIsNumber && list[0]) {\n                    items = [list[0]];\n                }\n            }\n            return items;\n        },\n        tackRev = function (fn, index, ctx) {\n            return function () {\n                var args = toArray(arguments);\n                while (args.length < index) {\n                    // fill it out with null\n                    args.push(null);\n                }\n                // put -1 on as the last arg\n                args.push(-1);\n                return fn.apply(ctx || _, args);\n            };\n        },\n        duffRev = tackRev(duff, 3),\n        eachRev = tackRev(each, 3),\n        recreateSelf = function (fn, ctx) {\n            return function () {\n                return new this.__constructor__(fn.apply(ctx || this, arguments));\n            };\n        },\n        /**\n         * @func\n         */\n        // Create a reducing function iterating left or right.\n        createReduce = function (dir) {\n            // Optimized iterator function as using arguments[lengthString]\n            // in the main function will deoptimize the, see #1991.\n            var iterator = function (obj, iteratee, memo, keys, index, length) {\n                var currentKey;\n                for (; index >= 0 && index < length; index += dir) {\n                    currentKey = keys ? keys[index] : index;\n                    memo = iteratee(memo, obj[currentKey], currentKey, obj);\n                }\n                return memo;\n            };\n            return function (obj, iteratee, memo, context) {\n                // iteratee = optimizeCb(iteratee, context, 4);\n                var actualKeys = !isArrayLike(obj) && keys(obj),\n                    length = getLength(actualKeys || obj),\n                    index = dir > 0 ? 0 : length - 1;\n                // Determine the initial value if none is provided.\n                if (getLength(arguments) < 3) {\n                    memo = obj[actualKeys ? actualKeys[index] : index];\n                    index += dir;\n                }\n                return iterator(obj, iteratee, memo, actualKeys, index, length);\n            };\n        },\n        // **Reduce** builds up a single result from a list of values, aka `inject`,\n        // or `foldl`.\n        /**\n         * @func\n         */\n        foldl = createReduce(1),\n        // The right-associative version of reduce, also known as `foldr`.\n        /**\n         * @func\n         */\n        foldr = createReduce(-1),\n        /**\n         * @func\n         */\n        filter = function (obj, iteratee, context) {\n            var isArrayResult = isArrayLike(obj),\n                bound = bindTo(iteratee, context),\n                runCount = 0;\n            return foldl(obj, function (memo, item, key, all) {\n                runCount++;\n                if (bound(item, key, all)) {\n                    if (isArrayResult) {\n                        memo.push(item);\n                    } else {\n                        memo[key] = item;\n                    }\n                }\n                return memo;\n            }, isArrayResult ? [] : {});\n        },\n        unwrapper = function (fn) {\n            return function (args) {\n                args[0] = args[0][itemsString];\n                return fn.call(this, args);\n            };\n        },\n        unwrapInstance = function (instance_) {\n            var instance = instance_;\n            if (_.isInstance(instance, _.Collection)) {\n                instance = instance.un();\n            }\n            return instance;\n        },\n        unwrapAll = function (fn) {\n            return function (args) {\n                duff(args, function (arg, idx, args) {\n                    args[idx] = unwrapInstance(arg);\n                });\n                return fn.call(this, args);\n            };\n        },\n        unwrap = function () {\n            return this[itemsString];\n        },\n        applyToSelf = function (fn) {\n            return function () {\n                return fn.apply(this, this[itemsString]);\n            };\n        },\n        lengthFn = function () {\n            return this[itemsString][lengthString];\n        },\n        wrappedCollectionMethods = _.extend(wrap({\n            each: duff,\n            duff: duff,\n            forEach: duff,\n            eachRev: duffRev,\n            duffRev: duffRev,\n            forEachRev: duffRev\n        }, function (fn, val) {\n            return function (iterator) {\n                fn(this[itemsString], iterator, this);\n                return this;\n            };\n        }), wrap(gapSplit('addAll removeAll'), function (name) {\n            return function () {\n                // unshiftContext\n                var args = toArray(arguments);\n                args.unshift(this);\n                // unwrapAll\n                duff(args, function (arg, idx, args) {\n                    if (arg instanceof Collection) {\n                        arg = arg.un();\n                    }\n                    args[idx] = arg;\n                });\n                // custom\n                _[name].apply(_, args);\n                return this;\n            };\n        }), wrap(gapSplit('sort unshift push cycle uncycle reverse count countTo countFrom eachCall eachRevCall'), function (name) {\n            return function () {\n                // unshiftContext\n                var args = toArray(arguments);\n                args.unshift(this[itemsString]);\n                // unwrapper\n                // custom\n                _[name].apply(_, args);\n                return this;\n            };\n        }), wrap(gapSplit('has add addAt remove removeAt pop shift indexOf find findLast findWhere findLastWhere posit foldr foldl reduce'), function (name) {\n            return function () {\n                // unshiftContext\n                var args = toArray(arguments);\n                args.unshift(this[itemsString]);\n                // custom\n                return _[name].apply(_, args);\n            };\n        }), wrap(gapSplit('merge eq map filter pluck where whereNot'), function (name) {\n            // always responds with an array\n            return function () {\n                // unshiftContext\n                var args = toArray(arguments);\n                args.unshift(this[itemsString]);\n                // unwrapper\n                // custom\n                return new Collection(_[name].apply(_, args));\n            };\n        })),\n        ret = _.exports({\n            eachCall: eachCall,\n            eachRevCall: eachRevCall,\n            closest: closest,\n            // map: map,\n            filter: filter,\n            reduce: foldl,\n            foldl: foldl,\n            foldr: foldr,\n            matches: matches,\n            add: add,\n            addAt: addAt,\n            addAll: addAll,\n            concatUnique: concatUnique,\n            removeAt: removeAt,\n            remove: remove,\n            removeAll: removeAll,\n            cycle: cycle,\n            uncycle: uncycle,\n            mamboWrap: internalMambo,\n            mambo: externalMambo,\n            concat: concat,\n            listMerge: merge,\n            pluck: pluck,\n            where: where,\n            findWhere: findWhere,\n            findLastWhere: findLastWhere,\n            // finder: finder,\n            // find: find,\n            // findLast: findLast,\n            eq: eq,\n            posit: posit,\n            range: range,\n            count: count,\n            countTo: countTo,\n            countFrom: countFrom,\n            whereNot: whereNot,\n            eachRev: eachRev,\n            duffRev: duffRev,\n            unshiftContext: unshiftContext,\n            flatten: flatten\n            // ,\n            // between: between\n        }),\n        BY_ID = '_byId',\n        Collection = extendFrom.Model('Collection', _.extend({\n            un: unwrap,\n            unwrap: unwrap,\n            len: lengthFn,\n            length: lengthFn,\n            range: recreateSelf(range),\n            flatten: recreateSelf(applyToSelf(flatten)),\n            index: function (number) {\n                return this[itemsString][number || 0];\n            },\n            first: recreateSelf(function () {\n                return [this[itemsString][0]];\n            }),\n            last: recreateSelf(function () {\n                var len = this.length();\n                if (len) {\n                    return [this[itemsString][len - 1]];\n                }\n            }),\n            concat: recreateSelf(function () {\n                var args = [],\n                    base = this[itemsString];\n                // this allows us to mix collections with regular arguments\n                return base.concat.apply(base, map(arguments, function (arg) {\n                    return _.Collection(arg)[itemsString];\n                }));\n            }),\n            constructor: function (arr) {\n                var collection = this;\n                if (!_.isArray(arr) && isArrayLike(arr)) {\n                    arr = toArray(arr);\n                }\n                if (arr !== blank && !isArrayLike(arr)) {\n                    arr = [arr];\n                }\n                collection[itemsString] = arr || [];\n                return collection;\n            },\n            toString: function () {\n                return stringify(this);\n            },\n            toJSON: function () {\n                // subtle distinction here\n                return map(this[itemsString], function (item) {\n                    var ret;\n                    if (isObject(item) && _.isFunction(item.toJSON)) {\n                        ret = item.toJSON();\n                    } else {\n                        ret = item;\n                    }\n                    return ret;\n                });\n            },\n            join: function (delimiter) {\n                return this[itemsString].join(delimiter);\n            },\n            get: function (id) {\n                this[BY_ID] = this[BY_ID] || {};\n                return this[BY_ID][id];\n            },\n            /**\n             * @description gets the item on the _byId object or function. If the _byId is a function, than the methods are passed automatically to it to process away\n             * @func\n             * @name Box#find\n             * @param {*} id - usually a string to lookup from the hash. could be an object that will be processed by a function\n             * @returns {*} thing that was being held at that key value on the _byId hash, or whatever the _byId function returns\n             */\n            /**\n             * @description registers a model by the id that is passed\n             * @func\n             * @name Box#register\n             * @param {String} string - key that the object will be registered under\n             * @param {*} thing - anything that you want to store\n             * @returns {Box} instance\n             */\n            register: function (id, thing) {\n                this[BY_ID] = this[BY_ID] || {};\n                this[BY_ID][id] = thing;\n                return this;\n            },\n            // match: objCondense(function () {}),\n            /**\n             * @description adds models to the children array\n             * @param {Object|Object[]} objs - object or array of objects to be passed through the model factory and pushed onto the children array\n             * @param {Object} [secondary] - secondary hash that is common among all of the objects being created. The parent property is automatically overwritten as the object that the add method was called on\n             * @returns {Object|Box} the object that was just created, or the object that the method was called on\n             * @name Box#add\n             * @func\n             */\n            unRegister: function (id) {\n                var box = this,\n                    byid = this[BY_ID] = this[BY_ID] || {},\n                    item = box[BY_ID][id];\n                if (item !== void 0) {\n                    box[BY_ID][id] = blank;\n                }\n                return item;\n            },\n            mambo: function (fn) {\n                var collection = this;\n                externalMambo(collection[itemsString], function () {\n                    fn(collection);\n                });\n                return collection;\n            }\n        }, wrappedCollectionMethods), !0);\n});","application.scope(function (app) {\n    var blank, _ = app._,\n        // extendFrom = app.extendFrom,\n        // factories = app.factories,\n        gapSplit = _.gapSplit,\n        simpleObject = _.simpleObject,\n        isObject = _.isObject,\n        isString = _.isString,\n        isNum = _.isNum,\n        isFunction = _.isFunction,\n        each = _.each,\n        duff = _.duff,\n        isBlank = _.isBlank,\n        duffRev = _.duffRev,\n        push = _.push,\n        has = _.has,\n        map = _.map,\n        isInstance = _.isInstance,\n        camelCase = _.camelCase,\n        intendedObject = _.intendedObject,\n        toArray = _.toArray,\n        clone = _.clone,\n        once = _.once,\n        extend = _.extend,\n        remove = _.remove,\n        property = _.property,\n        stringify = _.stringify,\n        isArrayLike = _.isArrayLike,\n        isArray = _.isArray,\n        upCase = _.upCase,\n        objCondense = _.objCondense,\n        LENGTH = 'length',\n        PARENT = 'parent',\n        internalEventsString = '_events',\n        EVENT_REMOVE = '_removeEventList',\n        currentEventString = '_currentEventList',\n        internalListeningToString = '_listeningTo',\n        modifiedTriggerString = 'alter:',\n        iPISString = 'immediatePropagationIsStopped',\n        seriDataStr = 'serializedData',\n        BOOLEAN_FALSE = !1,\n        BOOLEAN_TRUE = !0,\n        iterateOverObject = function (box, ctx, key, value, iterator, firstarg, allowNonFn) {\n            intendedObject(key, value, function (evnts, funs_) {\n                // only accepts a string or a function\n                var fn = isString(funs_) ? box[funs_] : funs_;\n                if (allowNonFn || isFunction(fn)) {\n                    return duff(gapSplit(evnts), function (eventName) {\n                        var namespace = eventName.split(':')[0];\n                        iterator(box, eventName, {\n                            disabled: !1,\n                            namespace: namespace,\n                            name: eventName,\n                            handler: fn,\n                            ctx: ctx,\n                            origin: box\n                        }, firstarg);\n                    });\n                }\n            });\n        },\n        // user friendly version\n        flattenMatrix = function (iterator, nameOrObjectIndex) {\n            return function () {\n                var names, box = this,\n                    args = toArray(arguments),\n                    handlersIndex = nameOrObjectIndex,\n                    list = args.splice(nameOrObjectIndex),\n                    nameOrObject = list[0];\n                if (!nameOrObjectIndex || args[0]) {\n                    iterateOverObject(box, args[handlersIndex + 1], nameOrObject, list[1], iterator, args[0]);\n                }\n                return box;\n            };\n        },\n        removeEventObject = function (box, arr, handler, ctx) {\n            var current = getCurrentEventList(box);\n            duffRev(arr, function (obj, idx, array) {\n                if ((!handler || obj.handler === handler) && (!ctx || obj.ctx === ctx)) {\n                    // because event triggers are always syncronous,\n                    // we can just wait until the dispatchEvent function is done\n                    if (current[LENGTH]) {\n                        getRemoveList(box).push(obj);\n                    } else {\n                        removeEvent(obj);\n                    }\n                }\n            });\n        },\n        removeEvent = function (evnt) {\n            var listeningTo, listening = evnt.listening;\n            remove(evnt.list, evnt);\n            // disconnect it from the list above it\n            evnt.list = blank;\n            // check to see if it was a listening type\n            if (listening) {\n                // if it was then decrement it\n                listening.count--;\n                if (!listening.count) {\n                    listeningTo = listening.listeningTo;\n                    listeningTo[listening.obj._listenId] = blank;\n                }\n            }\n        },\n        retreiveEventList = function (model, name) {\n            if (!model[internalEventsString]) {\n                model[internalEventsString] = {};\n            }\n            return model[internalEventsString][name];\n        },\n        getRemoveList = function (model) {\n            var list = model[EVENT_REMOVE];\n            if (!list) {\n                list = model[EVENT_REMOVE] = [];\n            }\n            return list;\n        },\n        getCurrentEventList = function (box) {\n            var list = box[currentEventString];\n            if (!list) {\n                list = box[currentEventString] = [];\n            }\n            return list;\n        },\n        attachEventObject = function (obj, name, eventObject) {\n            var events, list;\n            if (isObject(obj)) {\n                eventObject.ctx = eventObject.ctx || eventObject.origin;\n                eventObject.fn = eventObject.fn || eventObject.handler;\n                eventObject.fn = _.bind(eventObject.fn, eventObject.ctx);\n                events = obj[internalEventsString] = obj[internalEventsString] || {};\n                list = events[name] = events[name] || [];\n                // attached so event can remove itself\n                eventObject.list = list;\n                list.push(eventObject);\n            }\n        },\n        extrapolateContext = function (fn) {\n            return function () {\n                var args = toArray(arguments);\n                if (!args[2]) {\n                    args.push(this);\n                }\n                return fn.apply(this, args);\n            };\n        },\n        listenToWrap = function (fn) {\n            return function () {\n                var args = toArray(arguments);\n                if (!args[3]) {\n                    args.push(this);\n                }\n                args = _.cycle(args, 1);\n                return fn.apply(this, args);\n            };\n        },\n        unrollName = function (fn, expectsNameAt) {\n            return function () {\n                var args = toArray(arguments);\n                if (isString(args[expectsNameAt])) {\n                    args[expectsNameAt] = this[args[expectsNameAt]];\n                }\n                fn.apply(this, args);\n            };\n        },\n        retreiveListeningObject = function (thing, obj) {\n            var listeningTo, listening, thisId, id = obj._listenId;\n            if (!id) {\n                id = obj._listenId = _.uniqueId('l');\n            }\n            listeningTo = thing[internalListeningToString] || (thing[internalListeningToString] = {});\n            listening = listeningTo[id];\n            // This object is not listening to any other events on `obj` yet.\n            // Setup the necessary references to track the listening callbacks.\n            if (!listening) {\n                thisId = thing._listenId;\n                if (!thisId) {\n                    thisId = thing._listenId = _.uniqueId('l');\n                }\n                listening = listeningTo[id] = {\n                    obj: obj,\n                    objId: id,\n                    id: thisId,\n                    listeningTo: listeningTo,\n                    ctx: thing,\n                    count: 0\n                };\n            }\n            return listening;\n        },\n        ObjectEvent = _.extendFrom.Model('ObjectEvent', {\n            constructor: function (name, target, data) {\n                var evnt = this;\n                if (isInstance(data, Event)) {\n                    return data;\n                }\n                evnt.bubbles = BOOLEAN_FALSE;\n                evnt.dispatchChildren = BOOLEAN_FALSE;\n                evnt.dispatchTree = BOOLEAN_FALSE;\n                evnt.onMethodName = upCase(camelCase('on:' + name, ':'));\n                evnt.propagationIsStopped = evnt[iPISString] = BOOLEAN_FALSE;\n                evnt.target = target;\n                evnt.name = name;\n                evnt.type = name.split(':')[0];\n                evnt.timestamp = _.now();\n                evnt.data(data);\n                evnt.originalStack = BOOLEAN_TRUE;\n                return evnt;\n            },\n            isStopped: function () {\n                return this.propagationIsStopped || this.immediatePropagationIsStopped;\n            },\n            data: function (arg) {\n                var ret = this[seriDataStr];\n                if (arguments[LENGTH]) {\n                    ret = this[seriDataStr] = _.parse(_.stringify((arg === void 0 || arg === null) ? {} : arg));\n                }\n                this[seriDataStr] = ret;\n                ret = this[seriDataStr];\n                return ret;\n            },\n            get: function (key) {\n                return this[seriDataStr][key];\n            },\n            set: function (key, value) {\n                var evnt = this;\n                intendedObject(key, value, function (key, value) {\n                    evnt[seriDataStr][key] = value;\n                });\n                return this;\n            },\n            stopImmediatePropagation: function () {\n                this.stopPropagation();\n                this[iPISString] = BOOLEAN_TRUE;\n            },\n            stopPropagation: function () {\n                this.propagationIsStopped = BOOLEAN_TRUE;\n            },\n            toJSON: function () {\n                return this.data(this.data());\n            },\n            toString: function () {\n                return stringify(this.toJSON());\n            },\n            preventDefault: function () {\n                this.defaultPrevented = BOOLEAN_TRUE;\n            },\n            action: function (fn) {\n                var evnt = this;\n                evnt._actions = evnt._actions || [];\n                evnt._actions.push(fn);\n                return evnt;\n            },\n            finished: function () {\n                var evnt = this;\n                duff(evnt._actions, function (fn) {\n                    fn(evnt);\n                });\n                evnt.originalStack = BOOLEAN_FALSE;\n            }\n        }),\n        bindOnce = function (box, name, obj) {\n            var fn = obj.handler;\n            obj.fn = _.once(function () {\n                box.off();\n                fn.apply(this, arguments);\n            });\n        },\n        listenToHandler = function (box, name, obj, target) {\n            var listeningObject = retreiveListeningObject(box, target);\n            preBindListeners(obj, listeningObject);\n            attachEventObject(target, name, obj);\n        },\n        onceHandler = function (box, name, obj) {\n            bindOnce(box, name, obj);\n            attachEventObject(box, name, obj);\n        },\n        preBindListeners = function (obj, listening) {\n            listening.count++;\n            obj.listening = listening;\n        },\n        listenToOnceHandler = function (box, name, obj, extra) {\n            bindOnce(box, name, obj);\n            listenToHandler(box, name, obj, extra);\n        },\n        // makeValidEvent = ,\n        getEventList = function (box, name) {\n            var events = box[internalEventsString] = box[internalEventsString] || {};\n            return events[name] || [];\n        },\n        overrideEventCreation = function (obj) {\n            return obj && (obj.bubbles || obj.dispatchChildren || opts.dispatchTree);\n        },\n        Events = _.extendFrom.Model('Events', {\n            /**\n             * @description attach event handlers to the Box event loop\n             * @func\n             * @name Box#on\n             * @param {String} str - event name to listen to\n             * @param {Function|String} fn - event handler or string corresponding to handler on prototype to use for handler\n             * @param {Object} ctx - context that the handler will run in\n             * @returns {Box} instance\n             */\n            initialize: _.noop,\n            constructor: function (opts) {\n                var model = this;\n                model._makeValid();\n                model.on(model.events);\n                model.initialize(opts);\n                return model;\n            },\n            _makeValid: function () {\n                var model = this;\n                model[currentEventString] = model[currentEventString] || [];\n                model[internalEventsString] = model[internalEventsString] || {};\n                model[EVENT_REMOVE] = model[EVENT_REMOVE] || [];\n                return model;\n            },\n            on: flattenMatrix(attachEventObject, 0),\n            once: flattenMatrix(onceHandler, 0),\n            listenTo: flattenMatrix(listenToHandler, 1),\n            /**\n             * @description attaches an event handler to the events object, and takes it off as soon as it runs once\n             * @func\n             * @name Box#once\n             * @param {String} string - event name that will be triggered\n             * @param {Function} fn - event handler that will run only once\n             * @param {Object} ctx - context that will be applied to the handler\n             * @returns {Box} instance\n             */\n            listenToOnce: flattenMatrix(listenToOnceHandler, 1),\n            /**\n             * @description remove event objects from the _events object\n             * @param {String|Function} type - event type or handler. If a match is found, then the event object is removed\n             * @param {Function} handler - event handler to be matched and removed\n             * @func\n             * @name Box#off\n             * @returns {Box} instance\n             */\n            offAll: function () {\n                var box = this;\n                each(box[internalEventsString], function (array, key, obj) {\n                    duffRev(array, removeEvent);\n                });\n                return box;\n            },\n            off: function (name_, fn_, ctx_) {\n                var currentEventList, currentObj, box = this,\n                    // ctx = fn_,\n                    name = name_;\n                box._makeValid();\n                if (arguments[LENGTH]) {\n                    if (!name) {\n                        each(box[internalEventsString], function (list, name) {\n                            removeEventObject(box, list, fn_, ctx_);\n                        });\n                    } else {\n                        iterateOverObject(box, isObject(name_) ? fn_ : ctx_, name, fn_, function (box, name, obj) {\n                            removeEventObject(box, !name || box[internalEventsString][name], obj.handler, obj.ctx);\n                        }, BOOLEAN_TRUE);\n                    }\n                } else {\n                    currentEventList = getCurrentEventList(box);\n                    currentObj = currentEventList[currentEventList[LENGTH] - 1];\n                    if (currentObj) {\n                        removeEventObject(box, [currentObj]);\n                    }\n                }\n            },\n            stopListening: function (obj, name, callback) {\n                var ids, listening, stillListening = 0,\n                    origin = this,\n                    listeningTo = origin[internalListeningToString];\n                if (listeningTo && (!obj || obj._listenId)) {\n                    duff(obj ? [obj._listenId] : _.keys(listeningTo), function (id) {\n                        var listening = listeningTo[id];\n                        if (listening) {\n                            listening.obj.off(name, callback);\n                        }\n                        stillListening += listeningTo[id] ? 1 : 0;\n                    });\n                    if (!stillListening && !find(ids, function (id, key) {\n                        return listeningTo[id];\n                    })) {\n                        origin[internalListeningToString] = blank;\n                    }\n                }\n                return origin;\n            },\n            /**\n             * @description triggers a event loop\n             * @func\n             * @name Box#fire\n             * @param {String} name of the event loop to be triggered\n             * @returns {Box} object instance the method is being called on\n             */\n            dispatchEvents: function (names, data, eventOptions) {\n                var box = this;\n                duff(gapSplit(names), function (str) {\n                    box.dispatchEvent(str, data, eventOptions);\n                });\n                return box;\n            },\n            _eventDispatcher: function (evnt) {\n                var box = this,\n                    valid = box._makeValid(),\n                    name = evnt.name,\n                    currentEventArray = getCurrentEventList(box),\n                    list = getEventList(box, name),\n                    ret = isFunction(box[evnt.methodName]) && box[evnt.methodName](evnt);\n                    anotherRet = evnt[iPISString] || !!_.find(list, function (obj) {\n                        var gah;\n                        currentEventArray.push(obj);\n                        obj.fn(evnt);\n                        gah = currentEventArray.pop(name);\n                        return evnt[iPISString];\n                    });\n                if (!currentEventArray[LENGTH] && box[EVENT_REMOVE][LENGTH] && box[EVENT_REMOVE][LENGTH]) {\n                    duffRev(box[EVENT_REMOVE], removeEvent);\n                    box[EVENT_REMOVE] = [];\n                }\n                return box;\n            },\n            _createEvent: function (name, data) {\n                return new ObjectEvent(name, this, data);\n            },\n            dispatchEvent: function (name, data, evnt_) {\n                var methodName = upCase(camelCase('on:' + name, ':')),\n                    onMethod = isFunction(box[methodName]),\n                    evnt = evnt_ || box._createEvent(name, data);\n                box._eventDispatcher(evnt);\n                evnt.finished();\n                return evnt;\n            }\n        }, !0);\n});","application.scope(function (app) {\n    var _ = app._,\n        // factories = app.factories,\n        // Events = factories.Events,\n        // extendFrom = app.extendFrom,\n        basicData = function (basic) {\n            return function () {\n                return basic;\n            };\n        },\n        messengerHash = {},\n        attachToHash = function (key, obj) {\n            if (messengerHash[key]) {\n                messengerHash[key].destroy();\n            }\n            obj.name = key;\n            messengerHash[key] = obj;\n        },\n        removeFromHash = function (obj) {\n            messengerHash[obj.name] = void 0;\n        },\n        Events = _.factories.Events,\n        Messenger = _.extendFrom.Events('Messenger', {\n            constructor: function (parent) {\n                var hash = {};\n                this._getHash = function (key, args) {\n                    return _.resultOf(hash[key], args);\n                };\n                this._setHash = function (key, val) {\n                    hash[key] = val;\n                };\n                if (_.isObject(parent)) {\n                    this.attachParent(parent);\n                } else {\n                    // is string\n                    attachToHash(key, this);\n                }\n                return Events.call(this);\n            },\n            onDestroy: function () {\n                var obj = this;\n                if (obj.name) {\n                    removeFromHash(obj);\n                }\n            },\n            attachParent: function (parent) {\n                this.parent = parent;\n                parent.message = this;\n                return this;\n            },\n            request: function (key, args) {\n                return this._getHash(key, args);\n            },\n            reply: function (key, handler) {\n                if (!_.isFunction(handler)) {\n                    handler = basicData(handler);\n                }\n                this._setHash(key, handler);\n                return this.parent;\n            },\n            replies: function (obj) {\n                var messenger = this;\n                _.each(obj, function (val, key) {\n                    messenger._setHash(key, val);\n                });\n                return messenger.parent;\n            }\n        }, true);\n    _.exports({\n        reqres: function (obj) {\n            return new Messenger(obj);\n        }\n    });\n    _.reqres(app);\n});","application.scope(function (app) {\n    var blank, _ = app._,\n        extendFrom = _.extendFrom,\n        factories = _.factories,\n        Collection = _.Collection,\n        Events = factories.Events,\n        gapSplit = _.gapSplit,\n        isObject = _.isObject,\n        isStr = _.isString,\n        isNum = _.isNumber,\n        isFn = _.isFunction,\n        each = _.each,\n        duff = _.duff,\n        find = _.find,\n        isBlank = _.isBlank,\n        isFunction = _.isFunction,\n        duffRev = _.duffRev,\n        push = _.push,\n        has = _.has,\n        map = _.map,\n        toArray = _.toArray,\n        clone = _.clone,\n        once = _.once,\n        parse = _.parse,\n        extend = _.extend,\n        listDrop = _.remove,\n        property = _.property,\n        stringify = _.stringify,\n        isInstance = _.isInstance,\n        isArrayLike = _.isArrayLike,\n        upCase = _.upCase,\n        camelCase = _.camelCase,\n        isArray = _.isArray,\n        objCondense = _.objCondense,\n        intendedObject = _.intendedObject,\n        LENGTH = 'length',\n        PARENT = 'parent',\n        INTERNAL_EVENTS = '_events',\n        ATTRIBUTES = 'attributes',\n        DISPATCH_EVENT = 'dispatchEvent',\n        EVENT_REMOVE = '_removeEventList',\n        BOOLEAN_FALSE = !1,\n        BOOLEAN_TRUE = !0,\n        CHILDREN = 'children',\n        CHANGE_COUNTER = '_changeCounter',\n        toStringString = 'toString',\n        prototypeString = 'prototype',\n        CHANGED_STRING = 'change',\n        constructorString = 'constructor',\n        PREVIOUS_ATTRIBUTES = '_previousAttributes',\n        /**\n         * @class Box\n         * @description event and attribute extensor object that creates the Box Constructor and convenience method at _.Box\n         * @augments Model\n         */\n        Container = _.extendFrom.Events('Container', {\n            constructor: function (attributes, secondary) {\n                var model = this;\n                model.cid = model.cid = _.uniqueId(model.cidPrefix);\n                model.reset(attributes);\n                _.extend(model, secondary);\n                Events.apply(this, arguments);\n                return model;\n            },\n            _reset: function (attributes_) {\n                var childModel, children, model = this,\n                    _altered = model._altered = {},\n                    idAttr = _.result(model, 'idAttribute', arguments),\n                    // automatically checks to see if the attributes are a string\n                    attributes = parse(attributes_) || {},\n                    // default attributes\n                    attrs = _.result(model, 'defaults', arguments),\n                    // build new attributes\n                    newAttributes = extend(attrs, attributes),\n                    // stale attributes\n                    ret = model[ATTRIBUTES] || {};\n                // set id and let parent know what your new id is\n                this[DISPATCH_EVENT]('before:reset');\n                model._setId(attributes[idAttr]);\n                model[PREVIOUS_ATTRIBUTES] = {};\n                // swaps attributes hash\n                model[ATTRIBUTES] = newAttributes;\n                // let everything know that it is changing\n                model[DISPATCH_EVENT]('reset');\n                return ret;\n            },\n            /**\n             * @description remove attributes from the Box object. Does not completely remove from object with delete, but instead simply sets it to void 0 / undefined\n             * @param {String} attr - property string that is on the attributes object\n             * @returns {Box} instance the method was called on\n             * @func\n             * @name Box#unset\n             */\n            unset: function (attrs) {\n                var attrObj = this[ATTRIBUTES];\n                duff(gapSplit(attrs), function (attr) {\n                    attrObj[attr] = blank;\n                });\n                return this;\n            },\n            /**\n             * @description returns attribute passed into\n             * @param {String} attr - property string that is being gotten from the attributes object\n             * @returns {*} value that is present on the attributes object\n             * @func\n             * @name Box#get\n             */\n            get: function (attr) {\n                return this[ATTRIBUTES][attr];\n            },\n            /**\n             * @func\n             * @param {String} attr - property string that is being gotten from the attributes object\n             * @returns {Boolean} evaluation of whether or not the Box instance has a value at that attribute key\n             * @description checks to see if the current attribute is on the attributes object as anything other an undefined\n             * @name Box#has\n             */\n            has: function (attrs) {\n                var box = this,\n                    attributes = box[ATTRIBUTES];\n                return !find(gapSplit(attrs), function (attr) {\n                    return attributes[attr] === blank;\n                });\n            },\n            /**\n             * @description collects a splat of arguments and condenses them into a single object. Object is then extended onto the attributes object and any items that are different will be fired as events\n             * @param {...*} series - takes a series of key value pairs. can be mixed with objects. All key value pairs will be placed on a new object, which is to be passed into the function below\n             * @func\n             * @name Box#set\n             * @returns {Box} instance\n             */\n            _set: function (key, newValue) {\n                var model = this,\n                    didChange = BOOLEAN_FALSE,\n                    attrs = model[ATTRIBUTES],\n                    oldValue = attrs[key],\n                    previousAttrsObject = model[PREVIOUS_ATTRIBUTES] = model[PREVIOUS_ATTRIBUTES] || {};\n                if (!_.isEqual(oldValue, newValue)) {\n                    didChange = BOOLEAN_TRUE;\n                    previousAttrsObject[key] = oldValue;\n                    attrs[key] = newValue;\n                }\n                return didChange;\n            },\n            set: function (key, value) {\n                var changedList = [],\n                    model = this,\n                    compiled = {},\n                    _changeCounter = model[CHANGE_COUNTER] = model[CHANGE_COUNTER] || 0;\n                intendedObject(key, value, function (key, value) {\n                    if (model._set(key, value)) {\n                        changedList.push(key);\n                    }\n                });\n                if (changedList[LENGTH]) {\n                    model[CHANGE_COUNTER]++;\n                    duff(changedList, function (name) {\n                        model[DISPATCH_EVENT](CHANGED_STRING + ':' + name, {\n                            key: name,\n                            // uses get to prevent stale data\n                            value: model.get(name)\n                        });\n                    });\n                    model[DISPATCH_EVENT](CHANGED_STRING, model[PREVIOUS_ATTRIBUTES]);\n                    model[CHANGE_COUNTER]--;\n                }\n                // this event should only ever exist here\n                if (!model[CHANGE_COUNTER]) {\n                    model[DISPATCH_EVENT]('digest', model[PREVIOUS_ATTRIBUTES]);\n                    model[PREVIOUS_ATTRIBUTES] = {};\n                }\n                return model;\n            },\n            /**\n             * @description basic json clone of the attributes object\n             * @func\n             * @name Box#toJSON\n             * @returns {Object} json clone of the attributes object\n             */\n            toJSON: function () {\n                // does not prevent circular dependencies.\n                // swap this out for something else if you want\n                // to prevent circular dependencies\n                return clone(this[ATTRIBUTES]);\n            },\n            /**\n             * @description stringified version of attributes object\n             * @func\n             * @name Box#stringify\n             * @returns {String} stringified json version of\n             */\n            toString: function () {\n                return stringify(this);\n            },\n            _setId: function (id_) {\n                var model = this,\n                    id = id_ === void 0 ? _.uniqueId(!1) : id_ + '';\n                model.id = id;\n            },\n            reset: function (attrs) {\n                this._reset(attrs);\n                return this;\n            }\n        }, true),\n        Box = _.extendFrom.Container('Box', {\n            /**\n             * @description constructor function for the Box Object\n             * @name Box#constructor\n             * @func\n             */\n            cidPrefix: 'c',\n            idAttribute: 'id',\n            constructor: function (attributes, secondary) {\n                var model = this;\n                model[CHILDREN] = Collection();\n                Container.apply(model, arguments);\n                return model;\n            },\n            _gatherChildren: function () {\n                return [];\n            },\n            /**\n             * @description resets the box's attributes to the object that is passed in\n             * @name Box#reset\n             * @func\n             * @param {Object} attributes - non circular hash that is extended onto what the defaults object produces\n             * @returns {Box} instance the method was called on\n             */\n            _registerChild: function (id, model) {\n                var parent = this;\n                if (id !== void 0) {\n                    parent.children.register(id, model);\n                }\n            },\n            _unRegisterChild: function (id) {\n                var parent = this;\n                if (id !== void 0) {\n                    parent.children.unRegister(id);\n                }\n            },\n            resetChildren: function (newChildren) {\n                var child, box = this,\n                    children = box[CHILDREN],\n                    arr = children.un();\n                while (arr.length) {\n                    child = arr[0];\n                    if (child && child.destroy) {\n                        child.destroy();\n                    }\n                    // if it didn't remove itself,\n                    // then you should remove it here\n                    // this doesn't work if the child is a basic data type\n                    if (arr[0] === child) {\n                        _.remove(arr, child);\n                    }\n                }\n                box.add(newChildren);\n                return box;\n            },\n            /**\n             * @description calls toJSON on all children and creates an array of clones\n             * @func\n             * @name Box#childrenToJSON\n             * @returns {Object} array of toJSON'ed children\n             */\n            childrenToJSON: function () {\n                return this[CHILDREN].toJSON();\n            },\n            /**\n             * @description conbination of toJSON and kids to JSON, applied recurisvely. \"kids\" are applied as the children property\n             * @func\n             * @name Box#treeToJSON\n             * @returns {Object} JSON clone of attributes and children\n             */\n            treeToJSON: function () {\n                var model = this,\n                    attrClone = model.toJSON(),\n                    children = model[CHILDREN];\n                if (children.length()) {\n                    attrClone[CHILDREN] = children.toJSON();\n                }\n                return attrClone;\n            },\n            /**\n             * @description stringified version of children array\n             * @func\n             * @name Box#stringifyChildren\n             * @returns {String} string version of children\n             */\n            stringifyChildren: function () {\n                return stringify(this.childrenToJSON());\n            },\n            /**\n             * @description stringifies parent, child, attributes tree\n             * @func\n             * @name Box#stringifyTree\n             * @returns {String} string version of tree\n             */\n            stringifyTree: function () {\n                return stringify(this.treeToJSON());\n            },\n            // registers and actually adds child to hash\n            _addToHash: function (newModel) {\n                var parent = this,\n                    children = this.children;\n                // add to collection\n                children.add(newModel);\n                // register with parent\n                parent._registerChild(newModel.id, newModel);\n                parent._registerChild(newModel.cid, newModel);\n            },\n            // ties child events to new child\n            _delegateChildEvents: function (model) {\n                var parent = this,\n                    childEvents = _.result(parent, 'childEvents');\n                if (model && childEvents) {\n                    model._parentDelgatedChildEvents = childEvents;\n                    parent.listenTo(model, childEvents);\n                }\n            },\n            // ties child events to new child\n            _unDelegateChildEvents: function (model) {\n                if (model && model._parentDelgatedChildEvents && this.stopListening) {\n                    this.stopListening(model, model._parentDelgatedChildEvents);\n                }\n            },\n            _delegateParentEvents: function (model) {\n                var parent = model.parent,\n                    parentEvents = _.result(model, 'parentEvents');\n                if (parent && parentEvents) {\n                    model._delegatedParentEvents = parentEvents;\n                    model.listenTo(parent, parentEvents);\n                }\n            },\n            // ties child events to new child\n            _unDelegateParentEvents: function (model) {\n                var parent = this;\n                if (model.stopListening && model._delegatedParentEvents) {\n                    model.stopListening(parent, model._delegatedParentEvents);\n                }\n            },\n            _isChildType: function (child) {\n                return isInstance(child, this.Model);\n            },\n            // this one forcefully adds\n            _add: function (model) {\n                var parent = this,\n                    children = parent[CHILDREN],\n                    evt = model[DISPATCH_EVENT] && model[DISPATCH_EVENT]('before:added');\n                // let the child know it's about to be added\n                // (tied to it's parent via events)\n                // unties boxes\n                parent._remove(model);\n                // explicitly tie to parent\n                model.parent = parent;\n                // attach events from parent\n                parent._addToHash(model);\n                // ties boxes together\n                parent._delegateParentEvents(model);\n                parent._delegateChildEvents(model);\n                evt = model[DISPATCH_EVENT] && model[DISPATCH_EVENT]('added');\n                // notify that you were added\n                return model;\n            },\n            // public facing version filters\n            add: function (objs, secondary_) {\n                var childWasAdded, newModel, returnNewModel, parent = this,\n                    children = parent[CHILDREN],\n                    list = [],\n                    secondary = extend(_.result(parent, 'childOptions'), secondary_ || {});\n                // unwrap it if you were passed a collection\n                if (isInstance(objs, _.Collection)) {\n                    objs = objs.un();\n                }\n                if (!isArrayLike(objs)) {\n                    objs = [objs];\n                }\n                if (parent.Model && objs[0]) {\n                    list = map(objs, function (obj) {\n                        var foundModel, isChildType = parent._isChildType(obj);\n                        // create a new model\n                        newModel = isChildType ? obj : new parent.Model(obj, secondary);\n                        // find by the newly created's id\n                        foundModel = children.get(newModel.id);\n                        // out with the old\n                        if (foundModel) {\n                            // update the old model with new info\n                            foundModel.set(newModel.toJSON());\n                            newModel = foundModel;\n                        } else {\n                            childWasAdded = true;\n                            parent._add(newModel);\n                            // list to return\n                        }\n                        return newModel;\n                    });\n                    if (childWasAdded) {\n                        parent[DISPATCH_EVENT]('child:added');\n                    }\n                }\n                return list;\n            },\n            _removeFromHash: function (child) {\n                var parent = this,\n                    children = parent.children;\n                if (children && child) {\n                    // remove the child from the children hash\n                    children.remove(child);\n                    parent._unRegisterChild(child.id);\n                    // unregister from the child hash keys\n                    parent._unRegisterChild(child.cid);\n                }\n            },\n            // only place that we mention parents\n            _collectParents: function () {\n                var eventr = this,\n                    parents = [],\n                    parent = eventr[PARENT];\n                while (parent) {\n                    if (isInstance(parent, Events)) {\n                        parents.push(parent);\n                    }\n                    parent = parent[PARENT];\n                }\n                return parents;\n            },\n            // has to completely replace previous event dispatcher\n            dispatchEvent: function (name_, data, evnt_) {\n                var origin = this,\n                    name = (evnt_ && evnt_.methodName) || name_,\n                    methodName = (evnt_ && evnt_.methodName) || upCase(camelCase('on:' + name, ':')),\n                    childMethodName = upCase(camelCase('on:child:' + name, ':')),\n                    // onMethod = isFunction(origin[methodName]),\n                    evnt = evnt_ || origin._createEvent(name, data),\n                    parents = origin._collectParents(),\n                    i = parents[LENGTH] - 1;\n                while (parents[LENGTH] && parents[i] && !evnt.isStopped()) {\n                    parent = parents[i];\n                    if (parent._isDestroyed) {\n                        evnt.stopImmediatePropagation();\n                        i = 0;\n                    } else {\n                        parent._eventDispatcher(evnt);\n                    }\n                    i--;\n                }\n                // if (!evnt.isStopped()) {\n                //     origin._eventDispatcher(evnt);\n                // }\n                while (origin && origin._eventDispatcher && !evnt.isStopped()) {\n                    origin._eventDispatcher(evnt);\n                    origin = !evnt.isStopped() && evnt.bubbles && origin[PARENT];\n                }\n                evnt.finished();\n                return evnt;\n                // var evnt =\n                // var evnt, box = makeValidEvent(this),\n                //     originalBox = box,\n                //     currentEventArray = getCurrentEventList(originalBox),\n                //     methodName = upCase(camelCase('on:' + name, ':')),\n                //     childMethodName = upCase(camelCase('on:child:' + name, ':')),\n                //     onMethod = isFunction(box[methodName]);\n                // if (onMethod || getEventList(box, name).length || overrideEventCreation(options)) {\n                //     evnt = box._createEvent(name, data);\n                //     evnt.originalStack = BOOLEAN_TRUE;\n                //     evnt.onMethodName = methodName;\n                //     while (box && box[internalEventsString] && box._eventDispatcher && !evnt.isStopped()) {\n                //         box._eventDispatcher(evnt);\n                //         box = !evnt.isStopped() && evnt.bubbles && box[PARENT];\n                //     }\n                //     evnt.originalStack = BOOLEAN_FALSE;\n                // }\n            },\n            _remove: function (model) {\n                var parent = this;\n                model[DISPATCH_EVENT]('before:removed');\n                // notify the child that the remove pipeline is starting\n                // remove the parent listeners\n                parent._unDelegateParentEvents(model);\n                parent._unDelegateChildEvents(model);\n                // attach events from parent\n                parent._removeFromHash(model);\n                // void out the parent member tied directly to the model\n                model.parent = void 0;\n                model[DISPATCH_EVENT]('removed');\n                // notify the child that the remove pipeline is done\n                return model;\n            },\n            remove: function (idModel_) {\n                var removedSomething, parent = this,\n                    children = parent[CHILDREN],\n                    retList = _.Collection(),\n                    args = _.toArray(arguments).splice(1),\n                    idModel = idModel_;\n                if (!isObject(idModel)) {\n                    // it's a string\n                    idModel = parent.children.get(idModel + '');\n                }\n                if (idModel && isObject(idModel)) {\n                    if (isInstance(idModel, _.Collection)) {\n                        idModel = idModel.un();\n                    }\n                    if (!_.isArray(idModel)) {\n                        idModel = [idModel];\n                    }\n                    duff(idModel, function (model) {\n                        removedSomething = true;\n                        parent._remove(model);\n                        retList.add(model);\n                    });\n                    if (removedSomething) {\n                        parent[DISPATCH_EVENT]('child:removed');\n                    }\n                }\n                return retList;\n            },\n            /**\n             * @description removes pointers from parent\n             * @func\n             * @name Box#destroy\n             * @returns {Box} instance\n             */\n            destroy: function () {\n                var removeRet, box = this;\n                // notify things like parent that it's about to destroy itself\n                box[DISPATCH_EVENT]('before:destroy');\n                // destroys it's children\n                box.resetChildren();\n                // removes all parent / parent's child listeners\n                removeRet = box.parent && box.parent.remove(box);\n                // stop listening to other views\n                box[DISPATCH_EVENT]('destroy');\n                // stops listening to everything\n                box.stopListening();\n                // takes off all other event handlers\n                box.offAll();\n                return box;\n            },\n            /**\n             * @description basic sort function\n             * @param {Function|String} comparator - argument to sort children against\n             * @returns {Box} instance\n             * @func\n             * @name Box#sort\n             */\n            sort: function (comparator) {\n                var compString, isReversed, model = this,\n                    children = model[CHILDREN];\n                if (!comparator) {\n                    comparator = model.comparator;\n                }\n                if (_.isString(comparator)) {\n                    isReversed = comparator[0] === '!';\n                    compString = comparator;\n                    if (isReversed) {\n                        compString = comparator.slice(1, comparator[LENGTH]);\n                    }\n                    comparator = function (a, b) {\n                        var val, valA = a.get(compString),\n                            valB = b.get(compString);\n                        if (isReversed) {\n                            val = valB - valA;\n                        } else {\n                            val = valA - valB;\n                        }\n                        return val;\n                    };\n                }\n                model[DISPATCH_EVENT]('before:sort', model);\n                children.sort(comparator);\n                model[DISPATCH_EVENT]('sort', model);\n                return model;\n            }\n        }, !0);\n});","application.scope(function (app) {\n    var blank, _ = app._,\n        // submodules = app.submodules = {},\n        factories = _.factories,\n        Box = _.factories.Box,\n        startableMethods = {\n            start: function () {\n                var startable = this;\n                if (!startable.started) {\n                    startable.dispatchEvent('before:start', arguments);\n                    startable.started = true;\n                    startable.dispatchEvent('start', arguments);\n                }\n            },\n            stop: function () {\n                var startable = this;\n                if (startable.started) {\n                    startable.dispatchEvent('before:stop', arguments);\n                    startable.started = false;\n                    startable.dispatchEvent('stop', arguments);\n                }\n            },\n            toggle: function () {\n                var module = this;\n                if (module.started) {\n                    module.stop.apply(module, arguments);\n                } else {\n                    module.start.apply(module, arguments);\n                }\n                return module;\n            }\n        },\n        Startable = _.extendFrom.Box('Startable', startableMethods, !0),\n        doStart = function (e) {\n            if (this.get('startWithParent')) {\n                this.start(e);\n            }\n        },\n        doStop = function (e) {\n            if (this.get('stopWithParent')) {\n                this.stop(e);\n            }\n        },\n        moduleHandler = function (name_, fn) {\n            var module, attrs, parentIsModule, nametree, parent = this,\n                originalParent = parent,\n                name = name_,\n                namespace = name.split('.');\n            while (namespace.length > 1) {\n                parent = parent.module(namespace[0]);\n                namespace.shift();\n            }\n            name = namespace.join('.');\n            // module = parent.submodules[name];\n            if (!module) {\n                parentIsModule = _.isInstance(parent, Module);\n                if (parentIsModule) {\n                    namespace.unshift(parent.get('globalname'));\n                }\n                namespace = namespace.join('.');\n                attrs = {\n                    name: name,\n                    globalname: namespace\n                };\n                if (parentIsModule) {\n                    module = parent.add(attrs)[0];\n                } else {\n                    module = new Module(attrs, {\n                        application: app,\n                        parent: parent\n                    });\n                    parent.children.add(module);\n                }\n                // parent.registerModule(name, module);\n            }\n            if (!module.hasInitialized && _.isFunction(fn)) {\n                module.hasInitialized = true;\n                module.handler(fn);\n            }\n            return module;\n        },\n        Module = _.extendFrom.Box('Module', _.extend({}, startableMethods, {\n            // registerModule: registerModule,\n            // unRegisterModule: unRegisterModule,\n            idAttribute: 'name',\n            module: moduleHandler,\n            parentEvents: {\n                start: doStart,\n                stop: doStop\n            },\n            exports: function (obj) {\n                _.extend(this.get('exports'), obj);\n                return this;\n            },\n            run: function (fn) {\n                var module = this;\n                fn.apply(module, module.createArguments());\n                return module;\n            },\n            createArguments: function () {\n                return [this].concat(this.application.createArguments());\n            },\n            constructor: function (attrs, opts) {\n                var module = this;\n                // module.submodules = {};\n                module.name = attrs.name;\n                module.application = opts.application;\n                module.handlers = _.Collection();\n                _.reqres(this);\n                Box.apply(this, arguments);\n                return module;\n            },\n            defaults: function () {\n                return {\n                    startWithParent: true,\n                    stopWithParent: true,\n                    exports: {}\n                };\n            },\n            childOptions: function () {\n                return {\n                    application: this.application,\n                    parent: this\n                };\n            },\n            handler: function (fn) {\n                var module = this;\n                module.handlers.push(fn);\n                module.run(fn);\n                return module;\n            }\n        }), !0);\n    app.extend({\n        children: _.Collection(),\n        // registerModule: registerModule,\n        /**\n         * @func\n         * @name Specless#run\n         * @returns {*}\n         */\n        run: Module.prototype.run,\n        /**\n         * @func\n         * @name Specless#baseModuleArguments\n         * @returns {Array} list of base arguments to apply to submodules\n         */\n        baseModuleArguments: function () {\n            var app = this;\n            return [app, app._];\n        },\n        /**\n         * @func\n         * @name Specless#addModuleArgs\n         * @param {Array} arr - list of arguments that will be added to the extraModule args list\n         * @returns {Specless} instance\n         */\n        addModuleArgs: function (arr) {\n            var app = this;\n            app.extraModuleArgs = app.extraModuleArgs || [];\n            app._.addAll(app.extraModuleArgs, arr);\n            return app;\n        },\n        /**\n         * @func\n         * @name Specless#removeModuleArgs\n         * @param {Array} arr - list of objects or functions that will be removed from the extraModuleArgs\n         * @returns {Specless} instance\n         */\n        removeModuleArgs: function (arr) {\n            this.utils.removeAll(this.extraModuleArgs, arr);\n            return this;\n        },\n        /**\n         * @func\n         * @name Specless#createArguments\n         * @returns {Object[]}\n         */\n        createArguments: function () {\n            return this.baseModuleArguments().concat(this.extraModuleArgs);\n        },\n        require: function (modulename) {\n            var module = this.module(modulename);\n            return module.getExports();\n        },\n        module: moduleHandler\n    });\n});","application.scope().module('Looper', function (module, app, _, extendFrom, factories) {\n    var blank, LoopGen, x = 0,\n        lastTime = 0,\n        lengthString = 'length',\n        isFn = _.isFn,\n        isNum = _.isNum,\n        pI = _.pI,\n        posit = _.posit,\n        nowish = _.now,\n        getLength = _.property(lengthString),\n        gapSplit = _.gapSplit,\n        win = window,\n        vendors = gapSplit('ms moz webkit o'),\n        requestAnimationFrameString = 'requestAnimationFrame',\n        allLoopGens = [],\n        runningLoopGens = [],\n        bind = _.bind,\n        duff = _.duff,\n        remove = _.remove,\n        removeAll = _.removeAll,\n        duffRev = _.duffRev,\n        extend = _.extend,\n        // extendFrom = _.extendFrom,\n        running = false,\n        setup = function () {\n            running = true;\n            win[requestAnimationFrameString](function (time) {\n                duff(runningLoopGens, function (idx, loopGen) {\n                    loopGen.run(time);\n                });\n                teardown();\n            });\n        },\n        teardown = function () {\n            duffRev(runningLoopGens, function (idx, loopGen) {\n                if (loopGen.halted() || loopGen.stopped() || loopGen.destroyed() || !loopGen.length()) {\n                    runningLoopGens.splice(idx, 1);\n                }\n            });\n            running = false;\n            if (runningLoopGens[lengthString]) {\n                setup();\n            }\n        },\n        add = function (loopGen) {\n            allLoopGens.push(loopGen);\n        },\n        start = function (loopGen) {\n            if (!posit(runningLoopGens, loopGen)) {\n                runningLoopGens.push(loopGen);\n            }\n            if (!running) {\n                setup();\n            }\n        };\n    for (; x < getLength(vendors) && !win[requestAnimationFrameString]; ++x) {\n        win[requestAnimationFrameString] = win[vendors[x] + 'RequestAnimationFrame'];\n        win.cancelAnimationFrame = win[vendors[x] + 'CancelAnimationFrame'] || win[vendors[x] + 'CancelRequestAnimationFrame'];\n    }\n    if (!win[requestAnimationFrameString]) {\n        win[requestAnimationFrameString] = function (callback) {\n            var currTime = new Date().getTime(),\n                timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n                id = win.setTimeout(function () {\n                    callback(currTime + timeToCall);\n                }, timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n    }\n    if (!win.cancelAnimationFrame) {\n        win.cancelAnimationFrame = function (id) {\n            win.clearTimeout(id);\n        };\n    }\n    LoopGen = _.extendFrom.Model('LoopGen', {\n        constructor: function (_runner) {\n            var fns, stopped = false,\n                halted = false,\n                destroyed = false,\n                running = false,\n                loopGen = this,\n                counter = 0,\n                fnList = [],\n                addList = [],\n                removeList = [],\n                combineAdd = function () {\n                    if (addList[lengthString]) {\n                        fnList = fnList.concat(addList);\n                        addList = [];\n                    }\n                };\n            extend(loopGen, {\n                length: function () {\n                    return getLength(fnList);\n                },\n                destroy: function () {\n                    destroyed = true;\n                    remove(allLoopGens, this);\n                    return this.halt();\n                },\n                destroyed: function () {\n                    return destroyed;\n                },\n                running: function () {\n                    return !!running;\n                },\n                run: function () {\n                    var tween = this,\n                        removeLater = [],\n                        _nowish = nowish();\n                    if (halted || stopped) {\n                        return;\n                    }\n                    combineAdd();\n                    // removeAll(fnList, removeList);\n                    // removeList = [];\n                    duff(fnList, function (idx, fnObj) {\n                        if (!posit(removeList, fnObj)) {\n                            if (!fnObj.disabled && !halted) {\n                                running = fnObj;\n                                fnObj.fn(_nowish);\n                            }\n                        } else {\n                            removeLater.push(fnObj);\n                        }\n                    });\n                    running = false;\n                    combineAdd();\n                    removeAll(fnList, removeList.concat(removeLater));\n                    removeList = [];\n                },\n                remove: function (id) {\n                    var ret, fnObj, i = 0;\n                    if (!arguments[lengthString]) {\n                        if (running) {\n                            id = running.id;\n                        }\n                    }\n                    if (isNumber(id)) {\n                        for (; i < fnList[lengthString] && !ret; i++) {\n                            fnObj = fnList[i];\n                            if (fnObj.id === id) {\n                                if (!posit(removeList, fnObj)) {\n                                    removeList.push(fnObj);\n                                    ret = 1;\n                                }\n                            }\n                        }\n                    }\n                    return !!ret;\n                },\n                stop: function () {\n                    stopped = !0;\n                    return this;\n                },\n                start: function () {\n                    var looper = this;\n                    stopped = !1;\n                    halted = !1;\n                    return looper;\n                },\n                halt: function () {\n                    halted = !0;\n                    return this.stop();\n                },\n                halted: function () {\n                    return halted;\n                },\n                stopped: function () {\n                    return stopped;\n                },\n                reset: function () {\n                    fnList = [];\n                    removeList = [];\n                    addList = [];\n                    return this;\n                },\n                add: function (fn) {\n                    var obj, id = counter,\n                        tween = this;\n                    if (isFunction(fn)) {\n                        if (!fnList[lengthString]) {\n                            tween.start();\n                        }\n                        start(tween);\n                        obj = {\n                            fn: bind(fn, tween),\n                            id: id,\n                            disabled: !1,\n                            bound: tween\n                        };\n                        if (tween.running()) {\n                            addList.push(obj);\n                        } else {\n                            fnList.push(obj);\n                        }\n                        counter++;\n                        return id;\n                    }\n                }\n            });\n            add(loopGen);\n            return loopGen;\n        },\n        once: function (fn) {\n            return this.count(1, fn);\n        },\n        count: function (timey, fn) {\n            var count = 0,\n                times = pI(timey) || 1;\n            if (!fn && isFunction(times)) {\n                fn = timey;\n                times = 1;\n            }\n            if (times < 1 || !isNumber(times)) {\n                times = 1;\n            }\n            if (!isFunction(fn)) {\n                return;\n            }\n            return this.add(function (ms) {\n                var last = 1;\n                count++;\n                if (count >= times) {\n                    this.remove();\n                    last = 0;\n                }\n                fn.apply(this, [ms, !last, count]);\n            });\n        },\n        tween: function (time, fn) {\n            var added = nowish();\n            if (!time) {\n                time = 0;\n            }\n            if (!isFunction(fn)) {\n                return;\n            }\n            return this.interval(0, function (ms) {\n                var tween = 1,\n                    diff = ms - added;\n                if (diff >= time) {\n                    tween = 0;\n                    this.remove();\n                }\n                fn.call(this, ms, Math.min(1, (diff / time)), !tween);\n            });\n        },\n        time: function (time, fn) {\n            if (!isFunction(fn)) {\n                return;\n            }\n            return this.interval(time, function (ms) {\n                fn.call(this, ms);\n                this.remove();\n            });\n        },\n        frameRate: function (time, fn, min) {\n            var tween = this,\n                minimum = Math.min(min || 0.8, 0.8),\n                expectedFrameRate = 30 * minimum,\n                lastDate = 1,\n                lastSkip = _.now();\n            time = time || 125;\n            if (isFunction(fn)) {\n                return tween.add(function (ms) {\n                    var frameRate = 1000 / (ms - lastDate);\n                    if (frameRate > 40) {\n                        expectedFrameRate = 60 * minimum;\n                    }\n                    if (frameRate < expectedFrameRate) {\n                        lastSkip = ms;\n                    }\n                    if (ms - lastSkip > time) {\n                        this.remove();\n                        fn.call(this, ms);\n                    }\n                    lastDate = ms;\n                });\n            }\n        },\n        interval: function (time, fn) {\n            var last = nowish();\n            if (!time) {\n                time = 0;\n            }\n            if (!isFunction(fn)) {\n                return;\n            }\n            return this.add(function (ms) {\n                if (ms - time >= last) {\n                    fn.call(this, ms);\n                    last = ms;\n                }\n            });\n        }\n    }, !0);\n    _.exports({\n        AF: new LoopGen()\n    });\n});","application.scope().module('Promise', function (module, app, _) {\n    var blank, flatten = _.flatten,\n        extendFrom = _.extendFrom,\n        factories = _.factories,\n        lengthString = 'length',\n        duff = _.duff,\n        each = _.each,\n        extend = _.extend,\n        toArray = _.toArray,\n        isFunction = _.isFunction,\n        foldr = _.foldr,\n        result = _.result,\n        collapse = function (args) {\n            return foldr(args, function (memo, item) {\n                if (item) {\n                    memo.push(item);\n                }\n                return memo;\n            }, []);\n        },\n        when = function () {\n            var promise = _.Promise();\n            promise.add(_.foldl(flatten(arguments), function (memo, pro) {\n                if (promise._isChildType(pro)) {\n                    memo.push(pro);\n                }\n                return memo;\n            }, []));\n            return promise;\n        },\n        preventDoOver = {\n            success: true,\n            failure: true\n        },\n        dispatch = function (promise, name, opts) {\n            promise.dispatchEvent(name, opts);\n            if (!preventDoOver[name]) {\n                promise.dispatchEvent(promise.isFulfilled() ? 'success' : 'failure', opts);\n            }\n            promise.dispatchEvent('always', opts);\n        },\n        executeIfNeeded = function (promise, name) {\n            return function () {\n                var stashed = promise.get('stashed'),\n                    resolved = promise.resolved(),\n                    apply = stashed && resolved,\n                    // takes N functions from arrays or nested arrays\n                    passedFns = each(flatten(arguments), function (fn) {\n                        if (isFunction(fn)) {\n                            if (apply) {\n                                fn.apply(promise, stashed);\n                            } else {\n                                promise.once(name, fn);\n                            }\n                        }\n                    });\n                return promise;\n            };\n        },\n        associativeStates = {\n            success: true,\n            failure: true,\n            error: true,\n            always: true\n        },\n        addState = function (doit, key) {\n            var promise = this;\n            if (!promise[key] && doit !== false) {\n                promise[key] = executeIfNeeded(promise, key);\n            }\n            return promise;\n        },\n        Promise = extendFrom.Box('Promise', {\n            addState: addState,\n            childEvents: {\n                always: 'check'\n            },\n            events: {\n                'child:added': 'check'\n            },\n            constructor: function () {\n                var promise = this;\n                factories.Box.call(promise);\n                promise.restart();\n                // cannot have been resolved in any way yet\n                _.each(_.extend({}, associativeStates, result(promise, 'associativeStates')), addState, promise);\n                // add passed in success handlers\n                promise.success(arguments);\n                return promise;\n            },\n            check: function () {\n                var notSuccessful, resolveAs, parent = this,\n                    children = parent.children;\n                if (!children.find(function (idx, child) {\n                    notSuccessful = notSuccessful || child.state() !== 'success';\n                    return !child.resolved();\n                })) {\n                    if (notSuccessful) {\n                        resolveAs = 'failure';\n                    } else {\n                        resolveAs = 'success';\n                    }\n                    parent.resolveAs(resolveAs);\n                }\n            },\n            _isChildType: function (promise) {\n                return promise.success && promise.failure && promise.resolve;\n            },\n            state: function () {\n                return this.get('state');\n            },\n            // returns an object -- always\n            auxilarySuccess: function () {\n                return {};\n            },\n            successfulResolves: function () {\n                var resultResult = result(this, 'auxilarySuccess') || {};\n                resultResult.success = true;\n                return resultResult;\n            },\n            resolved: function () {\n                // allows resolved to be defined in a different way\n                return this.get('resolved');\n            },\n            isFulfilled: function () {\n                return !!_.resultOf(result(this, 'successfulResolves')[this.get('state')], this);\n            },\n            isRejected: function () {\n                return !this.isFulfilled();\n            },\n            isPending: function () {\n                return this.get('state') === 'pending';\n            },\n            defaults: function () {\n                return {\n                    state: 'pending',\n                    resolved: false,\n                    stashed: {}\n                };\n            },\n            restart: function () {\n                var promise = this;\n                if (promise.resolved()) {\n                    promise.set(promise.defaults());\n                }\n                return promise;\n            },\n            resolveAs: function (resolveAs_, opts_) {\n                var opts = opts_,\n                    resolveAs = resolveAs_,\n                    promise = this,\n                    stashed = promise.get('stashed');\n                if (!promise.resolved()) {\n                    if (!_.isString(resolveAs)) {\n                        opts = resolveAs;\n                        resolveAs = false;\n                    }\n                    promise.set({\n                        resolved: true,\n                        state: resolveAs || 'success',\n                        stashed: opts || stashed\n                    });\n                    opts = promise.get('stashed');\n                    resolveAs = promise.get('state');\n                    try {\n                        dispatch(promise, resolveAs, opts);\n                    } catch (e) {\n                        dispatch(promise, 'error', {\n                            // nest the sucker again in case it's an array or something else\n                            options: opts,\n                            message: 'javascript execution error'\n                        });\n                    }\n                }\n                return promise;\n            },\n            // convenience functions\n            resolve: function (opts) {\n                return this.resolveAs('success', opts);\n            },\n            reject: function (opts) {\n                return this.resolveAs('failure', opts);\n            }\n        }, 1);\n    _.exports({\n        when: when\n    });\n});","application.scope().module('Ajax', function (module, app, _, factories) {\n    var gapSplit = _.gapSplit,\n        duff = _.duff,\n        extendFrom = _.extendFrom,\n        validTypes = gapSplit('GET POST PUT DELETE'),\n        baseEvents = gapSplit('progress timeout error abort'),\n        cache = {},\n        /**\n         * @description helper function to attach a bunch of event listeners to the request object as well as help them trigger the appropriate events on the Ajax object itself\n         * @private\n         * @arg {Ajax} instance to listen to\n         * @arg {Xhr} instance to place event handlers to trigger events on the Ajax instance\n         * @arg {string} event name\n         */\n        attachBaseListeners = function (ajax) {\n            var prog = 0, req = ajax.requestObject;\n            duff(baseEvents, function (evnt) {\n                if (evnt === 'progress') {\n                    req['on' + evnt] = function (e) {\n                        prog++;\n                        ajax.dispatchEvent(evnt, {\n                            percent: (e.loaded / e.total) || (prog / (prog + 1)),\n                            counter: prog\n                        });\n                    };\n                } else {\n                    req['on' + evnt] = function (e) {\n                        ajax.rejectAs(evnt);\n                    };\n                }\n            });\n        },\n        sendthething = function (xhrReq, args) {\n            return function () {\n                try {\n                    xhrReq.send.apply(xhrReq, args);\n                } catch (e) {\n                    // reports on send error\n                    factories.reportError('xhr', e + '');\n                }\n            };\n        },\n        sendRequest = function (ajax, xhrReq, type, url) {\n            var args = [],\n                data = ajax.get('data');\n            if (url) {\n                xhrReq.open(type, url, ajax.get('async'));\n                if (data) {\n                    args.push(_.stringify(data));\n                }\n                ajax.setHeaders(ajax.get('headers'));\n                attachBaseListeners(ajax);\n                // have to wrap in set timeout for ie\n                setTimeout(sendthething(xhrReq, args));\n            }\n        },\n        decide = {\n            /**\n             * @description get pathway for actually sending out a get request\n             * @private\n             */\n            GET: function (ajax, xhrReq, type) {\n                var url = ajax.getUrl();\n                ajax.attachResponseHandler();\n                sendRequest(ajax, xhrReq, type, url);\n            },\n            /**\n             * @description pathway for actually sending out a put request\n             * @private\n             */\n            PUT: function () {},\n            /**\n             * @description pathway for actually sending out a post request\n             * @private\n             */\n            POST: function (ajax, xhrReq, type) {\n                var url = ajax.getUrl();\n                ajax.attachResponseHandler();\n                sendRequest(ajax, xhrReq, type, url);\n            },\n            /**\n             * @description pathway for actually sending out a delete request\n             * @private\n             */\n            DELETE: function () {}\n        };\n    /**\n     * @class Ajax\n     * @alias _.Ajax\n     * @augments Box\n     * @augments Model\n     * @classdesc XHR object wrapper Triggers events based on xhr state changes and abstracts many anomalies that have to do with IE\n     */\n    _.factories.Ajax = _.extendFrom.Promise('Ajax', {\n        events: {\n            'alter:url': function () {\n                var ajax = this,\n                    xhrReq = ajax.requestObject,\n                    type = ajax.get('type'),\n                    thingToDo = decide[type] || decide.GET;\n                if (thingToDo) {\n                    thingToDo(ajax, xhrReq, type);\n                }\n            }\n        },\n        associativeStates: {\n            timeout: true,\n            abort: true\n        },\n        defaults: function () {\n            return {\n                async: true,\n                type: 'GET'\n            };\n        },\n        /**\n         * @func\n         * @name Ajax#constructor\n         * @param {string} str - url to get from\n         * @returns {Ajax} new ajax object\n         */\n        constructor: function (str, secondary) {\n            var promise, url, thingToDo, typeThing, type, xhrReq, ajax = this,\n                method = 'onreadystatechange';\n            // Add a cache buster to the url\n            // ajax.async = true;\n            xhrReq = new XMLHttpRequest();\n            // covers ie9\n            if (typeof XDomainRequest !== 'undefined') {\n                xhrReq = new XDomainRequest();\n                method = 'onload';\n            }\n            if (!_.isObject(str)) {\n                str = str || '';\n                type = 'GET';\n                typeThing = str.toUpperCase();\n                if (_.listHas(validTypes, typeThing)) {\n                    type = typeThing;\n                } else {\n                    url = str;\n                }\n                str = {\n                    url: url || '',\n                    type: type\n                };\n            }\n            str.type = (str.type || 'GET').toUpperCase();\n            str.method = method;\n            factories.Promise.apply(ajax);\n            _.extend(ajax, secondary);\n            /** @member {XMLHttpRequest} */\n            ajax.requestObject = xhrReq;\n            return ajax.on('error abort timeout', function (e) {\n                factories.reportError('xhr error', e.type);\n            }).set(str).always(function (evnt) {\n                ajax.dispatchEvent('status:' + evnt.status, evnt);\n            });\n        },\n        status: function (code, handler) {\n            return this.once(_.simpleObject('status:' + code, handler));\n        },\n        setHeaders: function (headers) {\n            var ajax = this,\n                xhrReq = ajax.requestObject;\n            _.each(headers, function (val, key) {\n                xhrReq.setRequestHeader(_.unCamelCase(key), val);\n            });\n            return ajax;\n        },\n        /**\n         * @description specialized function to stringify url if it is an object\n         * @returns {string} returns the completed string that will be fetched / posted / put / or deleted against\n         * @name Ajax#getUrl\n         */\n        getUrl: function () {\n            var url = this.get('url');\n            if (_.isObject(url) && !_.isArray(url)) {\n                url = _.stringifyQuery(url);\n            }\n            return url;\n        },\n        /**\n         * @description makes public the ability to attach a response handler if one has not already been attached. We recommend not passing a function in and instead just listening to the various events that the xhr object will trigger directly, or indirectly on the ajax object\n         * @param {function} [fn=handler] - pass in a function to have a custom onload, onreadystatechange handler\n         * @returns {ajax}\n         * @name Ajax#attachResponseHandler\n         */\n        attachResponseHandler: function (fn) {\n            var ajax = this,\n                xhrReqObj = ajax.requestObject,\n                hasSucceeded = 0,\n                method = ajax.get('method'),\n                handler = function (evnt) {\n                    var doIt, responseTxt, xhrReqObj = this;\n                    if (xhrReqObj && !hasSucceeded) {\n                        responseTxt = xhrReqObj.responseText;\n                        ajax.dispatchEvent('readychange', [evnt, xhrReqObj]);\n                        if (method === 'onreadystatechange') {\n                            if (xhrReqObj.readyState === 4) {\n                                doIt = 1;\n                            }\n                        }\n                        if (method === 'onload') {\n                            doIt = 1;\n                        }\n                        if (doIt) {\n                            if ((xhrReqObj.status >= 200 && xhrReqObj.status <= 205) || xhrReqObj.status === 304 || xhrReqObj.status === 302) {\n                                responseTxt = _.parse(responseTxt);\n                                ajax.resolve(responseTxt);\n                                ajax.dispatchEvent('load', [responseTxt, evnt, xhrReqObj]);\n                                hasSucceeded = 1;\n                            } else {\n                                ajax.reject(evnt, responseTxt);\n                            }\n                        }\n                    }\n                };\n            if (_.isFunction(fn)) {\n                handler = fn;\n            }\n            if (!xhrReqObj[method]) {\n                xhrReqObj[method] = handler;\n            }\n            return ajax;\n        }\n    }, !0);\n});","application.scope().module('Associator', function (module, app, _) {\n    /**\n     * @class Associator\n     * @augments Model\n     */\n    var lengthString = 'length';\n    _.extendFrom.Model('Associator', {\n        /**\n         * @func\n         * @name Associator#get\n         * @param {Object} obj - object that data is being gotten against in the Associator\n         * @param {String} [type] - toString version of the object being passed in\n         */\n        get: function (obj, type) {\n            var returnData, idxOf, dataset, n, els, dataArray, current,\n                instance = this,\n                canRead = 0,\n                data = {\n                    dataset: {}\n                };\n            current = this.sameType(obj);\n            els = current.items;\n            dataArray = current.data;\n            if (!els) {\n                els = current.items = [];\n            }\n            if (!dataArray) {\n                dataArray = current.data = [];\n            }\n            if (obj && _.isDom && current.readData) {\n                dataset = obj.dataset;\n                // copy dataset over from one to the other\n                if (_.isObject(dataset) && _.isDom(obj)) {\n                    data.dataset = _.extend(data.dataset, dataset);\n                }\n            }\n            idxOf = current.items.indexOf(obj);\n            if (idxOf === -1) {\n                idxOf = current.items[lengthString];\n                current.items.push(obj);\n                dataArray[idxOf] = data;\n            }\n            return dataArray[idxOf];\n        },\n        /**\n         * @func\n         * @name Associator#set\n         * @param {Node} el - Element to store data against\n         * @param {Object} obj - object to extend onto current data\n         * @param {String} [type] - toString evaluation of element, if it has already been evaluated\n         * @returns {Object} data that is being held on the Associator\n         */\n        set: function (el, extensor, type) {\n            var n, data = this.get(el, type);\n            _.extend(data, extensor || {});\n            return data;\n        },\n        remove: function (el) {\n            var type = this.sameType(el);\n            var idx = _.indexOf(type.items, el);\n            var ret = _.removeAt(type.data, idx);\n            _.removeAt(type.items, idx);\n            return ret;\n        },\n        /**\n         * @func\n         * @name Associator#sameType\n         * @param {Object} obj - object to find matched types against\n         */\n        sameType: function (obj) {\n            var instance = this,\n                type = _.toString(obj),\n                current = instance[type],\n                lowerType = type.toLowerCase();\n            if (!current) {\n                // makes things easier to find\n                current = instance[type] = {};\n            }\n            // skip reading data\n            if (lowerType.indexOf('global') === -1 && lowerType.indexOf('window') === -1) {\n                current.readData = 1;\n            }\n            return current;\n        }\n    }, !0);\n    _.exports({\n        associator: _.Associator()\n    });\n});","application.scope().module('DOMM', function (module, app, _) {\n    var blank, sizzleDoc = document,\n        eq = _.eq,\n        uniqueId = _.uniqueId,\n        extendFrom = _.extendFrom,\n        factories = _.factories,\n        isFunction = _.isFunction,\n        each = _.each,\n        duff = _.duff,\n        find = _.find,\n        foldl = _.foldl,\n        isString = _.isString,\n        isObject = _.isObject,\n        isNumber = _.isNumber,\n        merge = _.merge,\n        remove = _.splice,\n        extend = _.extend,\n        negate = _.negate,\n        intendedObject = _.intendedObject,\n        isInstance = _.isInstance,\n        isBlank = _.isBlank,\n        gapJoin = _.gapJoin,\n        isArray = _.isArray,\n        toArray = _.toArray,\n        duffRev = _.duffRev,\n        indexOf = _.indexOf,\n        listHas = _.listHas,\n        gapSplit = _.gapSplit,\n        // dataCache = _.associator,\n        camelCase = _.camelCase,\n        unCamelCase = _.unCamelCase,\n        objCondense = _.objCondense,\n        parseDecimal = _.parseDecimal,\n        LENGTH_STRING = 'length',\n        itemsString = '_items',\n        __delegateCountString = '__delegateCount',\n        removeQueueString = 'removeQueue',\n        addQueueString = 'addQueue',\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        getComputed = window.getComputedStyle,\n        allStyles = getComputed(sizzleDoc.body),\n        devicePixelRatio = (window.devicePixelRatio || 1),\n        ua = navigator.userAgent,\n        /**\n         * @func\n         */\n        isAndroid = function () {\n            return ua.match(/Android/i);\n        },\n        /**\n         * @func\n         */\n        isBlackBerry = function () {\n            return ua.match(/BlackBerry/i);\n        },\n        /**\n         * @func\n         */\n        isIos = function () {\n            return ua.match(/iPhone|iPad|iPod/i);\n        },\n        /**\n         * @func\n         */\n        isOpera = function () {\n            return ua.match(/Opera Mini/i);\n        },\n        /**\n         * @func\n         */\n        isWindows = function () {\n            return ua.match(/IEMobile/i);\n        },\n        ELID_STRING = '__elid__',\n        __privateDataCache__ = {},\n        elementData = {\n            make: function (el) {\n                var elId = el[ELID_STRING] = uniqueId('elid');\n                var ret = __privateDataCache__[elId] = __privateDataCache__[elId] || {\n                    dataset: {},\n                    queued: {},\n                    handlers: {},\n                    events: {}\n                };\n                return ret;\n            },\n            get: function (el) {\n                var id = el[ELID_STRING];\n                var ret = id ? (__privateDataCache__[id] = __privateDataCache__[id] || this.make(el)) : this.make(el);\n                return ret;\n            },\n            remove: function (el) {\n                var id = el[ELID_STRING];\n                __privateDataCache__[id] = el[ELID_STRING] = void 0;\n                return id;\n            }\n        },\n        internalListAddRemove = function (keymaker, itemmaker) {\n            return function (setto) {\n                return function (base, items, subdata_, dirtifier) {\n                    var ret, subdata;\n                    if (items && items.length) {\n                        subdata = subdata_ || this.get(base);\n                        ret = !subdata.loaded && this.load(base, subdata);\n                        subdata.dirty = !dirtifier;\n                        // each item that i was passed\n                        duff(gapSplit(items), function (item) {\n                            var listitem, key = keymaker(item),\n                                index = subdata.hash[item];\n                            // do i have you?\n                            if (index === blank) {\n                                // lets make you\n                                listitem = itemmaker(subdata, key);\n                                // do i want you after you have been made?\n                                if (listitem) {\n                                    index = subdata.hash[item] = subdata.list.length;\n                                    subdata.list.push(listitem);\n                                }\n                            }\n                            // are you made and did i want you?\n                            if (index + 1) {\n                                listitem = subdata.list[index];\n                                setto(listitem, index, key, subdata);\n                            }\n                        });\n                    }\n                };\n            };\n        },\n        listAddRemove = function (datastorage, propertyname, getter, setter, keymaker, itemmaker) {\n            var madewithkey = internalListAddRemove(keymaker, itemmaker);\n            return {\n                add: madewithkey(function (listitem, index, key, subdata) {\n                    listitem.flag = BOOLEAN_TRUE;\n                }),\n                remove: madewithkey(function (listitem, index, key, subdata) {\n                    listitem.flag = BOOLEAN_FALSE;\n                }),\n                toggle: madewithkey(function (listitem, index, key, subdata) {\n                    listitem.flag = !listitem.flag;\n                }),\n                load: function (base, subdata_) {\n                    var subdata = subdata_ || this.get(base);\n                    // don't call this function again\n                    subdata.loaded = true;\n                    // load all of the base data\n                    this.add(base, getter(base), subdata, true);\n                },\n                unload: function (base, subdata_) {\n                    var subdata = subdata_ || this.get(base);\n                    // check to make sure it has at least been loaded\n                    if (subdata.loaded && subdata.dirty) {\n                        setter(base, subdata.list);\n                        this.reset();\n                    }\n                },\n                // requires base object that data is tied to\n                get: function (base) {\n                    var data = datastorage.get(base),\n                        queued = data.queued;\n                    queued[propertyname] = queued[propertyname] || this.reset();\n                    return queued[propertyname];\n                },\n                // requires subdata\n                reset: function (queued) {\n                    return {\n                        loaded: false,\n                        dirty: false,\n                        list: [],\n                        hash: {}\n                    };\n                }\n            };\n        },\n        getClassName = function (el) {\n            var className = el.className;\n            if (!isString(className)) {\n                className = el.getAttribute('class') || '';\n            }\n            return className;\n        },\n        setClassName = function (el, val) {\n            var value = val.join('');\n            if (isString(el.className)) {\n                el.className = value;\n            } else {\n                el.setAttribute('class', value);\n            }\n        },\n        queuedata = {\n            className: listAddRemove(elementData, 'className', getClassName, setClassName, function (item) {\n                return item;\n            }, function (subdata, item) {\n                return item ? {\n                    valueOf: function () {\n                        return item;\n                    },\n                    toString: function () {\n                        var adding = this.flag,\n                            classname = adding ? item : '',\n                            value = (adding && !subdata.firstAdded ? '' : ' ');\n                        if (classname) {\n                            subdata.firstAdded = true;\n                        }\n                        return value + classname;\n                    }\n                } : false;\n            })\n        },\n        /**\n         * @func\n         */\n        // isTablet = function () {\n        //     return ua.match(/Mobile|iPad|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/);\n        // },\n        rkeyEvent = /^key/,\n        rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n        rforceEvent = /^webkitmouseforce/,\n        /**\n         * @func\n         */\n        isMobile = function () {\n            return (isAndroid() || isBlackBerry() || isIos() || isOpera() || isWindows());\n        },\n        /**\n         * @func\n         */\n        isTouch = function () {\n            var ret = BOOLEAN_FALSE;\n            if ('ontouchstart' in window || 'onmsgesturechange' in window) {\n                ret = BOOLEAN_TRUE;\n            }\n            if (window.DocumentTouch) {\n                ret = sizzleDoc instanceof window.DocumentTouch;\n            }\n            return ret;\n        },\n        hasWebP = (function () {\n            var len = 4,\n                result = BOOLEAN_TRUE,\n                queue = [],\n                emptyqueue = function (fn) {\n                    return function () {\n                        len--;\n                        fn();\n                        if (!len) {\n                            duff(queue, function (item) {\n                                item(result);\n                            });\n                            queue = [];\n                        }\n                    };\n                };\n            duff([\"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\", \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\", \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\", \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"], function (val) {\n                var img = new Image();\n                img.onload = emptyqueue(function () {\n                    // is this code even doing anything?\n                    // if (result && (img.width > 0) && (img.height > 0)) {\n                    //     result = result;\n                    // }\n                });\n                img.onerror = emptyqueue(function () {\n                    result = false;\n                });\n                img.src = \"data:image/webp;base64,\" + val;\n            });\n            return function (cb) {\n                if (!len || !result) {\n                    cb(result);\n                } else {\n                    queue.push(cb);\n                }\n            };\n        }()),\n        /**\n         * @func\n         */\n        deviceCheck = _.wrap({\n            isAndroid: isAndroid,\n            isBlackBerry: isBlackBerry,\n            isIos: isIos,\n            isOpera: isOpera,\n            isWindows: isWindows,\n            isMobile: isMobile,\n            isTouch: isTouch\n        }, function (fn) {\n            return !!(fn());\n        }),\n        saveDOMContentLoadedEvent = function (doc) {\n            var data = elementData.get(doc);\n            if (data.isReady === void 0) {\n                data.isReady = BOOLEAN_FALSE;\n                _.DOMM(doc).on('DOMContentLoaded', function (e) {\n                    data.DOMContentLoadedEvent = e;\n                    data.isReady = BOOLEAN_TRUE;\n                });\n            }\n        },\n        _DOMM = _.factories._DOMM = function (doc) {\n            saveDOMContentLoadedEvent(doc);\n            return function (sel, ctx) {\n                return _.DOMM(sel, ctx || doc);\n            };\n        },\n        triggerEventWrapper = function (attr, api) {\n            attr = attr || api;\n            return function (fn, fn2) {\n                var args, evnt, count = 0,\n                    domm = this;\n                if (isFunction(fn) || isFunction(fn2)) {\n                    args = toArray(arguments);\n                    args.unshift(attr);\n                    domm.on.apply(domm, args);\n                } else {\n                    domm.duff(function (el) {\n                        var whichever = api || attr;\n                        if (isFunction(el[whichever])) {\n                            el[whichever]();\n                        } else {\n                            $(el).dispatchEvent(whichever);\n                        }\n                    });\n                }\n                return domm;\n            };\n        },\n        /**\n         * @private\n         * @func\n         */\n        htmlDataMatch = function (string, regexp, callback, nameFinder) {\n            var matches = string.trim().match(regexp);\n            duff(matches, function (idx, match) {\n                var value;\n                match = match.trim();\n                value = match.match(/~*=[\\'|\\\"](.*?)[\\'|\\\"]/);\n                name = match.match(/(.*)(?:~*=)/igm);\n                name = _.join(_.split(name, '='), '').trim();\n                callback(value[1], name, match);\n            });\n        },\n        Events = gapSplit('abort afterprint beforeprint blocked cached canplay canplaythrough change chargingchange chargingtimechange checking close complete dischargingtimechange DOMContentLoaded downloading durationchange emptied ended error fullscreenchange fullscreenerror input invalid languagechange levelchange loadeddata loadedmetadata message noupdate obsolete offline online open pagehide pageshow paste pause pointerlockchange pointerlockerror play playing ratechange reset seeked seeking stalled storage submit success suspend timeupdate updateready upgradeneeded versionchange visibilitychange'),\n        SVGEvent = gapSplit('SVGAbort SVGError SVGLoad SVGResize SVGScroll SVGUnload SVGZoom volumechange waiting'),\n        KeyboardEvent = gapSplit('keydown keypress keyup'),\n        GamePadEvent = gapSplit('gamepadconnected gamepadisconnected'),\n        CompositionEvent = gapSplit('compositionend compositionstart compositionupdate drag dragend dragenter dragleave dragover dragstart drop'),\n        MouseEvents = gapSplit('click contextmenu dblclick mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup show wheel'),\n        TouchEvents = gapSplit('touchcancel touchend touchenter touchleave touchmove touchstart'),\n        DeviceEvents = gapSplit('devicemotion deviceorientation deviceproximity devicelight'),\n        FocusEvent = gapSplit('blur focus'),\n        // BeforeUnloadEvent = gapSplit(''),\n        TimeEvent = gapSplit('beginEvent endEvent repeatEvent'),\n        AnimationEvent = gapSplit('animationend animationiteration animationstart transitionend'),\n        AudioProcessingEvent = gapSplit('audioprocess complete'),\n        UIEvents = gapSplit('abort error hashchange load orientationchange readystatechange resize scroll select unload beforeunload'),\n        ProgressEvent = gapSplit('abort error load loadend loadstart popstate progress timeout'),\n        AllEvents = _.concatUnique(Events, SVGEvent, KeyboardEvent, CompositionEvent, GamePadEvent, MouseEvents, TouchEvents, DeviceEvents, FocusEvent, TimeEvent, AnimationEvent, AudioProcessingEvent, UIEvents, ProgressEvent),\n        knownPrefixes = gapSplit('-o- -ms- -moz- -webkit- mso- -xv- -atsc- -wap- -khtml- -apple- prince- -ah- -hp- -ro- -rim- -tc-'),\n        trustedEvents = gapSplit('load scroll resize orientationchange click dblclick mousedown mouseup mouseover mouseout mouseenter mouseleave mousemove change contextmenu hashchange load mousewheel wheel readystatechange'),\n        setClass = function (el, val) {\n            if (isString(el.className)) {\n                el.className = val;\n            } else {\n                el.setAttribute('class', val);\n            }\n        },\n        knownPrefixesHash = _.wrap(knownPrefixes, true),\n        /**\n         * @private\n         * @func\n         */\n        getClass = function (el) {\n            var className = el.className;\n            if (!isString(className)) {\n                className = el.getAttribute('class') || '';\n            }\n            return gapSplit(className);\n        },\n        changeClass = function (el, remove, add) {\n            var subdata = queuedata.className.get(el);\n            queuedata.className.remove(el, remove, subdata);\n            queuedata.className.add(el, add, subdata);\n            queuedata.className.unload(el, subdata);\n        },\n        removeClass = function (el, remove) {\n            var subdata = queuedata.className.get(el);\n            queuedata.className.remove(el, remove, subdata);\n            queuedata.className.unload(el, subdata);\n        },\n        addClass = function (el, add) {\n            var subdata = queuedata.className.get(el);\n            queuedata.className.add(el, add, subdata);\n            queuedata.className.unload(el, subdata);\n        },\n        eventNameProperties = function (str) {},\n        /**\n         * @private\n         * @func\n         */\n        toStyleString = function (css) {\n            var cssString = [];\n            each(css, function (name, val) {\n                var nameSplit;\n                name = unCamelCase(name);\n                nameSplit = name.split('-');\n                if (knownPrefixesHash[nameSplit[0]]) {\n                    nameSplit.unshift('');\n                }\n                name = nameSplit.join('-');\n                cssString.push(name + ': ' + val + ';');\n            });\n            return cssString.join(' ');\n        },\n        // toCssObject = function () {},\n        /**\n         * @private\n         * @func\n         */\n        isDom = function (el) {\n            var hasAttr, retVal = BOOLEAN_FALSE;\n            if (isObject(el)) {\n                if (isObject(el.style)) {\n                    if (isString(el.tagName)) {\n                        if (isFunction(el.getBoundingClientRect)) {\n                            retVal = BOOLEAN_TRUE;\n                        }\n                    }\n                }\n            }\n            return retVal;\n        },\n        ensureDOM = function (fn) {\n            return function (el) {\n                if (isDom(el)) {\n                    fn(el);\n                }\n            };\n        },\n        /**\n         * @private\n         * @func\n         */\n        // returns the flow of the element passed on relative to the element's bounding window\n        position = function (el) {\n            var clientRect = el.getBoundingClientRect(),\n                computedStyle = getComputed(el),\n                marginTop = parseFloat(computedStyle.marginTop),\n                marginLeft = parseFloat(computedStyle.marginLeft),\n                marginRight = parseFloat(computedStyle.marginRight),\n                marginBottom = parseFloat(computedStyle.marginBottom);\n            return {\n                height: clientRect.height,\n                width: clientRect.width,\n                top: clientRect.top - marginTop,\n                left: clientRect.left - marginLeft,\n                right: clientRect.left - marginLeft + clientRect.width - marginRight,\n                bottom: clientRect.top - marginTop + clientRect.height - marginBottom\n            };\n        },\n        numberBasedCss = {\n            columnCount: BOOLEAN_TRUE,\n            columns: BOOLEAN_TRUE,\n            fontWeight: BOOLEAN_TRUE,\n            lineHeight: BOOLEAN_TRUE,\n            opacity: BOOLEAN_TRUE,\n            zIndex: BOOLEAN_TRUE,\n            zoom: BOOLEAN_TRUE,\n            animationIterationCount: BOOLEAN_TRUE,\n            boxFlex: BOOLEAN_TRUE,\n            boxFlexGroup: BOOLEAN_TRUE,\n            boxOrdinalGroup: BOOLEAN_TRUE,\n            flex: BOOLEAN_TRUE,\n            flexGrow: BOOLEAN_TRUE,\n            flexPositive: BOOLEAN_TRUE,\n            flexShrink: BOOLEAN_TRUE,\n            flexNegative: BOOLEAN_TRUE,\n            flexOrder: BOOLEAN_TRUE,\n            lineClamp: BOOLEAN_TRUE,\n            order: BOOLEAN_TRUE,\n            orphans: BOOLEAN_TRUE,\n            tabSize: BOOLEAN_TRUE,\n            widows: BOOLEAN_TRUE,\n            // SVG-related properties\n            fillOpacity: BOOLEAN_TRUE,\n            stopOpacity: BOOLEAN_TRUE,\n            strokeDashoffset: BOOLEAN_TRUE,\n            strokeOpacity: BOOLEAN_TRUE,\n            strokeWidth: BOOLEAN_TRUE\n        },\n        timeBasedCss = {\n            transitionDuration: BOOLEAN_TRUE,\n            animationDuration: BOOLEAN_TRUE,\n            transitionDelay: BOOLEAN_TRUE,\n            animationDelay: BOOLEAN_TRUE\n        },\n        /**\n         * @private\n         * @func\n         */\n        css = (function () {\n            var i, j, n, found, prefixIndex, __prefix, styleName, currentCheck, deprefixed, currentLen,\n                validCssNames = [],\n                prefixed = {},\n                len = 0,\n                valueModifiers = {\n                    '-webkit-transform': function (val) {\n                        return val;\n                    }\n                },\n                modifyFinalProp = function (prop, val) {\n                    if (valueModifiers[prop]) {\n                        val = valueModifiers[prop](val);\n                    }\n                    return val;\n                },\n                addPrefix = function (list, prefix) {\n                    if (!_.listHas(list, __prefix)) {\n                        list.push(__prefix);\n                    }\n                };\n            for (i = 0; i < knownPrefixes[LENGTH_STRING]; i++) {\n                currentLen = knownPrefixes[i][LENGTH_STRING];\n                if (len < currentLen) {\n                    len = currentLen;\n                }\n            }\n            for (n in allStyles) {\n                found = 0;\n                currentCheck = '';\n                __prefix = '';\n                if (isNumber(+n)) {\n                    styleName = allStyles[n];\n                } else {\n                    styleName = unCamelCase(n);\n                }\n                deprefixed = styleName;\n                for (j = 0; j < len && styleName[j] && !found; j++) {\n                    currentCheck += styleName[j];\n                    prefixIndex = indexOf(knownPrefixes, currentCheck);\n                    if (prefixIndex !== -1) {\n                        __prefix = knownPrefixes[prefixIndex];\n                        deprefixed = styleName.split(__prefix).join('');\n                        found = 1;\n                    }\n                    prefixIndex = indexOf(knownPrefixes, '-' + currentCheck);\n                    if (prefixIndex !== -1) {\n                        __prefix = knownPrefixes[prefixIndex];\n                        deprefixed = styleName.split(currentCheck).join('');\n                        found = 1;\n                    }\n                }\n                deprefixed = camelCase(deprefixed);\n                validCssNames.push(deprefixed);\n                if (!prefixed[deprefixed]) {\n                    prefixed[deprefixed] = [];\n                }\n                addPrefix(prefixed[deprefixed], __prefix);\n            }\n            return function (el, key, value) {\n                var n, m, j, firstEl, lastKey, prefixes, unCameled, computed, _ret, retObj, finalProp, i = 0,\n                    ret = {},\n                    count = 0,\n                    nuCss = {};\n                if (isObject(el)) {\n                    if (_.isBool(obj)) {\n                        obj = el;\n                        retObj = 1;\n                    }\n                    firstEl = el[0];\n                    intendedObject(key, value, function (key, value) {\n                        if (!isBlank(value)) {\n                            count++;\n                            prefixes = [''];\n                            if (prefixed[m]) {\n                                prefixes = prefixed[m].concat(prefixes);\n                            }\n                            for (j = 0; j < prefixes[LENGTH_STRING]; j++) {\n                                finalProp = camelCase(prefixes[j] + m);\n                                nuCss[finalProp] = modifyFinalProp(finalProp, value);\n                            }\n                        } else {\n                            ret[m] = value;\n                        }\n                    });\n                    if (retObj) {\n                        return nuCss;\n                    }\n                    if (isDom(el)) {\n                        el = [el];\n                    }\n                    if (!count) {\n                        if (isDom(firstEl)) {\n                            _ret = {};\n                            computed = getComputed(firstEl);\n                            count--;\n                            each(ret, function (val_, key, obj) {\n                                _ret[key] = convertStyleValue(key, computed[key]);\n                                count++;\n                                lastKey = key;\n                            });\n                            if (count + 1) {\n                                if (count) {\n                                    return _ret;\n                                } else {\n                                    return _ret[lastKey];\n                                }\n                            }\n                        }\n                    } else {\n                        style(el, nuCss);\n                    }\n                }\n            };\n        }()),\n        convertStyleValue = function (key, value_) {\n            var value = value_;\n            if (value === +value) {\n                if (timeBasedCss[key]) {\n                    value += 'ms';\n                }\n                if (!numberBasedCss[key]) {\n                    value += 'px';\n                }\n            }\n            return value;\n        },\n        style = function (els, key, value) {\n            if (els[LENGTH_STRING]) {\n                intendedObject(key, value, function (key, value_) {\n                    var value = convertStyleValue(value_);\n                    duff(els, ensureDOM(function (el) {\n                        el.style[key] = value;\n                    }));\n                });\n            }\n        },\n        prefixer = function (obj) {\n            var rez = css(obj, BOOLEAN_TRUE);\n            return rez;\n        },\n        jsToCss = function (obj) {\n            var nuObj = {};\n            each(obj, function (key, val) {\n                var deCameled = unCamelCase(key),\n                    split = deCameled.split('-'),\n                    starter = split[0],\n                    idx = indexOf(knownPrefixes, '-' + starter + '-');\n                if (idx !== -1) {\n                    split[0] = '-' + starter;\n                }\n                nuObj[split.join('-')] = val;\n            });\n            return nuObj;\n        },\n        /**\n         * @private\n         * @func\n         */\n        box = function (el) {\n            var computed, ret = {};\n            if (isDom(el)) {\n                computed = getComputed(el);\n                ret = merge({\n                    borderBottom: parseFloat(computed.borderBottomWidth) || 0,\n                    borderRight: parseFloat(computed.borderRightWidth) || 0,\n                    borderLeft: parseFloat(computed.borderLeftWidth) || 0,\n                    borderTop: parseFloat(computed.borderTopWidth) || 0,\n                    paddingBottom: parseFloat(computed.paddingBottom) || 0,\n                    paddingRight: parseFloat(computed.paddingRight) || 0,\n                    paddingLeft: parseFloat(computed.paddingLeft) || 0,\n                    paddingTop: parseFloat(computed.paddingTop) || 0,\n                    marginBottom: parseFloat(computed.marginBottom) || 0,\n                    marginRight: parseFloat(computed.marginRight) || 0,\n                    marginLeft: parseFloat(computed.marginLeft) || 0,\n                    marginTop: parseFloat(computed.marginTop) || 0,\n                    computedBottom: parseFloat(computed.bottom) || 0,\n                    computedRight: parseFloat(computed.right) || 0,\n                    computedLeft: parseFloat(computed.left) || 0,\n                    computedTop: parseFloat(computed.top) || 0\n                }, clientRect(el));\n            }\n            return ret;\n        },\n        clientRect = function (item) {\n            var ret = {};\n            if (item) {\n                if (isDom(item) && item.parentNode) {\n                    ret = item.getBoundingClientRect();\n                }\n            }\n            return extend({\n                top: 0,\n                left: 0,\n                right: 0,\n                bottom: 0,\n                width: 0,\n                height: 0\n            }, ret);\n        },\n        /**\n         * @private\n         * @func\n         */\n        unitRemoval = function (str, unit) {\n            return parseFloat(str.split(unit || 'px').join('').trim()) || 0;\n        },\n        /**\n         * @private\n         * @func\n         */\n        getStyleSize = function (el, attr) {\n            var val, elStyle, num = el;\n            if (isObject(el)) {\n                if (isDom(el)) {\n                    elStyle = getComputed(el);\n                } else {\n                    elStyle = el;\n                }\n                val = elStyle[attr];\n            } else {\n                val = el;\n            }\n            if (isString(val)) {\n                val = unitRemoval(val);\n            }\n            return val;\n        },\n        /**\n         * @private\n         * @func\n         */\n        filterExpressions = {\n            ':even': function (el, idx) {\n                return (idx % 2);\n            },\n            ':odd': function (el, idx) {\n                return ((idx + 1) % 2);\n            }\n        },\n        // always in pixels\n        numToUnitsConverters = {\n            'in': function (val, el, win, styleAttr) {\n                return val / 96;\n            },\n            vh: function (val, el, win, styleAttr) {\n                return (val / win.innerHeight) * 100;\n            },\n            px: function (val, el, win, styleAttr) {\n                return val;\n            },\n            cm: function (val, el, win, styleAttr) {\n                return val / 37.79527559055118;\n            },\n            vw: function (val, el, win, styleAttr) {\n                return (val / win.innerWidth) * 100;\n            },\n            em: function (val, el, win, styleAttr) {\n                return val / getStyleSize(el, 'fontSize');\n            },\n            mm: function (val, el, win, styleAttr) {\n                return val / 3.779527559055118;\n            },\n            vmin: function (val, el, win, styleAttr) {\n                var mult = Math.min(win.innerHeight, win.innerWidth);\n                return (val / mult) * 100;\n            },\n            rem: function (val, el, win, styleAttr) {\n                return val / getStyleSize(win.document.body.parentNode, 'fontSize');\n            },\n            pt: function (val, el, win, styleAttr) {\n                return val / 1.333333333333333;\n            },\n            vmax: function (val, el, win, styleAttr) {\n                var mult = Math.max(win.innerHeight, win.innerWidth);\n                return (val / mult) * 100;\n            },\n            '%': function (val, el, win, styleAttr) {\n                var parent = _.isDom(el) ? el.parentNode : el,\n                    _val = getStyleSize(parent, styleAttr);\n                return (val / _val) * 100;\n            },\n            pc: function (val, el, win, styleAttr) {\n                return val / 16;\n            }\n        },\n        numToUnits = function (num, unit, el, winTop, styleAttr, returnNum) {\n            var number = num;\n            if (num) {\n                number = numToUnitsConverters[unit](num, el, winTop, styleAttr);\n            }\n            number = (number || 0);\n            if (!returnNum) {\n                number += unit;\n            }\n            return number;\n        },\n        /**\n         * @private\n         * @func\n         */\n        unitsToNumConverters = {\n            // 'in'\n            // vh\n            // px\n            // cm\n            // vw\n            // em\n            // mm\n            // vmin\n            // rem\n            // pt\n            // vmax\n            // '%'\n            // pc\n            'in': function (val, el, win, styleAttr) {\n                return val * 96;\n            },\n            vh: function (val, el, win, styleAttr) {\n                return win.innerHeight * val / 100;\n            },\n            px: function (val, el, win, styleAttr) {\n                return val;\n            },\n            cm: function (val, el, win, styleAttr) {\n                return val * 37.79527559055118;\n            },\n            vw: function (val, el, win, styleAttr) {\n                return win.innerWidth * val / 100;\n            },\n            em: function (val, el, win, styleAttr) {\n                return getStyleSize(el, 'fontSize') * val;\n            },\n            mm: function (val, el, win, styleAttr) {\n                return val * 3.779527559055118;\n            },\n            vmin: function (val, el, win, styleAttr) {\n                return ((Math.min(win.innerHeight, win.innerWidth) || 1) * val / 100);\n            },\n            rem: function (val, el, win, styleAttr) {\n                return getStyleSize(win.document.body.parentNode, 'fontSize') * val;\n            },\n            pt: function (val, el, win, styleAttr) {\n                return val * 1.333333333333333;\n            },\n            vmax: function (val, el, win, styleAttr) {\n                return ((Math.max(win.innerHeight, win.innerWidth) || 1) * val / 100);\n            },\n            '%': function (val, el, win, styleAttr) {\n                var parent = _.isDom(el) ? el.parentNode : el,\n                    _val = getStyleSize(parent, styleAttr);\n                return (val * _val) / 100;\n            },\n            pc: function (val, el, win, styleAttr) {\n                return val * 16;\n            }\n        },\n        unitsToNum = function (str, el, winTop, styleAttr) {\n            var ret, number, unit = _.units(str);\n            if (unit) {\n                number = +(str.split(unit).join('')) || 0;\n                if (unitsToNumConverters[unit]) {\n                    number = unitsToNumConverters[unit](number, el, winTop, styleAttr) || 0;\n                }\n            } else {\n                // you passed in a number\n                number = str;\n            }\n            return number;\n        },\n        /**\n         * @private\n         * @func\n         */\n        containsClass = function (el, className) {\n            var idxOf, original = getClass(el),\n                nuClasses = gapSplit(className),\n                nuClassesLen = nuClasses[LENGTH_STRING],\n                i = 0,\n                has = 0;\n            for (; i < nuClassesLen; i++) {\n                idxOf = indexOf(original, nuClasses[i]);\n                if (idxOf !== -1) {\n                    has++;\n                }\n            }\n            return (has === nuClassesLen);\n        },\n        /**\n         * @private\n         * @func\n         */\n        tagIs = function (el, str) {\n            var tagName;\n            if (el && isObject(el)) {\n                tagName = el.tagName;\n                if (isString(tagName)) {\n                    return tagName.toLowerCase() === str.toLowerCase();\n                }\n            }\n        },\n        /**\n         * @private\n         * @func\n         */\n        isWin = function (obj) {\n            return obj && obj === obj.window;\n        },\n        /**\n         * @private\n         * @func\n         */\n        isDoc = function (obj) {\n            return obj && isNumber(obj.nodeType) && obj.nodeType === obj.DOCUMENT_NODE;\n        },\n        isFrag = function (frag) {\n            return frag && frag.nodeType === sizzleDoc.DOCUMENT_FRAGMENT_NODE;\n        },\n        /**\n         * @private\n         * @func\n         */\n        isTrustedEvent = function (name) {\n            return (indexOf(trustedEvents, name) !== -1);\n        },\n        /**\n         * @private\n         * @func\n         */\n        createEl = function (str) {\n            return sizzleDoc.createElement(str);\n        },\n        makeEmptyFrame = function (str) {\n            var frame, div = createEl('div');\n            div.innerHTML = str;\n            frame = div.children[0];\n            return $(frame);\n        },\n        makeTree = function (str) {\n            var div = createEl('div');\n            div.innerHTML = str;\n            return $(div.children).remove().un();\n        },\n        /**\n         * @private\n         * @func\n         */\n        // makeScriptTag = function (src) {\n        //     var scriptTag = createEl('script');\n        //     scriptTag.type = 'text/javascript';\n        //     scriptTag.src = src;\n        //     return scriptTag;\n        // },\n        /**\n         * @private\n         * @func\n         */\n        matches = function (element, selector) {\n            var match, parent, temp, matchesSelector;\n            if (!selector || !element || element.nodeType !== 1) {\n                return BOOLEAN_FALSE;\n            }\n            matchesSelector = element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector;\n            if (matchesSelector) {\n                return matchesSelector.call(element, selector);\n            }\n            // fall back to performing a selector:\n            parent = element.parentNode;\n            temp = !parent;\n            if (temp) {\n                parent = createEl('div');\n                parent.appendChild(element);\n            }\n            // temp && tempParent.removeChild(element);\n            return !!_.posit(_.Sizzle(selector, parent), element);\n        },\n        setAttribute = function (el, key, val) {\n            if (val === true) {\n                val = '';\n            }\n            val = _.stringify(val);\n            val += '';\n            el.setAttribute(key, val);\n        },\n        getAttribute = function (el, key, val) {\n            var converted;\n            val = el.getAttribute(key);\n            if (val === '') {\n                val = BOOLEAN_TRUE;\n            }\n            if (isString(val)) {\n                if (val[0] === '{' || val[0] === '[') {\n                    val = JSON.parse(val);\n                } else {\n                    converted = +val;\n                    if (converted === converted) {\n                        val = converted;\n                    } else {\n                        // if for whatever reason you have a function\n                        if (val[val.length - 1] === '}') {\n                            if (val.slice(0, 8) === 'function') {\n                                val = new Function.constructor('return ' + val);\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (isBlank(val)) {\n                    val = BOOLEAN_FALSE;\n                }\n            }\n            return val;\n        },\n        /**\n         * @private\n         * @func\n         */\n        attributeInterface = function (el, key, val) {\n            // set or remove if not undefined\n            // undefined fills in the gap by returning some value, which is never undefined\n            if (val !== blank) {\n                if (!val && val !== 0) {\n                    el.removeAttribute(key);\n                } else {\n                    setAttribute(el, key, val);\n                }\n            } else {\n                return getAttribute(el, key, val);\n            }\n        },\n        /**\n         * @private\n         * @func\n         */\n        eachProc = function (fn) {\n            return function () {\n                var args = toArray(arguments),\n                    domm = this;\n                args.unshift(domm);\n                domm.duff(function (el) {\n                    args[0] = el;\n                    fn.apply(domm, args);\n                });\n                return domm;\n            };\n        },\n        /**\n         * @private\n         * @func\n         */\n        makeEl = function (tagName) {\n            return $(foldl(gapSplit(tagName), function (memo, name) {\n                memo.push(createEl(name));\n                return memo;\n            }, []));\n        },\n        createDocFrag = function () {\n            return sizzleDoc.createDocumentFragment();\n        },\n        frag = function (el) {\n            var frag = createDocFrag(),\n                els = el[itemsString] || el;\n            if (!_.isArrayLike(els)) {\n                els = [els];\n            }\n            duff(els, function (el) {\n                frag.appendChild(el);\n            });\n            return frag;\n        },\n        makeEls = function (arr, tag, style, props, attrs) {\n            var frag = createDocFrag();\n            map(arr, function (idx, str) {\n                var div = createEl(tag || 'div');\n                div.innerHTML = str;\n                each(style, function (key, val) {\n                    div.style[key] = val;\n                });\n                each(props, function (key, val) {\n                    div[key] = val;\n                });\n                each(attrs, function (key, val) {\n                    attributeInterface(div, key, val);\n                });\n                frag.appendChild(div);\n            });\n            return frag;\n        },\n        /**\n         * @private\n         * @func\n         */\n        htmlTextManipulator = function (attr) {\n            return function (str) {\n                var dom = this,\n                    nuStr = '';\n                if (isString(str)) {\n                    return dom.duff(function (el) {\n                        el[attr] = str;\n                    });\n                } else {\n                    dom.duff(function (el) {\n                        nuStr += el[attr];\n                    });\n                    return nuStr;\n                }\n            };\n        },\n        horizontalTraverser = function (_idxChange) {\n            return attachPrevious(function (idxChange) {\n                var domm = this,\n                    collected = [],\n                    list = domm[itemsString];\n                idxChange = _idxChange || idxChange;\n                if (idxChange) {\n                    duff(list, function (idx_, el) {\n                        var parent = el.parentNode,\n                            idx = (indexOf(parent.children, el) + idxChange),\n                            item = parent.children[idx];\n                        if (item && !_.listHas(list, item)) {\n                            _.add(collected, item);\n                        }\n                    });\n                } else {\n                    collected = list;\n                }\n                return collected;\n            });\n        },\n        domAttrManipulator = function (fn, getData) {\n            // cant wrap in each because need to return custom data\n            return function (key, value) {\n                var dataKeys = [],\n                    dom = this,\n                    ret = {},\n                    count = 0,\n                    cachedData = [],\n                    domList = dom.un();\n                // moved to outside because iterating over objects is more\n                // time consuming than iterating over a straight list\n                intendedObject(key, value, function (__key, val) {\n                    var __keys = gapSplit(__key);\n                    dataKeys.push(__key);\n                    duff(domList, function (el, idx) {\n                        var data;\n                        if (getData) {\n                            data = cachedData[idx] = cachedData[idx] || elementData.get(el);\n                        }\n                        duff(__keys, function (_key) {\n                            var value = fn(el, _key, val, data, dom);\n                            if (value !== blank) {\n                                ret[_key] = value;\n                                count++;\n                            }\n                        });\n                    });\n                });\n                if (dataKeys[LENGTH_STRING] === 1) {\n                    if (count === 1) {\n                        ret = ret[dataKeys[0]];\n                    } else {\n                        if (!count) {\n                            ret = dom;\n                        }\n                    }\n                } else {\n                    ret = dom;\n                }\n                return ret;\n            };\n        },\n        attachPrevious = function (fn) {\n            return function () {\n                var prev = this;\n                // ensures it's still a dom object\n                var obj = $(fn.apply(this, arguments));\n                obj._previous = prev;\n                return obj;\n            };\n        },\n        // coordinates\n        covers = function (element, coords) {\n            var _clientRect = clientRect(element),\n                bottom = _clientRect.bottom,\n                right = _clientRect.right,\n                left = _clientRect.left,\n                tippytop = _clientRect.top,\n                x = coords.x,\n                y = coords.y,\n                ret = BOOLEAN_FALSE;\n            if (x > left && x < right && y > tippytop && y < bottom) {\n                ret = BOOLEAN_TRUE;\n            }\n            return ret;\n        },\n        center = function (clientRect) {\n            return {\n                x: clientRect.left + (clientRect.width / 2),\n                y: clientRect.top + (clientRect.height / 2)\n            };\n        },\n        distance = function (a, b) {\n            var xdiff = a.x - b.x,\n                ydiff = a.y - b.y;\n            return Math.sqrt((xdiff * xdiff) + (ydiff * ydiff));\n        },\n        closer = function (center, current, challenger) {\n            return distance(center, current) < distance(center, challenger);\n        },\n        flattenBlock = function (block, selector, spaced) {\n            var children = [],\n                _flat = {},\n                flat = {};\n            _.each(block, function (property, value) {\n                var gah;\n                if (_.isObject(value)) {\n                    children.push(flattenBlock(value, selector + ' ' + property));\n                } else {\n                    flat[property] = value;\n                }\n            });\n            _flat[selector] = flat;\n            _flat = [_flat];\n            return _flat.concat.apply(_flat, children);\n        },\n        buildBlocks = function (blocks) {\n            var allBlocks = coll();\n            _.each(blocks, function (block, selector) {\n                allBlocks = allBlocks.concat(flattenBlock(block, selector));\n            });\n            return allBlocks;\n        },\n        stringifyPair = function (property, value) {\n            return property + ':' + value + ';';\n        },\n        stringifyBlock = function (block, selector, opts) {\n            var blockString = '' + selector + '{';\n            opts = extend({\n                line: '\\n',\n                tab: '\\t',\n                minify: 1\n            }, opts || {});\n            each(jsToCss(prefixer(block)), function (property, value) {\n                if (_.isObject(value)) {\n                    blockString += stringifyBlock(value, property, opts);\n                } else {\n                    blockString += stringifyPair(property, value);\n                }\n            });\n            if (blockString[blockString[LENGTH_STRING] - 1] !== '{') {\n                blockString += '}';\n            } else {\n                blockString = '';\n            }\n            return blockString;\n        },\n        buildStyles = function (obj, opts) {\n            return coll(obj).foldl(function (memo, idx, item) {\n                memo += buildBlocks(item).foldl(function (memo, idx, block) {\n                    _.each(block, function (block, idx, selector) {\n                        memo += stringifyBlock(block, selector, opts);\n                    });\n                    return memo;\n                }, '');\n                memo += '\\n';\n                return memo;\n            }, '').split(' &').join('');\n        },\n        // parseEventName = function (name) {\n        //     var ret = [\n        //         [],\n        //         []\n        //     ];\n        //     duff(gapSplit(name), function (nme) {\n        //         var captures = BOOLEAN_FALSE;\n        //         if (nme[0] === '_') {\n        //             nme = nme.slice(1);\n        //             captures = BOOLEAN_TRUE;\n        //         }\n        //         duff(gapSplit(eventExpander[nme] || nme), function (nm) {\n        //             ret[0].push(nm);\n        //             ret[1].push(captures);\n        //         });\n        //     });\n        //     return ret;\n        // },\n        createSelector = function (domm, args, fn) {\n            var fun, selector, name = args.shift();\n            if (isString(args[0]) || isBlank(args[0])) {\n                selector = args.shift();\n            }\n            // if (isFunction(args[0])) {\n            //     args[0] = [args[0]];\n            // }\n            if (isFunction(args[0])) {\n                fn = _.bind(fn, domm);\n                fun = args[0];\n                // duff(args[0], function (fun) {\n                duff(gapSplit(name), function (nme) {\n                    var split = eventToNamespace(nme),\n                        captures = BOOLEAN_FALSE,\n                        namespaceSplit = nme.split('.'),\n                        nm = namespaceSplit.shift(),\n                        namespace = namespaceSplit.join('.');\n                    if (nm[0] === '_') {\n                        nm = nm.slice(1);\n                        captures = BOOLEAN_TRUE;\n                    }\n                    fn(nm, namespace, selector, fun, captures);\n                });\n            }\n        },\n        ensureOne = function (fn) {\n            return function () {\n                if (this.length()) {\n                    fn.apply(this, arguments);\n                }\n                return this;\n            };\n        },\n        expandEventListenerArguments = function (fn) {\n            return ensureOne(function () {\n                var args, obj, selector, domm = this;\n                // if there's nothing selected, then do nothing\n                args = toArray(arguments);\n                obj = args.shift();\n                if (isObject(obj)) {\n                    if (isString(args[0])) {\n                        selector = args.shift();\n                    }\n                    each(obj, function (key, handlers) {\n                        createSelector(domm, [key, selector, handlers].concat(args), fn);\n                    });\n                } else {\n                    args.unshift(obj);\n                    createSelector(domm, args, fn);\n                }\n            });\n        },\n        validateEvent = function (evnt, el) {\n            if (isString(evnt)) {\n                evnt = {\n                    type: evnt,\n                    bubbles: BOOLEAN_FALSE,\n                    eventPhase: 2,\n                    cancelable: BOOLEAN_FALSE,\n                    defaultPrevented: BOOLEAN_FALSE,\n                    data: '',\n                    isTrusted: BOOLEAN_FALSE,\n                    timeStamp: _.nowish(),\n                    target: el\n                };\n            }\n            return evnt;\n        },\n        isCapturing = function (evnt) {\n            var capturing = BOOLEAN_FALSE,\n                eventPhase = evnt.eventPhase;\n            if (eventPhase === 1) {\n                capturing = BOOLEAN_TRUE;\n            }\n            if (eventPhase === 2 && !evnt.bubbles && isDom(evnt.srcElement)) {\n                capturing = BOOLEAN_TRUE;\n            }\n            return capturing;\n        },\n        findMatch = function (el, target, selector) {\n            var parent, found = null;\n            if (selector && isString(selector)) {\n                parent = target;\n                while (parent && !found && isDom(parent) && parent !== el) {\n                    if (matches(parent, selector)) {\n                        found = parent;\n                    }\n                    parent = parent.parentNode;\n                }\n            }\n            return found;\n        },\n        getMainHandler = function (data, name, capturing) {\n            return data.handlers[capturing + ':' + name];\n        },\n        dispatchEvent = function (el, evnt, capturing, data, args, selector) {\n            var e, gah, eventNameStack, capturingStack, events, stack, currentEventStack, selectorIsString, mainHandler, eventType, removeStack, $el, matches = 1;\n            evnt = validateEvent(evnt, el);\n            if (evnt && evnt.type) {\n                capturing = !!capturing;\n                if (!_.isObject(data)) {\n                    data = elementData.get(el);\n                }\n                events = data.events;\n                capturingStack = events[capturing];\n                if (capturingStack) {\n                    eventType = evnt.type;\n                    eventNameStack = capturingStack[eventType];\n                    // currentEventStack = data[currentEventStackString];\n                    mainHandler = getMainHandler(data, eventType, capturing);\n                    if (mainHandler) {\n                        removeStack = mainHandler[removeQueueString];\n                        $el = $(el);\n                        e = new Event(evnt, el);\n                        args = [e].concat(args || []);\n                        // selectorIsString = isString(selector);\n                        find(eventNameStack, function (obj) {\n                            var selectorsMatch, ctx, originalTarget = e.currentTarget,\n                                mainHandler = obj.mainHandler;\n                            if (mainHandler.currentEvent) {\n                                return BOOLEAN_TRUE;\n                            }\n                            mainHandler.currentEvent = obj;\n                            if (obj && obj.persist && !obj.disabled) {\n                                if (obj.selector) {\n                                    ctx = findMatch(el, evnt.target, obj.selector);\n                                    if (ctx) {\n                                        e.currentTarget = ctx;\n                                    } else {\n                                        mainHandler.currentEvent = null;\n                                        return;\n                                    }\n                                }\n                                // e.type = obj.passedName;\n                                obj.fn.apply(ctx || $el, args);\n                            }\n                            if (!obj.persist) {\n                                // puts it on the event queue\n                                removeEventQueue(obj);\n                            }\n                            e.currentTarget = originalTarget;\n                            mainHandler.currentEvent = null;\n                            return e.isImmediatePropagationStopped;\n                        });\n                        duffRev(removeStack, removeEventQueue);\n                        while (mainHandler[addQueueString].length) {\n                            addEventQueue(mainHandler[addQueueString][0]);\n                            gah = mainHandler[addQueueString].shift();\n                        }\n                    }\n                }\n            }\n        },\n        matchesHandler = function (handler, obj) {\n            return !handler || obj.fn === handler;\n        },\n        _eventExpander = (function (__obj) {\n            var obj = {};\n            each(__obj, function (key, val, object) {\n                obj[key] = gapSplit(val);\n            });\n            return obj;\n        }({\n            deviceorientation: 'deviceorientation mozOrientation',\n            fullscreenalter: 'webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange',\n            hover: 'mouseenter mouseleave',\n            forcetouch: 'webkitmouseforcewillbegin webkitmouseforcedown webkitmouseforceup webkitmouseforcechanged'\n        })),\n        distilledEventName = (function () {\n            var obj = {};\n            each(_eventExpander, function (key, arr) {\n                duff(arr, function (idx, item) {\n                    obj[item] = key;\n                });\n            });\n            return obj;\n        }()),\n        eventExpander = function (fn_) {\n            return function (nme, idx) {\n                var fn = _.bind(fn_, this);\n                duff(gapSplit(_eventExpander[nme] || nme), function (name, idx) {\n                    fn(name, nme);\n                });\n            };\n        },\n        addEventListener = expandEventListenerArguments(function (name, namespace, selector, callback, capture) {\n            var dom = this;\n            if (isFunction(callback)) {\n                dom.duff(function (el) {\n                    _addEventListener(el, name, namespace, selector, callback, capture);\n                });\n            }\n            return dom;\n        }),\n        eventToNamespace = function (evnt) {\n            if (!isString(evnt)) {\n                evnt = evnt.type;\n            }\n            evnt = evnt.split('.');\n            var evntName = evnt.shift();\n            return [evntName, evnt.sort().join('.')];\n        },\n        _addEventListener = function (el, types, namespace, selector, fn, capture) {\n            var handleObj, eventHandler, data = elementData.get(el),\n                handlers = data.handlers = data.handlers || {},\n                events = data.events = data.events || {},\n                capturehash = events[capture] = events[capture] || {};\n            duff(gapSplit(types), eventExpander(function (name, passedName) {\n                var attach, mainHandler, handlerKey = capture + ':' + name,\n                    namespaceCache = capturehash[name] = capturehash[name] || [];\n                mainHandler = handlers[handlerKey];\n                if (!mainHandler) {\n                    eventHandler = function (e) {\n                        return dispatchEvent(this, e, capture, data);\n                    };\n                    handlers[handlerKey] = mainHandler = {\n                        fn: eventHandler,\n                        __delegateCount: 0,\n                        addQueue: [],\n                        removeQueue: [],\n                        currentEvent: null,\n                        capturing: capture\n                    };\n                    el.addEventListener(name, eventHandler, capture);\n                }\n                attach = _.find(namespaceCache, function (obj) {\n                    // remove any duplicates\n                    if (fn === obj.fn && obj.namespace === namespace && selector === obj.selector) {\n                        return true;\n                    }\n                });\n                if (!attach) {\n                    addEventQueue({\n                        fn: fn,\n                        persist: BOOLEAN_TRUE,\n                        disabled: BOOLEAN_FALSE,\n                        list: namespaceCache,\n                        namespace: namespace,\n                        mainHandler: mainHandler,\n                        selector: selector,\n                        name: name,\n                        passedName: passedName\n                    });\n                }\n            }));\n        },\n        addEventQueue = function (obj) {\n            var mainHandler = obj.mainHandler,\n                selector = obj.selector;\n            if (!mainHandler.currentEvent) {\n                if (selector) {\n                    obj.list.splice(mainHandler[__delegateCountString]++, 0, obj);\n                } else {\n                    obj.list.push(obj);\n                }\n            } else {\n                mainHandler[addQueueString].push(obj);\n            }\n        },\n        removeEventQueue = function (obj, idx) {\n            var gah, mainHandler = obj.mainHandler,\n                list = obj.list,\n                selector = obj.selector;\n            if (!mainHandler.currentEvent) {\n                if (!obj.isDestroyed) {\n                    obj.isDestroyed = true;\n                    idx = idx === void 0 ? list.indexOf(obj) : idx;\n                    if (idx + 1) {\n                        if (selector) {\n                            mainHandler[__delegateCountString]--;\n                        }\n                        gah = list.splice(idx, 1);\n                    }\n                    obj.list = null;\n                }\n            } else {\n                if (obj.persist) {\n                    mainHandler[removeQueueString].push(obj);\n                }\n            }\n            obj.persist = BOOLEAN_FALSE;\n        },\n        ensureHandlers = function (fn) {\n            return function (name) {\n                // var args = toArray(arguments);\n                var args = ['', blank, []],\n                    origArgs = _.filter(arguments, negate(isBlank)),\n                    argLen = origArgs.length;\n                if (!isObject(name)) {\n                    if (argLen === 1) {\n                        args = [name, blank, [blank]];\n                    }\n                    if (argLen === 2) {\n                        args = [name, blank, arguments[1]];\n                    }\n                }\n                if (argLen === 3) {\n                    args = arguments;\n                }\n                fn.apply(this, args);\n            };\n        },\n        removeEventListener = ensureHandlers(expandEventListenerArguments(function (name, namespace, selector, handler, capture) {\n            this.duff(function (idx, el) {\n                _removeEventListener(el, name, namespace, selector, handler, capture);\n            });\n        })),\n        removeEvent = function (obj) {\n            var mainHandler = obj.mainHandler;\n            if (obj.selector) {\n                mainHandler[__delegateCountString] = Math.max(mainHandler[__delegateCountString] - 1, 0);\n            }\n            _.remove(obj.list, obj);\n        },\n        _removeEventListener = function (el, name, namespace, selector, handler, capture) {\n            var objs, vent, current, data = elementData.get(el),\n                // currentStack = data[currentEventStackString],\n                events = data.events,\n                removeFromList = function (list, name) {\n                    duffRev(list, function (obj) {\n                        if ((!name || name === obj.name) && (!handler || obj.fn === handler) && (!namespace || obj.namespace === namespace) && (!selector || obj.selector === selector)) {\n                            removeEventQueue(obj);\n                        }\n                    });\n                };\n            if (events) {\n                objs = events[capture];\n                if (name) {\n                    // scan a select list\n                    removeFromList(objs[name], name);\n                } else {\n                    // scan all of the lists\n                    each(objs, removeFromList);\n                }\n            }\n        },\n        /**\n         * @class DOMM\n         * @augments Model\n         * @augments Collection\n         */\n        coll = _.Collection,\n        Collection = _.factories.Collection,\n        fixHooks = {\n            // Includes some event props shared by KeyEvent and MouseEvent\n            props: gapSplit(\"data altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\"),\n            fixedHooks: {},\n            keyHooks: {\n                props: gapSplit(\"char charCode key keyCode\"),\n                filter: function (evnt, original) {\n                    var charCode;\n                    // Add which for key evnts\n                    if (isBlank(evnt.which)) {\n                        charCode = original.charCode;\n                        evnt.which = !isBlank(charCode) ? charCode : original.keyCode;\n                    }\n                    return evnt;\n                }\n            },\n            forceHooks: {\n                props: [],\n                filter: function (evnt, original) {\n                    evnt.value = (original.webkitForce / 3) || original;\n                    return evnt;\n                }\n            },\n            mouseHooks: {\n                props: gapSplit(\"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\"),\n                filter: function (evnt, original) {\n                    var eventDoc, doc, body,\n                        button = original.button;\n                    // Calculate pageX/Y if missing and clientX/Y available\n                    if (isBlank(evnt.pageX) && !isBlank(original.clientX)) {\n                        evntDoc = evnt.target.ownerDocument || sizzleDoc;\n                        doc = evntDoc.documentElement;\n                        body = evntDoc.body;\n                        evnt.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n                        evnt.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n                    }\n                    evnt.movementX = original.movementX || 0;\n                    evnt.movementY = original.movementY || 0;\n                    evnt.layerX = original.layerX || 0;\n                    evnt.layerY = original.layerY || 0;\n                    evnt.x = original.x || 0;\n                    evnt.y = original.y || 0;\n                    // Add which for click: 1 === left; 2 === middle; 3 === right\n                    // Note: button is not normalized, so don't use it\n                    if (!evnt.which && button !== undefined) {\n                        evnt.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));\n                    }\n                    return evnt;\n                }\n            },\n            make: function (evnt) {\n                var doc, target, val, originalEvent = evnt.originalEvent,\n                    // Create a writable copy of the event object and normalize some properties\n                    i, prop, copy,\n                    type = originalEvent.type,\n                    fixHook = fixHooks.fixedHooks[type];\n                if (!fixHook) {\n                    fixHooks.fixedHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : rforceEvent.test(type) ? this.forceHooks : {};\n                }\n                copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;\n                i = copy.length;\n                while (i--) {\n                    prop = copy[i];\n                    val = originalEvent[prop];\n                    if (!isBlank(val)) {\n                        evnt[prop] = val;\n                    }\n                }\n                evnt.originalType = originalEvent.type;\n                // Support: Cordova 2.5 (WebKit) (#13255)\n                // All events should have a target; Cordova deviceready doesn't\n                // ie also does not have a target... so use current target\n                target = evnt.target || (evnt.view ? evnt.view.event.currentTarget : event.currentTarget);\n                if (!target) {\n                    target = evnt.target = sizzleDoc;\n                }\n                // Support: Safari 6.0+, Chrome<28\n                // Target should not be a text node (#504, #13143)\n                if (target.nodeType === 3) {\n                    evnt.target = target.parentNode;\n                }\n                if (isFunction(fixHook.filter)) {\n                    fixHook.filter(evnt, originalEvent);\n                }\n                evnt.type = distilledEventName[originalEvent.type] || originalEvent.type;\n                evnt.data = originalEvent.data || '';\n                evnt.isImmediatePropagationStopped = evnt.isPropagationStopped = evnt.isDefaultPrevented = BOOLEAN_FALSE;\n                // special\n                if (evnt.type === 'fullscreenchange') {\n                    doc = evnt.target;\n                    if (isWin(doc)) {\n                        doc = doc.document;\n                    } else {\n                        while (doc && !isDoc(doc) && doc.parentNode) {\n                            doc = doc.parentNode;\n                        }\n                    }\n                    evnt.fullscreenDocument = doc;\n                    if (isDoc(doc)) {\n                        evnt.isFullScreen = (doc.fullScreen || doc.webkitFullscreenElement || doc.mozFullScreenElement || doc.fullscreenElement) ? true : false;\n                    }\n                }\n                return evnt;\n            }\n        },\n        Event = _.extendFrom.Model('Event', {\n            constructor: function (evnt, el) {\n                var e = this;\n                e.originalEvent = evnt;\n                fixHooks.make(e);\n                evnt.delegateTarget = el;\n                return e;\n            },\n            preventDefault: function () {\n                var e = this.originalEvent;\n                this.isDefaultPrevented = BOOLEAN_TRUE;\n                if (e && e.preventDefault) {\n                    e.preventDefault();\n                }\n            },\n            stopPropagation: function () {\n                var e = this.originalEvent;\n                this.isPropagationStopped = BOOLEAN_TRUE;\n                if (e && e.stopPropagation) {\n                    e.stopPropagation();\n                }\n            },\n            stopImmediatePropagation: function () {\n                var e = this.originalEvent;\n                this.isImmediatePropagationStopped = BOOLEAN_TRUE;\n                if (e && e.stopImmediatePropagation) {\n                    e.stopImmediatePropagation();\n                }\n                this.stopPropagation();\n            }\n        }, BOOLEAN_TRUE),\n        createDomFilter = function (items, filtr) {\n            var filter;\n            if (isFunction(filtr)) {\n                filter = filtr;\n            } else {\n                if (isObject(filtr)) {\n                    if (isDom(filtr)) {\n                        filter = function (el) {\n                            return !!_.posit(items, el);\n                        };\n                    } else {\n                        filter = _.matches(filtr);\n                    }\n                } else {\n                    if (isString(filtr)) {\n                        filter = filterExpressions[filtr];\n                        if (!filter) {\n                            filter = function (item) {\n                                return matches(item, filtr);\n                            };\n                        }\n                    } else {\n                        if (isNumber(filtr)) {\n                            filter = function (el, idx) {\n                                return idx === filtr;\n                            };\n                        }\n                    }\n                }\n            }\n            return filter;\n        },\n        domFilter = function (items, filtr) {\n            var filter = createDomFilter(items, filtr);\n            return _.filter(items, filter);\n        },\n        dimFinder = function (element, doc, win) {\n            return function (num) {\n                var ret, el = this.get(num);\n                if (isDom(el)) {\n                    ret = clientRect(el)[element];\n                } else {\n                    if (isDoc(el) && el.body) {\n                        ret = el.body[doc];\n                    } else {\n                        if (isWin(el)) {\n                            ret = el[win];\n                        }\n                    }\n                }\n                return ret || 0;\n            };\n        },\n        dommFind = attachPrevious(function (str) {\n            var dom = this,\n                matchers = [],\n                passedString = isString(str);\n            duff(dom.un(), function (el) {\n                if (passedString) {\n                    duff(_.Sizzle(str, el), function (el) {\n                        matchers.push(el);\n                    });\n                } else {\n                    matchers.push(el);\n                }\n            });\n            return matchers;\n        }),\n        canBeProcessed = function (item) {\n            return isDom(item) || isWin(item) || isDoc(item) || isFrag(item);\n        },\n        DOMM = factories.DOMM = _.extendFrom.Collection('DOMM', extend({\n            /**\n             * @func\n             * @name DOMM#constructor\n             * @param {String|Node|Function} str - string to query the dom with, or a function to run on document load, or an element to wrap in a DOMM instance\n             * @returns {DOMM} instance\n             */\n            constructor: function (str, ctx) {\n                var i, els, elsLen, $doc, docEl, docData, dom = this;\n                if (isFunction(str)) {\n                    if (_.isDoc(ctx)) {\n                        $doc = $(ctx);\n                        docEl = $doc.get();\n                        docData = elementData.get(docEl);\n                        if (docData.isReady) {\n                            // make it async\n                            setTimeout(function () {\n                                str.apply($doc, [$, docData.DOMContentLoadedEvent]);\n                            });\n                            els = dom.un();\n                        } else {\n                            dom = $doc.on('DOMContentLoaded', function (e) {\n                                _.unshift(args, $);\n                                str.apply(this, args);\n                            });\n                            els = dom.un();\n                        }\n                    }\n                } else {\n                    if (isString(str)) {\n                        if (str[0] === '<') {\n                            els = makeTree(str);\n                        } else {\n                            els = _.Sizzle(str, ctx);\n                        }\n                    } else {\n                        els = str;\n                        if (canBeProcessed(els)) {\n                            els = [els];\n                        }\n                    }\n                }\n                Collection.call(dom, els);\n                return dom;\n            },\n            /**\n             * @func\n             * @name DOMM#isWin\n             * @description asks if the first or specified index of the object is a window type object\n             * @returns {Boolean}\n             */\n            isWin: function (num) {\n                return isWin(this.index(num || 0) || {});\n            },\n            isDom: function (num) {\n                return isDom(this.index(num || 0) || {});\n            },\n            /**\n             * @func\n             * @name DOMM#isDoc\n             * @description asks if the first or specified index of the object is a document type object\n             * @returns {Boolean}\n             */\n            isDoc: function (num) {\n                return isDoc(this.index(num || 0) || {});\n            },\n            isFrag: function (num) {\n                return isFrag(this.index(num || 0) || {});\n            },\n            frag: function (el) {\n                return _.frag(el || this[itemsString]);\n            },\n            /**\n             * @func\n             * @name DOMM#filter\n             * @param {String|Function|Object} filtr - filter variable that will filter by matching the object that is passed in, or by selector if it is a string, or simply with a custom function\n             * @returns {DOMM} new DOMM instance object\n             */\n            filter: attachPrevious(function (filter) {\n                return domFilter(this.un(), filter);\n            }),\n            /**\n             * @func\n             * @name DOMM#find\n             * @param {String} str - string to use sizzle to find against\n             * @returns {DOMM} matching elements\n             */\n            find: dommFind,\n            $: dommFind,\n            /**\n             * @func\n             * @name DOMM#children\n             * @param {Number} [eq] - index of the children to gather. If none is provided, then all children will be added\n             * @returns {DOMM} all / matching children\n             */\n            children: attachPrevious(function (eq) {\n                var dom = this,\n                    items = dom.un(),\n                    filter = createDomFilter(items, eq);\n                return foldl(items, function (memo, el) {\n                    return foldl(el.children || el.childNodes, function (memo, child, idx, children) {\n                        if (!filter || filter(child, idx, children)) {\n                            memo.push(child);\n                        }\n                        return memo;\n                    }, memo);\n                }, []);\n            }),\n            /**\n             * @func\n             * @name DOMM#offAll\n             * @returns {DOMM} instance\n             */\n            offAll: function () {\n                return this.duff(function (el) {\n                    var data = elementData.get(el);\n                    each(data.handlers, function (key, fn, eH) {\n                        var wasCapt, split = key.split(':');\n                        eH[key] = blank;\n                        wasCapt = data.events[split[0]];\n                        if (wasCapt) {\n                            wasCapt[split[1]] = [];\n                        }\n                    });\n                    elementData.remove(el);\n                });\n            },\n            /**\n             * @name DOMM#off\n             * @param {String|Function} type - event type\n             * @param {Function} handler - specific event handler to be removed\n             * @returns {DOMM} instnace\n             */\n            on: addEventListener,\n            off: removeEventListener,\n            addEventListener: addEventListener,\n            removeEventListener: removeEventListener,\n            dispatchEvent: expandEventListenerArguments(eachProc(dispatchEvent)),\n            /**\n             * @func\n             * @name DOMM#once\n             * @param {String} space delimited list of event names to attach handlers to\n             * @param {Function} fn - handler to put on the event loop\n             * @returns {DOMM} instance\n             */\n            once: expandEventListenerArguments(eachProc(function (el, types, namespace, selector, fn, capture) {\n                var args = toArray(arguments);\n                args[4] = _.once(function () {\n                    _removeEventListener.apply(null, args);\n                    return fn.apply(this, arguments);\n                });\n                _addEventListener.apply(null, args);\n            })),\n            /**\n             * @func\n             * @name DOMM#css\n             * @param {...*} splat of objects and key value pairs that create a single object to be applied to the element\n             * @returns {DOMM} instance\n             */\n            css: function (key, value) {\n                var dom = this,\n                    ret = css(dom[itemsString], key, value);\n                if (isBlank(ret)) {\n                    ret = dom;\n                }\n                return ret;\n            },\n            style: ensureOne(function (key, value) {\n                style(this.un(), key, value);\n                return this;\n            }),\n            /**\n             * @func\n             * @name DOMM#allDom\n             * @returns {Boolean} value indicating whether or not there were any non dom elements found in the collection\n             */\n            allDom: function () {\n                var count = 0,\n                    length = this.length(),\n                    result = length && find(this.un(), negate(isDom));\n                return length && result === void 0;\n            },\n            /**\n             * @func\n             * @name DOMM#height\n             * @returns {Number} height of the first object, adjusting for the different types of possible objects such as dom element, document or window\n             */\n            height: dimFinder('height', 'scrollHeight', 'innerHeight'),\n            /**\n             * @func\n             * @name DOMM#width\n             * @returns {Number} width of the first object, adjusting for the different types of possible objects such as dom element, document or window\n             */\n            width: dimFinder('width', 'scrollWidth', 'innerWidth'),\n            /**\n             * @func\n             * @name DOMM#getStyle\n             * @retuns {Object} the get computed result or a blank object if first or defined index is not a dom element and therefore cannot have a style associated with it\n             */\n            getStyle: function (eq) {\n                var ret = {},\n                    first = this.get();\n                if (first && isDom(first)) {\n                    ret = getComputed(first);\n                }\n                return ret;\n            },\n            /**\n             * @func\n             * @name DOMM#data\n             * @param {...*} splat of objects and key value pairs that create a single object to be applied to the element\n             * @returns {Object|*} can return the value that is asked for by the initial function call\n             */\n            data: domAttrManipulator(function (el, _key, val, data, dom) {\n                var value, dataStr = 'data-',\n                    sliced = _key.slice(0, 5),\n                    key = _key;\n                if (dataStr !== sliced) {\n                    key = dataStr + _key;\n                }\n                key = unCamelCase(key);\n                value = attributeInterface(el, key, val);\n                if (value !== blank) {\n                    data.dataset[_key] = value;\n                }\n                return value;\n            }, BOOLEAN_TRUE),\n            /**\n             * @func\n             * @name DOMM#attr\n             * @param {...*} splat of objects and key value pairs that create a single object to be applied to the element\n             * @returns {DOMM|*} if multiple attributes were requested then a plain hash is returned, otherwise the DOMM instance is returned\n             */\n            attr: domAttrManipulator(function (el, _key, val, data, dom) {\n                return attributeInterface(el, unCamelCase(_key), val);\n            }),\n            prop: domAttrManipulator(function (el, key, val, data, dom) {\n                var value;\n                if (isBlank(val)) {\n                    value = el[key];\n                    if (isBlank(value)) {\n                        value = null;\n                    }\n                } else {\n                    if (isBlank(val)) {\n                        val = blank;\n                    }\n                    el[key] = val;\n                }\n                return value;\n            }),\n            /**\n             * @func\n             * @name DOMM#eq\n             * @param {Number|Array} [num=0] - index or list of indexes to create a new DOMM element with.\n             * @returns {DOMM} instance\n             */\n            eq: attachPrevious(function (num) {\n                return eq(this.un(), num);\n            }),\n            /**\n             * @func\n             * @name DOMM#first\n             * @returns {DOMM} instance\n             */\n            first: attachPrevious(function () {\n                return eq(this.un(), 0);\n            }),\n            /**\n             * @func\n             * @name DOMM#last\n             * @returns {DOMM} instance\n             */\n            last: attachPrevious(function () {\n                return eq(this.un(), this.length() - 1);\n            }),\n            /**\n             * @func\n             * @name DOMM#clientRect\n             * @param {Number} [num=0] - item who's bounding client rect will be assessed and extended\n             * @returns {Object} hash of dimensional properties (getBoundingClientRect)\n             */\n            clientRect: function (num) {\n                return clientRect(eq(this.un(), num)[0]);\n            },\n            /**\n             * @func\n             * @name DOMM#each\n             * @param {Function} callback - iterator to apply to each item on the list\n             * @param {Boolean} elOnly - switches the first argument from a DOMM wrapped object to the Node itself\n             * @returns {DOMM} instance\n             */\n            each: function (callback) {\n                var domm = this;\n                if (domm.length()) {\n                    callback = _.bind(callback, domm);\n                    duff(domm[itemsString], function (item_, index, all) {\n                        var item = $([item_]);\n                        callback(item, index, all);\n                    });\n                }\n                return domm;\n            },\n            /**\n             * @func\n             * @name DOMM#addClass\n             * @param {String|Array} add - space delimited string that separates classes to be added through the change class function\n             * @returns {DOMM} instance\n             */\n            addClass: eachProc(function (el, add) {\n                changeClass(el, 0, add);\n            }),\n            /**\n             * @func\n             * @name DOMM#removeClass\n             * @param {String|Array} remove - space delimited string that separates classes to be removed through the change class function\n             * @returns {DOMM} instance\n             */\n            removeClass: eachProc(function (el, remove) {\n                changeClass(el, remove);\n            }),\n            /**\n             * @func\n             * @name DOMM#toggleClass\n             * @params {String|Array} list - space delimited string that separates classes to be removed and added through the change class function\n             * @returns {DOMM} instance\n             */\n            toggleClass: eachProc(function (el, list) {\n                var add = [],\n                    remove = [];\n                duff(gapSplit(list), function (item) {\n                    if (containsClass(el, item)) {\n                        remove.push(item);\n                    } else {\n                        add.push(item);\n                    }\n                });\n                changeClass(el, remove, add);\n            }),\n            /**\n             * @func\n             * @name DOMM#hasClass\n             * @param {String|Array} list - space delimited string that each element is checked againsts to ensure that it has the classs\n             * @returns {Boolean} do all of the elements in the collection have all of the classes listed\n             */\n            hasClass: function (clas) {\n                var dom = this,\n                    retVals = [],\n                    countLen = [],\n                    classes = gapSplit(clas);\n                dom.duff(function (el) {\n                    countLen.push(1);\n                    if (containsClass(el, clas)) {\n                        retVals.push(1);\n                    }\n                });\n                return (dom.length() && countLen[LENGTH_STRING] === retVals[LENGTH_STRING]);\n            },\n            /**\n             * @func\n             * @name DOMM#changeClass\n             * @param {String|Array} [remove] - removes space delimited list or array of classes\n             * @param {String|Array} [add] - adds space delimited list or array of classes\n             * @returns {DOMM} instance\n             */\n            changeClass: eachProc(changeClass),\n            booleanClass: eachProc(function (el, add, remove) {\n                if (add) {\n                    add = remove;\n                    remove = [];\n                }\n                changeClass(el, remove, add);\n            }),\n            /**\n             * @func\n             * @name DOMM#box\n             * @param {Number} [num=0] - index to get the boxmodel of\n             */\n            box: function (num) {\n                return box(this.get(num));\n            },\n            /**\n             * @func\n             * @name DOMM#end\n             * @returns {DOMM} object that started the traversal chain\n             */\n            end: function () {\n                var that = this;\n                while (that._previous) {\n                    that = that._previous;\n                }\n                return that;\n            },\n            /**\n             * @func\n             * @name DOMM#hide\n             * @description sets all elements to display\n             * @returns {DOMM} instance\n             */\n            hide: eachProc(ensureDOM(function (el) {\n                el.style.display = 'none';\n            })),\n            /**\n             * @func\n             * @name DOMM#show\n             */\n            show: eachProc(ensureDOM(function (el) {\n                el.style.display = 'block';\n            })),\n            /**\n             * @func\n             * @name DOMM#append\n             */\n            append: function (el) {\n                var dom = this,\n                    frag = _.frag(el);\n                dom.duff(function (el) {\n                    el.appendChild(frag);\n                });\n                return dom;\n            },\n            /**\n             * @func\n             * @name DOMM#next\n             * @returns {DOMM} instance\n             */\n            next: horizontalTraverser(1),\n            /**\n             * @func\n             * @name DOMM#previous\n             * @returns {DOMM} instance\n             */\n            prev: horizontalTraverser(-1),\n            /**\n             * @func\n             * @name DOMM#skip\n             * @returns {DOMM} instance\n             */\n            skip: horizontalTraverser(0),\n            /**\n             * @func\n             * @name DOMM#insertAt\n             * @returns {DOMM} instance\n             */\n            insertAt: function (els, idx) {\n                var point, dom = this,\n                    frag = _.frag(els),\n                    children = dom.children();\n                if (!idx && !isNumber(idx)) {\n                    point = {};\n                }\n                if (isNumber(idx)) {\n                    point = children.eq(idx);\n                }\n                if (isString(idx)) {\n                    point = dom.children().filter(idx);\n                }\n                if (isInstance(point, DOMM)) {\n                    point = point.get(0);\n                }\n                if (!_.isDom(point)) {\n                    point = null;\n                }\n                dom.duff(function (el) {\n                    el.insertBefore(frag, point);\n                });\n                return dom;\n            },\n            /**\n             * @func\n             * @name DOMM#remove\n             * @returns {DOMM} instance\n             */\n            remove: eachProc(function (el) {\n                var parent = el.parentNode;\n                if (isObject(parent) && isFunction(parent.removeChild)) {\n                    parent.removeChild(el);\n                }\n            }),\n            /**\n             * @func\n             * @name DOMM#parent\n             * @param {Number} [count=1] - number of elements to go up in the parent chain\n             * @returns {DOMM} instance of collected, unique parents\n             */\n            parent: (function () {\n                var finder = function (collect, fn, original) {\n                        return function (el) {\n                            var rets, found, parent = el,\n                                next = original;\n                            while (parent && !found) {\n                                rets = fn(parent.parentNode || parent.defaultView, original, next);\n                                parent = rets[0];\n                                found = rets[1];\n                                next = rets[2];\n                            }\n                            if (parent) {\n                                collect.push(parent);\n                            }\n                        };\n                    },\n                    number = function (parent, original, next) {\n                        next -= 1;\n                        if (next < 0 || !isFinite(next) || isNaN(next)) {\n                            next = 0;\n                        }\n                        return [parent, !next, next];\n                    },\n                    string = function (parent, original, next) {\n                        return [parent, matches(parent, original)];\n                    },\n                    speshal = {\n                        document: function (parent, original, next) {\n                            return [parent, isDoc(parent)];\n                        },\n                        window: function (parent, original, next) {\n                            return [parent, isWin(parent)];\n                        },\n                        iframe: function (parent, original, next) {\n                            var win, found = 1;\n                            if (isWin(parent) && parent !== window.top) {\n                                if (parent.location.protocol.indexOf('http') === -1) {\n                                    win = parent;\n                                    found = 1;\n                                    try {\n                                        parent = win.frameElement;\n                                        if (parent) {\n                                            found = 0;\n                                        }\n                                    } catch (e) {\n                                        found = 1;\n                                    }\n                                }\n                            }\n                            return [parent, (!found && parent)];\n                        }\n                    };\n                return attachPrevious(function (original) {\n                    var iterator, doDefault = 1,\n                        collect = coll();\n                    if (isNumber(original)) {\n                        iterator = number;\n                    } else {\n                        if (isString(original)) {\n                            if (speshal[original]) {\n                                iterator = speshal[original];\n                            } else {\n                                iterator = string;\n                            }\n                        } else {\n                            if (original) {\n                                doDefault = 0;\n                            }\n                        }\n                    }\n                    if (doDefault) {\n                        if (!iterator) {\n                            iterator = number;\n                            original = 1;\n                        }\n                        this.duff(finder(collect, iterator, original));\n                    } else {\n                        this.duff(finder(collect, function (el) {\n                            return [el, original(el)];\n                        }));\n                    }\n                    return collect[itemsString];\n                });\n            }()),\n            /**\n             * @func\n             * @name DOMM#has\n             * @param {Node|Array} els - list of elements to check the current instance against\n             * @returns {Boolean} whether or not the current domm element has all of the elements that were passed in\n             */\n            has: function (els) {\n                var has = 0,\n                    domm = this,\n                    list = domm[itemsString];\n                if (_.isInstance(els, Collection)) {\n                    els = els.un();\n                } else {\n                    if (isDom(els)) {\n                        els = [els];\n                    }\n                }\n                if (els[LENGTH_STRING]) {\n                    has = els[LENGTH_STRING];\n                }\n                find(els, function (el) {\n                    if (domm.posit(el)) {\n                        has--;\n                    }\n                });\n                return has === 0 && els && els[LENGTH_STRING];\n            },\n            /**\n             * @func\n             * @name DOMM#indexOf\n             * @param {Node|Array} el - element to check against the collection\n             * @returns {Number} index of the element\n             */\n            indexOf: function (el, lookAfter) {\n                if (isInstance(el, DOMM)) {\n                    el = el.get();\n                }\n                return indexOf(this[itemsString], el, lookAfter);\n            },\n            /**\n             * @func\n             * @name DOMM#html\n             * @returns {DOMM} instance\n             */\n            html: htmlTextManipulator('innerHTML'),\n            /**\n             * @func\n             * @name DOMM#text\n             * @returns {DOMM} instance\n             */\n            text: htmlTextManipulator('innerText'),\n            /**\n             * @func\n             * @name DOMM#contentRect\n             * @returns {Object} dimensions of the content rectangle\n             */\n            contentRect: function (num) {\n                var box = this.box(num),\n                    pB = box.paddingBottom,\n                    pT = box.paddingTop,\n                    pR = box.paddingRight,\n                    pL = box.paddingLeft,\n                    bT = box.borderTop,\n                    bB = box.borderBottom,\n                    bR = box.borderRight,\n                    bL = box.borderLeft;\n                return {\n                    bottom: box.bottom - pB - bB,\n                    height: box.height - pT - bT - pB - bB,\n                    right: box.right - pR - bR,\n                    width: box.width - pL - bL - pR - bR,\n                    left: box.left + pL - bL,\n                    top: box.top + pT - bT\n                };\n            },\n            /**\n             * @func\n             * @name DOMM#flowRect\n             * @returns {Object} dimensions of the flow rectangle: the amount of space the element should take up in the dom\n             */\n            flowRect: function () {\n                var box = this.box(0),\n                    mT = box.marginTop,\n                    mL = box.marginLeft,\n                    mB = box.marginBottom,\n                    mR = box.marginRight;\n                return {\n                    height: box.height + mT + mB,\n                    bottom: box.bottom + mB,\n                    width: box.width + mR + mL,\n                    right: box.right + mR,\n                    left: box.left + mL,\n                    top: box.top + mT\n                };\n            },\n            /**\n             * @func\n             * @name DOMM#stopEvent\n             */\n            stopEvent: function (e, now) {\n                e = _.Event(e);\n                e.stopPropagation();\n                e.preventDefault();\n                if (!isBlank(e.cancelBubble)) {\n                    e.cancelBubble = BOOLEAN_TRUE;\n                }\n                if (!isBlank(e.cancel)) {\n                    e.cancel = BOOLEAN_TRUE;\n                }\n                if (now) {\n                    e.stopImmediatePropagation();\n                }\n            },\n            /**\n             * @func\n             * @name DOMM#childOf\n             */\n            childOf: function (oParent) {\n                var domm = this,\n                    _oParent = $(oParent),\n                    children = domm.un();\n                oParent = _oParent.un();\n                return !!domm.length() && !!_oParent.length() && !find(oParent, function (_parent) {\n                    return find(children, function (child) {\n                        var parent = child,\n                            finding = BOOLEAN_TRUE;\n                        while (parent && finding) {\n                            if (_parent === parent) {\n                                finding = BOOLEAN_FALSE;\n                            }\n                            parent = parent.parentNode;\n                        }\n                        return finding;\n                    });\n                });\n            },\n            serialize: function () {\n                var domm = this,\n                    arr = [];\n                domm.each(function (idx, $node) {\n                    var node = $node.get(),\n                        children = $node.children().serialize(),\n                        obj = {\n                            tag: node.localName\n                        };\n                    if (children.length) {\n                        obj.children = children;\n                    }\n                    if (node.innerText) {\n                        obj.innerText = node.innerText;\n                    }\n                    duff(node.attributes, function (idx, attr) {\n                        obj[camelCase(attr.localName)] = attr.nodeValue;\n                    });\n                    arr.push(obj);\n                });\n                return arr;\n            },\n            stringify: function () {\n                return JSON.stringify(this.serialize());\n            }\n        }, _.wrap({\n            id: 0,\n            src: 0,\n            checked: 0,\n            disabled: 0,\n            tag: 'localName',\n            classes: 'className'\n        }, function (attr, api) {\n            if (!attr) {\n                attr = api;\n            }\n            return function (str) {\n                var item, setter = {};\n                if (isString(str)) {\n                    setter[attr] = str;\n                    return this.attr(setter);\n                }\n                item = this.get(str);\n                if (item) {\n                    return item[attr];\n                }\n            };\n        }), _.wrap({\n            play: 'playing',\n            pause: 'paused'\n        }, triggerEventWrapper), _.wrap(gapSplit('blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu'), function (attr) {\n            return triggerEventWrapper(attr);\n        })), BOOLEAN_TRUE),\n        $ = _DOMM(sizzleDoc);\n    app.addModuleArgs([$]);\n    _.exports({\n        covers: covers,\n        center: center,\n        closer: closer,\n        distance: distance,\n        css: css,\n        box: box,\n        frag: frag,\n        isDom: isDom,\n        isWin: isWin,\n        isDoc: isDoc,\n        isFrag: isFrag,\n        device: deviceCheck,\n        makeEl: makeEl,\n        makeEls: makeEls,\n        createDocFrag: createDocFrag,\n        hasWebP: hasWebP,\n        makeTree: makeTree,\n        numToUnits: numToUnits,\n        unitsToNumConverters: unitsToNumConverters,\n        numToUnitsConverters: numToUnitsConverters,\n        position: position,\n        unitsToNum: unitsToNum,\n        buildStyles: buildStyles,\n        changeClass: changeClass,\n        unitRemoval: unitRemoval,\n        getStyleSize: getStyleSize,\n        htmlDataMatch: htmlDataMatch,\n        toStyleString: toStyleString,\n        trustedEvents: trustedEvents,\n        makeEmptyFrame: makeEmptyFrame,\n        isTrustedEvent: isTrustedEvent,\n        devicePxRatio: devicePixelRatio,\n        setAttribute: setAttribute,\n        getAttribute: getAttribute,\n        attributeInterface: attributeInterface,\n        attributeRegExpMaker: function (attr, regex) {\n            var stringified = regex.toString(),\n                converted = stringified.slice(1, stringified[LENGTH_STRING] - 1).replace(new RegExp('{{{}}}'), attr);\n            return new RegExp(converted, 'mgi');\n        },\n        Sizzle: function (str, ctx) {\n            return (ctx || sizzleDoc).querySelectorAll(str);\n        },\n        stashAttrs: function (el, extras) {\n            var data = _.stashedAttrs(el);\n            duff(gapSplit('id class maxWidth width minWidth maxHeight height minHeight style').concat(gapSplit(extras) || []), function (idx, attr) {\n                if (!_.has(data.backup, attr)) {\n                    data.stashedCount++;\n                }\n                data.backup[attr] = _.attributeInterface(el, unCamelCase(attr));\n            });\n        },\n        stashedAttrs: function (el) {\n            var obj = {},\n                data = elementData.get(el);\n            if (!data.backup) {\n                data.backup = {};\n            }\n            if (!data.stashedCount) {\n                data.stashedCount = 0;\n            }\n            return data;\n        },\n        resetAttrs: function (el) {\n            var data = elementData.get(el);\n            each(data.backup, function (key, val) {\n                _.attributeInterface(el, unCamelCase(key), val);\n            });\n        },\n        elementData: elementData,\n        eventLists: {\n            Event: Event,\n            SVGEvent: SVGEvent,\n            KeyboardEvent: KeyboardEvent,\n            GamePadEvent: GamePadEvent,\n            CompositionEvent: CompositionEvent,\n            MouseEvents: MouseEvents,\n            TouchEvents: TouchEvents,\n            DeviceEvents: DeviceEvents,\n            FocusEvent: FocusEvent,\n            TimeEvent: TimeEvent,\n            AnimationEvent: AnimationEvent,\n            AudioProcessingEvent: AudioProcessingEvent,\n            UIEvents: UIEvents,\n            ProgressEvent: ProgressEvent,\n            AllEvents: AllEvents\n        }\n    });\n});","application.scope().module('Element', function (module, app, _, $) {\n    var factories = _.factories,\n        each = _.each,\n        duff = _.duff,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        isUnitlessNumber = {\n            columnCount: BOOLEAN_TRUE,\n            columns: BOOLEAN_TRUE,\n            fontWeight: BOOLEAN_TRUE,\n            lineHeight: BOOLEAN_TRUE,\n            opacity: BOOLEAN_TRUE,\n            zIndex: BOOLEAN_TRUE,\n            zoom: BOOLEAN_TRUE,\n            animationIterationCount: BOOLEAN_TRUE,\n            boxFlex: BOOLEAN_TRUE,\n            boxFlexGroup: BOOLEAN_TRUE,\n            boxOrdinalGroup: BOOLEAN_TRUE,\n            flex: BOOLEAN_TRUE,\n            flexGrow: BOOLEAN_TRUE,\n            flexPositive: BOOLEAN_TRUE,\n            flexShrink: BOOLEAN_TRUE,\n            flexNegative: BOOLEAN_TRUE,\n            flexOrder: BOOLEAN_TRUE,\n            lineClamp: BOOLEAN_TRUE,\n            order: BOOLEAN_TRUE,\n            orphans: BOOLEAN_TRUE,\n            tabSize: BOOLEAN_TRUE,\n            widows: BOOLEAN_TRUE,\n            // SVG-related properties\n            fillOpacity: BOOLEAN_TRUE,\n            stopOpacity: BOOLEAN_TRUE,\n            strokeDashoffset: BOOLEAN_TRUE,\n            strokeOpacity: BOOLEAN_TRUE,\n            strokeWidth: BOOLEAN_TRUE\n        },\n        timeBasedCss = {\n            transitionDuration: BOOLEAN_TRUE,\n            animationDuration: BOOLEAN_TRUE,\n            transitionDelay: BOOLEAN_TRUE,\n            animationDelay: BOOLEAN_TRUE\n        },\n\n        /**\n        * Support style names that may come passed in prefixed by adding permutations\n        * of vendor prefixes.\n        */\n        prefixes = ['Webkit', 'ms', 'Moz', 'O'],\n\n\n        /**\n        * Most style properties can be unset by doing .style[prop] = '' but IE8\n        * doesn't like doing that with shorthand properties so for the properties that\n        * IE8 breaks on, which are listed here, we instead unset each of the\n        * individual properties. See http://bugs.jquery.com/ticket/12385.\n        * The 4-value 'clock' properties like margin, padding, border-width seem to\n        * behave without any problems. Curiously, list-style works too without any\n        * special prodding.\n        */\n        shorthandPropertyExpansions = {\n            background: {\n                backgroundAttachment: BOOLEAN_TRUE,\n                backgroundColor: BOOLEAN_TRUE,\n                backgroundImage: BOOLEAN_TRUE,\n                backgroundPositionX: BOOLEAN_TRUE,\n                backgroundPositionY: BOOLEAN_TRUE,\n                backgroundRepeat: BOOLEAN_TRUE\n            },\n            backgroundPosition: {\n                backgroundPositionX: BOOLEAN_TRUE,\n                backgroundPositionY: BOOLEAN_TRUE\n            },\n            border: {\n                borderWidth: BOOLEAN_TRUE,\n                borderStyle: BOOLEAN_TRUE,\n                borderColor: BOOLEAN_TRUE\n            },\n            borderBottom: {\n                borderBottomWidth: BOOLEAN_TRUE,\n                borderBottomStyle: BOOLEAN_TRUE,\n                borderBottomColor: BOOLEAN_TRUE\n            },\n            borderLeft: {\n                borderLeftWidth: BOOLEAN_TRUE,\n                borderLeftStyle: BOOLEAN_TRUE,\n                borderLeftColor: BOOLEAN_TRUE\n            },\n            borderRight: {\n                borderRightWidth: BOOLEAN_TRUE,\n                borderRightStyle: BOOLEAN_TRUE,\n                borderRightColor: BOOLEAN_TRUE\n            },\n            borderTop: {\n                borderTopWidth: BOOLEAN_TRUE,\n                borderTopStyle: BOOLEAN_TRUE,\n                borderTopColor: BOOLEAN_TRUE\n            },\n            font: {\n                fontStyle: BOOLEAN_TRUE,\n                fontVariant: BOOLEAN_TRUE,\n                fontWeight: BOOLEAN_TRUE,\n                fontSize: BOOLEAN_TRUE,\n                lineHeight: BOOLEAN_TRUE,\n                fontFamily: BOOLEAN_TRUE\n            },\n            outline: {\n            outlineWidth: BOOLEAN_TRUE,\n            outlineStyle: BOOLEAN_TRUE,\n            outlineColor: BOOLEAN_TRUE\n            }\n        },\n\n        CSSProperty = {\n            isUnitlessNumber: isUnitlessNumber,\n            shorthandPropertyExpansions: shorthandPropertyExpansions\n        },\n        convertStyleType = function (key, value) {\n            if (value === +value) {\n                if (timeBasedCss[n]) {\n                    value += 'ms';\n                }\n                if (!isUnitlessNumber[n]) {\n                    value += 'px';\n                }\n            }\n            return value;\n        },\n        isNode = function (object) {\n          return !!(object && (_.isFunction(Node) ? _.isInstance(object, Node) : _.isObject(object) && _.isNumber(object.nodeType) && _.isString(object.nodeName)));\n        },\n        isWin = function (obj) {\n            return obj && obj === obj.window;\n        },\n        /**\n         * @private\n         * @func\n         */\n        isDoc = function (obj) {\n            return obj && isNumber(obj.nodeType) && obj.nodeType === obj.DOCUMENT_NODE;\n        },\n        isFrag = function (frag) {\n            return frag && frag.nodeType === sizzleDoc.DOCUMENT_FRAGMENT_NODE;\n        },\n        styles = function (el, css_) {\n            _.each(css_, function (key_, value) {\n                var key = _.camelCase(key_);\n                el.style[key] = convertStyleType(key, value);\n            });\n        },\n        Element = factories.Element = _.extendFrom.Model('Element', {\n            constructor: function (el, skip) {\n                var element = this;\n                element._el = el;\n                element._validated = !skip;\n                element.validate();\n                element.apply();\n                return element;\n            },\n            apply: function () {\n                var element = this;\n                _.each(element._queue, function (key, value) {});\n                element._queue = {};\n                return element;\n            },\n            validate: function () {\n                var element = this;\n                var el = element._el;\n                element._isNode = isNode(el);\n                element._isDoc = element._isNode ? BOOLEAN_FALSE : isDoc(el);\n                element._isWin = element._isNode || element._isDoc ? BOOLEAN_FALSE : isWin(el);\n                element._isFrag = element._isNode || element._isDoc || element._isWin ? BOOLEAN_FALSE : isFrag(el);\n                element._isValid =  element._isWin || element._isNode || element._isDoc || element._isFrag;\n            },\n            valid: function (type, preventRevalidation) {\n                var element = this;\n                if (!element._validated && !preventRevalidation) {\n                    element.validate();\n                }\n                return this['_is' + type];\n            },\n            style: function (css) {\n                var element = this;\n                if (element.valid('DOM')) {\n                    styles(element._el, css);\n                }\n                return element;\n            }\n        }, BOOLEAN_TRUE);\n        /**\n         * @param {string} prefix vendor-specific prefix, eg: Webkit\n         * @param {string} key style name, eg: transitionDuration\n         * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n         * WebkitTransitionDuration\n         */\n        function prefixKey(prefix, key) {\n          return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n        }\n        // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n        // infinite loop, because it iterates over the newly added props too.\n        each(isUnitlessNumber, function (truth, prop) {\n            duff(prefixes, function (prefix) {\n                isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n            });\n        });\n});","application.scope().module('View', function (module, app, _, $) {\n    var blank, each = _.each,\n        isFn = _.isFn,\n        duff = _.duff,\n        factories = _.factories,\n        Box = factories.Box,\n        extendFrom = _.extendFrom,\n        isString = _.isString,\n        gapSplit = _.gapSplit,\n        isArray = _.isArray,\n        bind = _.bind,\n        has = _.has,\n        protoProp = _.protoProp,\n        lengthString = 'length',\n        optionsString = 'options',\n        templates = {},\n        compile = function (id, force) {\n            var matches, tag, template, attrs, templateFn = templates[id];\n            if (!templateFn || force) {\n                tag = $(id);\n                template = tag.html();\n                matches = template.match(/\\{\\{([\\w\\s\\d]*)\\}\\}/mgi);\n                attrs = _.map(matches, function (match) {\n                    return {\n                        match: match,\n                        attr: match.split('{{').join('').split('}}').join('').trim()\n                    };\n                });\n                template = template.trim();\n                templateFn = templates[id] = function (obj) {\n                    var str = template,\n                        clone = _.clone(obj);\n                    duff(attrs, function (idx, match) {\n                        if (!clone[match.attr]) {\n                            clone[match.attr] = '';\n                        }\n                        str = str.replace(match.match, clone[match.attr]);\n                    });\n                    return str;\n                };\n            }\n            return templateFn;\n        },\n        scrapeData = function (model, el, attributes) {\n            var val, value, str = model.dataScrape;\n            if (str) {\n                value = el.data(str);\n                if (isString(value)) {\n                    val = {};\n                    val[_.camelCase(str)] = value;\n                    value = val;\n                }\n                _.extend(attributes, value);\n            }\n        },\n        ensureUIObj = function (fn) {\n            return function () {\n                var ui, view = this,\n                    viewEl = view.el;\n                if (!_.has(view, 'ui')) {\n                    ui = view.ui || {};\n                    view.ui = {};\n                    each(ui, function (domm, key) {\n                        view.ui[key] = $();\n                        viewEl.find(domm).duff(function (el) {\n                            view.attachUIElement(key, el);\n                        });\n                    });\n                }\n                return fn.apply(view, arguments);\n            };\n        },\n        makeDelegateEventKey = function (view, name) {\n            return name + '.delegateEvents' + view.cid;\n        },\n        makeDelegateEventKeys = function (view, key, namespace) {\n            if (namespace) {\n                namespace = '.' + namespace;\n            } else {\n                namespace = '';\n            }\n            var viewNamespace = 'delegateEvents' + view.cid;\n            return _.map(gapSplit(key), function (_key) {\n                var __key = _key.split('.');\n                if (__key[1] !== viewNamespace) {\n                    __key.splice(1, 0, viewNamespace);\n                    _key = __key.join('.');\n                }\n                return _key += namespace;\n            }).join(' ');\n        },\n        normalizeUIString = function(uiString, ui) {\n            return uiString.replace(/@ui\\.[a-zA-Z_$0-9]*/g, function (r) {\n                return ui[r.slice(4)];\n            });\n        },\n        // allows for the use of the @ui. syntax within\n        // a given key for triggers and events\n        // swaps the @ui with the associated selector.\n        // Returns a new, non-mutated, parsed events hash.\n        normalizeUIKeys = function(hash, ui) {\n            return _.reduce(hash, function (memo, val, key) {\n                var normalizedKey = Marionette.normalizeUIString(key, ui);\n                memo[normalizedKey] = val;\n                return memo;\n            }, {});\n        },\n        viewGetRegion = function (key) {\n            var region, view = this,\n                regionManager = view.regionManager;\n            if (regionManager) {\n                region = regionManager.get(key);\n            }\n            return region;\n        },\n        /**\n         * @class View\n         * @augments Model\n         * @augments Box\n         * @classDesc Objects that have one or more element associated with them, such as a template that needs constant updating from the data\n         */\n        // region views are useful if you're constructing different components\n        // from a separate place and just want it to be in the attach pipeline\n        // very useful for componentizing your ui\n        viewplucks = ['el', 'regionViews'],\n        pluckviews = function (from, to, props) {\n            duff(props, function (idx, prop) {\n                if (has(from, prop)) {\n                    to[prop] = from[prop];\n                    from[prop] = void 0;\n                }\n            });\n        },\n        View = extendFrom.Box('View', {\n            /**\n             * @func\n             * @name View#constructor\n             * @description constructor for new view object\n             * @param {Object|DOMM|Node} attributes - hash with non-circular data on it. Is set later with the Box constructor\n             * @param {Object} secondary - options such as defining the parent object, or the element if necessary\n             * @param {DOMM|Node} el - element or Node that is attached directly to the View object\n             * @returns {View} instance\n             */\n            tagName: 'div',\n            getRegion: viewGetRegion,\n            constructor: function (attributes, secondary) {\n                var model = this;\n                pluckviews(secondary, model, viewplucks);\n                model._ensureElement();\n                Box.apply(model, arguments);\n                return model;\n            },\n            childViewContainer: function () {\n                return this.el;\n            },\n            $: function (selector) {\n                return this.el.find(selector);\n            },\n            template: function (ctx) {\n                return '';\n            },\n            _renderHTML: function () {\n                var view = this,\n                    innerHtml = view.template(view.toJSON());\n                view.el.html(innerHtml);\n            },\n            _ensureRegionManager: function () {\n                var view = this;\n                // weak association\n                var regionManager = view.regionsManager = view.regionsManager || new RegionManager({}, {\n                    parent: view\n                });\n                return regionsManager;\n            },\n            _appendChildElements: function () {\n                var view = this,\n                    // scoped under view because it always has to be inside of view\n                    el = view.$(_.result(view, 'childViewContainer'));\n                // view.children.eachCall('render');\n                view.children.each(function (idx, child) {\n                    if (_.result(child, 'filter')) {\n                        child.render();\n                    }\n                });\n                if (view.parent && !view.parent.rendered()) {\n                    view._passBufferedViews();\n                }\n                // if any were rendered\n                el.append(view._bufferedEls);\n            },\n            _establishRegions: function () {\n                var regionsManager, view = this,\n                    regions = view._establishedRegions || _.result(view, 'regions');\n                if (regions) {\n                    view._establishedRegions = regions;\n                }\n                if (view._establishedRegions) {\n                    // hold off making the region manager as long as possible\n                    view._ensureRegionManager();\n                    // add regions to the region manager\n                    view.regionManager.establishRegions(regions);\n                }\n            },\n            render: function () {\n                var frag = _.createDocFrag(),\n                    view = this;\n                view.isRendered = !1;\n                view._ensureBufferedViews();\n                // detach this element so we don't cause more reflows than necessary\n                // view._detachElement();\n                // remove the child elements\n                // request extra data or something before rendering: is still intact\n                view.dispatchEvent('before:render');\n                // set render flat\n                view.isRendered = !1;\n                // unbinds and rebinds element only if it changes\n                view.setElement(view.el);\n                view._setElAttributes();\n                // renders the html\n                view._renderHTML();\n                // gathers the ui elements\n                view._bindUIElements();\n                // ties regions back to newly formed parent template\n                view._establishRegions();\n                // puts children back inside parent\n                view._appendChildElements();\n                view._attachBufferedViews();\n                view.isRendered = !0;\n                view.dispatchEvent('render');\n                return view;\n            },\n            filter: function () {\n                return true;\n            },\n            setElement: function (element) {\n                var view = this,\n                    previousElement = view.el;\n                // detaches events with this view's namespace\n                // view._unDelegateEvents();\n                view._setElement(element);\n                if (previousElement !== view.el) {\n                    view._unDelegateEvents(previousElement);\n                    view._delegateEvents();\n                }\n                // attaches events with this view's namespace\n                return view;\n            },\n            // Creates the `this.el` and `this.$el` references for this view using the\n            // given `el`. `el` can be a CSS selector or an HTML string, a jQuery\n            // context or an element. Subclasses can override this to utilize an\n            // alternative DOM manipulation API and are only required to set the\n            // `this.el` property.\n            _setElement: function (el) {\n                this.el = $(el);\n            },\n            _createElement: function (tag) {\n                return $('<' + tag + '>');\n            },\n            // Ensure that the View has a DOM element to render into.\n            // If `this.el` is a string, pass it through `$()`, take the first\n            // matching element, and re-assign it to `el`. Otherwise, create\n            // an element from the `id`, `className` and `tagName` properties.\n            _ensureElement: function () {\n                var el, view = this,\n                    _elementSelector = view._elementSelector || _.result(view, 'el');\n                if (_elementSelector) {\n                    view._elementSelector = _elementSelector;\n                }\n                if (!_.isInstance(_elementSelector, _.DOMM)) {\n                    if (_.isString(_elementSelector)) {\n                        // sets external element\n                        el = _elementSelector;\n                    } else {\n                        // defauts back to wrapping the element\n                        // creates internal element\n                        el = view._createElement(_.result(view, 'tagName'));\n                        // subclassed to expand the attributes that can be used\n                    }\n                    view.setElement(el);\n                }\n            },\n            _setElAttributes: function () {\n                var view = this;\n                var attrs = _.result(view, 'elementAttributes') || {};\n                if (view.className) {\n                    attrs['class'] = _.result(view, 'className');\n                }\n                view._setAttributes(attrs);\n            },\n            // Set attributes from a hash on this view's element.  Exposed for\n            // subclasses using an alternative DOM manipulation API.\n            _setAttributes: function (attributes) {\n                this.el.attr(attributes);\n            },\n            // pairs. Callbacks will be bound to the view, with `this` set properly.\n            // Uses event delegation for efficiency.\n            // Omitting the selector binds the event to `this.el`.\n            _delegateEvents: function (el, bindings_) {\n                var key, method, match,\n                    view = this,\n                    _elementEventBindings = view._elementEventBindings || view.elementEvents,\n                    bindings = bindings_ || _elementEventBindings,\n                    __events = {};\n                if (_elementEventBindings) {\n                    view._elementEventBindings = _elementEventBindings;\n                }\n                if (el) {\n                    each(bindings, function (key, methods_) {\n                        // assumes is array\n                        var methods = gapSplit(methods_);\n                        if (isFunction(methods_)) {\n                            methods = [methods_];\n                        }\n                        __events[makeDelegateEventKeys(view, key)] = _.map(methods, function (idx, method) {\n                            return _.bind(view[method] || method, view);\n                        });\n                    });\n                    el.on(__events);\n                }\n                return view;\n            },\n            _unDelegateEvents: function (el, bindings_) {\n                var key, method, match,\n                    view = this,\n                    _elementEventBindings = view._elementEventBindings || view.elementEvents,\n                    bindings = bindings_ || _elementEventBindings,\n                    __events = {};\n                if (_elementEventBindings) {\n                    view._elementEventBindings = _elementEventBindings;\n                }\n                if (el) {\n                    each(bindings, function (key, methods_) {\n                        // assumes is array\n                        var methods = gapSplit(methods_);\n                        if (isFunction(methods_)) {\n                            methods = [methods_];\n                        }\n                        __events[makeDelegateEventKeys(view, key)] = _.map(methods, function (idx, method) {\n                            return _.bind(view[method] || method, view);\n                        });\n                    });\n                    el.on(__events);\n                }\n                return view;\n            },\n            parentView: function () {\n                var found, view = this,\n                    parent = view.parent;\n                while (found && parent && !_.isInstance(parent, View)) {\n                    parent = parent.parent;\n                    if (_.isInstance(parent, View)) {\n                        found = parent;\n                    }\n                }\n                return found;\n            },\n            _bindUIElements: function () {\n                var view = this,\n                    _uiBindings = view._uiBindings || _.result(view, 'ui');\n                view.ui = view.ui || {};\n                if (_uiBindings) {\n                    // save it to skip the result call later\n                    view._uiBindings = _uiBindings;\n                    view.ui = _.hashMap(_uiBindings, function (key, selector) {\n                        return view.$(selector);\n                    });\n                }\n                return view;\n            },\n            _unBindUIElements: function () {\n                var view = this;\n                view.ui = view._uiBindings;\n            },\n            remove: function () {\n                var el, view = this;\n                Box.prototype.remove.apply(view, arguments);\n                // if you were not told to select something in\n                // _ensureElements then remove the view from the dom\n                view.detach();\n                return view;\n            },\n            _detachElement: function () {\n                var view = this,\n                    el = view.el && view.el.get(0);\n                if (el && el.parentNode) {\n                    el.parentNode.removeChild(el);\n                }\n            },\n            _ensureBufferedViews: function () {\n                var bufferedViews = isArray(this._bufferedViews) ? 1 : this._resetBufferedViews();\n                var _bufferedEls = _.isFrag(this._bufferedEls) ? 1 : this._resetBufferedEls();\n            },\n            _resetBuffered: function () {\n                this._resetBufferedEls();\n                this._resetBufferedViews();\n            },\n            _addBufferedView: function (view) {\n                var parent = this;\n                parent._bufferedEls.appendChild(view.el.get(0));\n                parent._bufferedViews.push(view);\n            },\n            _removeViewElement: function (el, frag) {\n                var parent = this;\n                if (frag) {\n                    frag.appendChild(el);\n                } else {\n                    if (el.parentNode) {\n                        el.parentNode.removeChild(el);\n                    }\n                }\n            },\n            _add: function (view) {\n                var parent = this;\n                Box.prototype._add.call(parent, view);\n                // ensure the element buffer\n                // append to the view list buffer\n                // attached buffered element here so we don't have to loop through the list later\n                parent._addBufferedView(view);\n            },\n            add: function (models_) {\n                var ret, _bufferedViews, view = this;\n                view._ensureBufferedViews();\n                ret = Box.prototype.add.call(view, _.isArrayLike(models_) ? models_ : [models_]);\n                _.duff(ret, function (view) {\n                    view._attemptAttach();\n                });\n                return ret;\n            },\n            _attemptAttach: function () {\n                var view = this,\n                    parent = view.parent;\n                if (view.attached() || parent && parent.attached()) {\n                    view.attach(view.parent);\n                }\n            },\n            _passBufferedViews: function () {\n                var child = this,\n                    parent = child.parent;\n                if (parent && child._bufferedViews) {\n                    parent._ensureBufferedViews();\n                    parent._bufferedEls.appendChild(child.el.get(0));\n                    parent._bufferedViews.push.apply(parent._bufferedViews, child._bufferedViews);\n                    child._resetBufferedViews();\n                }\n            },\n            _resetBufferedViews: function () {\n                this._bufferedViews = [];\n            },\n            _resetBufferedEls: function () {\n                this._bufferedEls = _.createDocFrag();\n            },\n            _attachBufferedChildren: function () {\n                var childView, idx = 0,\n                    view = this,\n                    el = view.$(_.result(view, 'childViewContainer'));\n                if (view._bufferedEls) {\n                    el.append(view._bufferedEls);\n                }\n                while (view._bufferedViews && view._bufferedViews[lengthString] && view._bufferedViews[idx]) {\n                    childView = view._bufferedViews[idx];\n                    idx++;\n                    // appends children to parent el\n                    childView.attach(childView.parent);\n                }\n                if (!view.attached()) {\n                    view._passBufferedViews();\n                }\n            },\n            _attachBufferedViews: function () {\n                var parent = this;\n                parent.el.append(parent._bufferedEls);\n                _.duff(parent._bufferedViews, function (idx, buffered) {\n                    buffered.isAttached = true;\n                    buffered.dispatchEvent('attach');\n                });\n            },\n            // _attachTrigger: function () {\n            //     var parent = this;\n            //     // only has to happen once\n            //     parent._attachBufferedViews();\n            //     parent._resetBuffered();\n            // },\n            attach: function (parent_) {\n                var view = this;\n                if (view.attached()) {\n                    if (parent_ && view.parent && parent_ !== view.parent) {\n                        view.detach();\n                        view.attach(parent_);\n                    }\n                    view._attachBufferedChildren();\n                } else {\n                    // resets the html\n                    // queue children for attachment\n                    view.dispatchEvent('before:attach');\n                    // render / attach children to self\n                    view._attachBufferedChildren();\n                    if (parent_.attached() && !view.attached()) {\n                        view.render();\n                        // parent_._attachTrigger();\n                        parent_._attachBufferedViews();\n                        parent_._resetBuffered();\n                    }\n                }\n            },\n            // _conditionallyDispachAttached: function () {\n            //     var view = this,\n            //         parent = view.parent;\n            //     if (!view.attached() && parent && parent.attached()) {\n            //         view.isAttached = true;\n            //         parent.el.append(view.el);\n            //         view.dispatchEvent('attach');\n            //     }\n            // },\n            detach: function () {\n                var view = this;\n                view.dispatchEvent('before:detach');\n                view._detachElement();\n            },\n            /**\n             * @func\n             * @name View#destroy\n             * @description removes dom elemenets as well as all elements on the ui\n             * @returns {View} instance\n             */\n            destroy: function (opts) {\n                var view = this;\n                view.isRendered = false;\n                // done here for redundancy when using iframes\n                view.detach();\n                // remove all events\n                // should internally call remove\n                Box.prototype.destroy.call(view);\n                return view;\n            },\n            rendered: function () {\n                return this.isRendered;\n            },\n            destroyed: function () {\n                return this.isDestroyed;\n            },\n            attached: function () {\n                return this.isAttached;\n            }\n        }, !0),\n        Region = factories.View.extend('Region', {\n            Model: View,\n            _delegateEvents: _.noop,\n            _unDelegateEvents: _.noop,\n            fill: function (newView) {\n                var region = this,\n                    currentView = region.currentView;\n                if (!newView) {\n                    return;\n                }\n                if (currentView !== newView) {\n                    region.empty();\n                    region.add(newView);\n                    region.currentView = newView;\n                    newView.attach(region);\n                }\n                return currentView;\n            },\n            empty: function () {\n                var region = this,\n                    currentView = region.currentView;\n                if (currentView) {\n                    currentView.detach();\n                }\n            }\n        }, true),\n        RegionManager = factories.Collection.extend('RegionManager', {\n            Model: Region,\n            createRegion: function (where, region_) {\n                var scope, regionManager = this,\n                    // assume that it is a region\n                    region = region_;\n                if (!(region instanceof regionManager.Model)){\n                    region = new regionManager.Model({\n                        id: where\n                    }, {\n                        el: regionManager._getElementFromDom(region)\n                    });\n                }\n                regionManager.add(region);\n                regionManager.register(region.get('id'), region);\n            },\n            _getElementFromDom: function (selector) {\n                var regionManager = this;\n                var $ = regionManager.getElementContext();\n                var $selected = $(selector);\n                return $selected;\n            },\n            removeRegion: function (region_) {\n                var regionManager = this;\n                var region = _.isString(region_) ? regionManager.get(region_) : region_;\n                regionManager.remove(region);\n                regionManager.unregister(region.get('id'), region);\n            },\n            _setElementContext: function ($) {\n                this.$ = $;\n            },\n            _resetElementContext: function () {\n                this.$ = void 0;\n            },\n            defaultContext: function () {\n                return $;\n            },\n            getElementContext: function () {\n                var regionManager = this;\n                var parent = regionManager.parent;\n                var _$ = _.has(regionManager, '$') ? regionManager.$ : $;\n                if (parent && parent.$ && !regionManager.$) {\n                    regionManager.$ = _.bind(parent.$, parent);\n                    _$ = regionManager.$;\n                }\n                return _$;\n            },\n            establishRegion: function (key, value) {\n                var regionManager = this;\n                var region = regionManager.get(key);\n                if (!region) {\n                    regionManager.createRegion(key, value);\n                }\n            },\n            establishRegions: function (regions) {\n                var regionManager = this;\n                var reversed = _.reverseParams(_.bind(regionManager.establishRegion, regionManager));\n                _.each(regions, reversed, regionManager);\n                return regionManager;\n            }\n        }, true);\n    _.exports({\n        htmlCompile: compile\n    });\n    app.regionManager = new RegionManager();\n    app.extend({\n        addRegion: function (where, selector) {\n            var app = this;\n            var regionManager = app.regionManager;\n            _.intendedObject(where, selector, function (key, value) {\n                var region;\n                regionManager.establishRegion(key, value);\n                region = regionManager.get(key);\n                region.isAttached = true;\n            });\n            return app;\n        },\n        getRegion: viewGetRegion,\n        addRegions: function (obj) {\n            var app = this;\n            app.addRegion(obj);\n            return app;\n        }\n    });\n});","application.scope().module('Buster', function (module, app, _, $) {\n    var blank, isReceiving = 0,\n        get = _.get,\n        duff = _.duff,\n        gapSplit = _.gapSplit,\n        associator = _.associator,\n        unitsToNum = _.unitsToNum,\n        roundFloat = _.roundFloat,\n        extend = _.extend,\n        factories = _.factories,\n        infin = 32767,\n        attributesString = 'attributes',\n        // 0 is first positive -1 is first non positive\n        nInfin = -infin - 1,\n        lengthString = 'length',\n        heightString = 'height',\n        widthString = 'width',\n        bottomString = 'bottom',\n        rightString = 'right',\n        leftString = 'left',\n        topString = 'top',\n        marginBottomString = 'marginBottom',\n        marginRightString = 'marginRight',\n        minHeightString = 'minHeight',\n        maxHeightString = 'maxHeight',\n        minWidthString = 'minWidth',\n        maxWidthString = 'minWidth',\n        queuedMessageIndexString = 'queuedMessageIndex',\n        pI = _.pI,\n        _setupInit = function (e) {\n            var i, currentCheck, src, parentEl, frameWin, frameEl, allFrames, tippyTop, spFacts, spOFacts, shouldRespond, sameSide, topDoc, wrapper, buster = this,\n                frame = e.frame,\n                data = e.data(),\n                packet = data.packet,\n                responder = e.responder,\n                attrs = get(buster),\n                parts = buster.parts;\n            if (app.topAccess) {\n                tippyTop = window[topString];\n                topDoc = tippyTop.document;\n                wrapper = topDoc.body;\n            }\n            if (!frame) {\n                if (!data.toInner) {\n                    /**\n                     * when the buster has to go through an unfriendly iframe, it has to find the iframe it belonged to from the top document\n                     * @private\n                     * @arg {string} url that is the iframe. also, secondarily checks the window objects in the while loop\n                     */\n                    buster.el = (function (specFrame) {\n                        var frame, frameWin, src, currentCheck, i,\n                            frames = topDoc.getElementsByTagName('iframe'),\n                            srcEl = e.srcElement;\n                        if (specFrame) {\n                            for (i in frames) {\n                                frame = frames[i];\n                                frameWin = frame.contentWindow;\n                                src = frame.src;\n                                if (src === specFrame) {\n                                    currentCheck = srcEl;\n                                    while (currentCheck !== tippyTop) {\n                                        if (frameWin === currentCheck) {\n                                            return frame;\n                                        }\n                                        currentCheck = currentCheck.parent;\n                                    }\n                                }\n                            }\n                        }\n                        return 0;\n                    }(attrs.srcOrigin));\n                }\n                if (data.toInner) {\n                    buster.el = document.body;\n                }\n                if (buster.el) {\n                    buster.el = $(buster.el);\n                    buster.set({\n                        sameSide: 0,\n                        id: data.from,\n                        referrer: _.getReference(parts.doc)\n                    });\n                    extend(parts, {\n                        srcElement: e.source,\n                        top: tippyTop || {},\n                        doc: topDoc || {},\n                        wrapper: wrapper || {}\n                    });\n                    shouldRespond = 1;\n                    attrs.isConnected = 1;\n                }\n            }\n            if (frame) {\n                buster.el = frame;\n                buster.responder = e.responder;\n                shouldRespond = 1;\n                buster.set({\n                    sameSide: 1,\n                    referrer: packet.referrer\n                });\n                extend(buster.parts, {\n                    srcElement: e.srcElement,\n                    wrapper: wrapper,\n                    top: tippyTop,\n                    doc: topDoc\n                });\n            }\n            if (shouldRespond) {\n                parentEl = buster.el.parent();\n                buster.respond(data, {\n                    parent: {\n                        height: parentEl[heightString](),\n                        width: parentEl[widthString](),\n                        style: {\n                            height: parentEl.get(0).style[heightString],\n                            width: parentEl.get(0).style[widthString]\n                        }\n                    }\n                });\n            }\n        },\n        /**\n         * single handler for all busters under same window makes it easy to remove from window when the time comes to unload\n         * @private\n         * @arg {event} event object passed in by browser\n         */\n        receive = function (evt) {\n            var buster, bustersCache, data = _.parse(evt.data),\n                postTo = data.postTo;\n            if (data && postTo && !app.isDestroying) {\n                bustersCache = associator.get(postTo);\n                if (bustersCache) {\n                    buster = bustersCache.buster;\n                    if (buster && buster.run) {\n                        buster.run(data, evt);\n                    }\n                }\n            }\n        },\n        /**\n         * single function to stringify and post message an object to the other side\n         * @private\n         * @arg {object} object to be stringified and sent to the receive function,\n         * either through a post message, or through a setTimeout\n         * @arg {buster}\n         */\n        postMessage = function (base, buster) {\n            var busterAttrs = buster[attributesString],\n                sameSide = busterAttrs.sameSide,\n                parts = buster.parts,\n                message = JSON.stringify(base),\n                timestamp = _.nowish(),\n                doReceive = function () {\n                    receive({\n                        data: message,\n                        frame: buster.el,\n                        responder: receive,\n                        srcElement: window,\n                        timestamp: timestamp\n                    });\n                };\n            if (!sameSide) {\n                if (busterAttrs.referrer) {\n                    parts.sendWin.postMessage(message, busterAttrs.referrer);\n                } else {\n                    window.console.trace('missing referrer', buster);\n                }\n            }\n            if (sameSide) {\n                doReceive();\n            }\n            return timestamp;\n        },\n        /**\n         * object for 4 different setup cases. probably belongs elsewhere\n         * @private\n         * @arg {buster}\n         */\n        setups = {\n            /**\n             * @private\n             */\n            toInner: function (buster) {\n                var attrs = buster[attributesString],\n                    parts = buster.parts;\n                parts.sendWin = buster.parent.el.get(0).contentWindow;\n                attrs.referrer = attrs.referrer || _.getReference(parts.doc);\n                attrs.sameSide = !buster.parent.parent.get('unfriendlyCreative');\n            },\n            /**\n             * @private\n             */\n            fromInner: function (buster) {\n                var attrs = buster[attributesString],\n                    parts = buster.parts;\n                parts.sendWin = parts.receiveWin.parent;\n                attrs.referrer = attrs.referrer || _.getReference(parts.doc);\n            },\n            notInner: {\n                /**\n                 * @private\n                 */\n                noAccess: function (buster) {\n                    var url, attrs = buster[attributesString],\n                        parts = buster.parts,\n                        doc = parts.doc,\n                        iframe = doc.createElement('iframe'),\n                        allMods = _.clone(app.allModules);\n                    allMods.push('initPublisherConfig');\n                    if (attrs.busterLocation) {\n                        iframe.style.display = 'none';\n                        url = attrs.referrer + attrs.busterLocation;\n                        iframe.src = _.stringifyQuery({\n                            url: attrs.referrer + attrs.busterLocation,\n                            query: {\n                                origin: doc.location.href,\n                                sessionId: attrs.sessionId,\n                                src: app.BASEURL + buster.get('scriptUrl') + app.addVersionNumber(allMods).join()\n                            }\n                        });\n                        parts.wrapper.appendChild(iframe);\n                        parts.sendWin = iframe.contentWindow;\n                        buster.el = $(iframe);\n                        _.Ajax(url).failure(function () {\n                            var time = 2000;\n                            if (_.isMobile) {\n                                time = 10000;\n                            }\n                            setTimeout(function () {\n                                // handle no buster file here\n                                var ret, ad = buster.parent,\n                                    adAttrs = ad[attributesString],\n                                    banner = ad.children.index(1),\n                                    panel = ad.children.index(2);\n                                if (!ad.busterLoaded) {\n                                    if (!banner) {\n                                        banner = panel;\n                                    }\n                                    ret = panel.destroy && panel.destroy();\n                                    buster.unSendAll();\n                                    buster.on('message:queued', buster.unSendAll);\n                                }\n                            }, time);\n                        });\n                    }\n                },\n                /**\n                 * @private\n                 */\n                topAccess: function (buster) {\n                    var commands, newParent = buster.el.get(0),\n                        attrs = buster[attributesString];\n                    // if preventselfinit is true, then that means that\n                    // this is being triggered by the buster file\n                    if (!attrs.preventSelfInit) {\n                        if (attrs.publisherConfig) {\n                            // // does need some special functions\n                            _.Ajax('http:' + app.SERVERURL + app.SCRIPTPATH + attrs.publisherConfig).success(function (responseText) {\n                                new Function.constructor('return ' + responseText)();\n                                buster.begin();\n                            });\n                        } else {\n                            // doesn't need any special functions\n                            buster.addCommand(factories.publisherConfig());\n                            buster.begin();\n                        }\n                    } else {\n                        buster.addCommand(factories.publisherConfig());\n                    }\n                }\n            }\n        },\n        containerSize = function (components) {\n            return components.foldr(function (memo, idx, com) {\n                var preventScrollCounter = 0,\n                    hPushCount = 0,\n                    vPushCount = 0,\n                    calced = com.calculatedSize,\n                    verticalPush = com.pushVertical,\n                    horizontalPush = com.pushHorizontal;\n                if (verticalPush !== '') {\n                    vPushCount++;\n                }\n                if (horizontalPush !== '') {\n                    hPushCount++;\n                }\n                if (com.isShowing && com.container === 'ad') {\n                    if (com.preventScroll) {\n                        preventScrollCounter = 1;\n                    }\n                    memo = {\n                        top: Math.min(memo[topString], calced[topString]),\n                        left: Math.min(memo[leftString], calced[leftString]),\n                        right: Math.max(memo[rightString], (calced[leftString] + calced[widthString])),\n                        bottom: Math.max(memo[bottomString], (calced[topString] + calced[heightString])),\n                        zIndex: Math.max(memo.zIndex, (+com.zIndex || 0)),\n                        marginRight: Math.max(memo[marginRightString], horizontalPush || 0),\n                        marginBottom: Math.max(memo[marginBottomString], verticalPush || 0),\n                        vPushCount: vPushCount + memo.vPushCount,\n                        hPushCount: hPushCount + memo.hPushCount,\n                        transitionDuration: Math.max(memo.transitionDuration, com.duration),\n                        preventScrollCount: memo.preventScrollCount + preventScrollCounter\n                    };\n                }\n                return memo;\n            }, {\n                top: infin,\n                left: infin,\n                right: nInfin,\n                bottom: nInfin,\n                marginBottom: 0,\n                marginRight: 0,\n                zIndex: 0,\n                vPushCount: 0,\n                hPushCount: 0,\n                transitionDuration: 0,\n                preventScrollCount: 0\n            });\n        };\n    if (app.topAccess) {\n        $(window[topString]).on('message', receive);\n    }\n    /**\n     * @class Buster\n     * @augments Model\n     * @augments Box\n     * @augments View\n     * @classDesc constructor for buster objects, which have the ability to talk across windows\n     */\n    var Message = _.extendFrom.Container('Message', {\n        // idAttribute: 'command',\n        packet: function (data) {\n            var ret = this;\n            if (arguments[0]) {\n                this.set({\n                    packet: data || {}\n                });\n            } else {\n                ret = _.parse(_.stringify(this.get('packet')));\n            }\n            return ret;\n        },\n        defaults: function () {\n            return {\n                command: 'null',\n                packet: {}\n            };\n        },\n        deferred: function (fn) {\n            this.on('deferred', fn);\n            return this;\n        },\n        respond: function (fn) {\n            var message = this,\n                buster = message.parent;\n            if (_.isFunction(fn)) {\n                message.once('respond', fn);\n            }\n            if (message.responseOptions) {\n                message.dispatchEvent('respond', message.responseOptions, buster.currentPoint());\n            }\n            return message;\n        }\n    });\n    factories.Buster = _.extendFrom.Box('Buster', {\n        Model: Message,\n        events: {\n            unload: 'destroy',\n            'alter:isConnected': function () {\n                this.set(queuedMessageIndexString, 1);\n            },\n            'alter:isConnected child:added': 'flush'\n        },\n        parentEvents: {\n            destroy: 'destroy'\n        },\n        /**\n         * @func\n         * @name Buster#destroy\n         */\n        currentPoint: function () {\n            var currentPoint = this.get('currentPoint') || {};\n            return {\n                source: currentPoint.source,\n                srcElement: currentPoint.srcElement,\n                originTimestamp: currentPoint.timestamp,\n                frame: currentPoint.frame,\n                responder: currentPoint.responder\n            };\n        },\n        destroy: function () {\n            var buster = this,\n                attrs = get(buster);\n            buster.set({\n                isConnected: !1\n            });\n            buster.resetElements();\n            clearTimeout(attrs.__lastMouseMovingTimeout__);\n            _.AF.remove(attrs.elQueryId);\n            _.AF.remove(attrs.componentTransitionAFID);\n            buster.allListeners.each(function (idx, obj) {\n                obj.els.off(obj.name, obj.fn, obj.capture);\n            });\n            buster.el.offAll();\n            buster.el.shift();\n            buster.parts = {};\n            associator.remove(buster.id);\n            factories.Box.prototype.destroy.apply(this, arguments);\n            return buster;\n        },\n        tellMouseMovement: function () {\n            if (this.get('mouseMoveDataObject')) {\n                this.respond(this.get('mouseMoveDataObject'));\n            }\n        },\n        reapplyCss: function (extend) {\n            var containerSize, hw = {},\n                buster = this,\n                attrs = get(buster);\n            if (attrs.frameAlwaysFillHeight) {\n                hw[heightString] = '100%';\n            }\n            if (attrs.frameAlwaysFillWidth) {\n                hw[widthString] = '100%';\n            }\n            hw = _.extend(buster.calculateContainerSize(), extend, hw);\n            buster.el.css(hw);\n            if (buster.get('applyImportant')) {\n                buster.applyImportantStyles(buster.el.get(0));\n            }\n            return buster;\n        },\n        applyImportantStyles: function (el) {\n            var panel = buster.components.get(2);\n            var hasDuration;\n            var style = (el.getAttribute('style') || '').split(' !important').join('').split('!important').join('').split('important').join('').split('!').join('').split(';');\n            el.setAttribute('style', _.foldl(style, function (memo, idx, val) {\n                var split;\n                if (val) {\n                    split = val.trim().split(': ');\n                    if (val && split[0] && split[1]) {\n                        memo.push(split[0].trim() + ': ' + split[1].trim() + ' !important;');\n                    }\n                }\n                return memo;\n            }, []).join(' '));\n        },\n        unSend: function (obj) {\n            var buster = this,\n                every = buster.get('every');\n            every.apply(buster, [obj, {},\n                buster.parent\n            ]);\n            if (obj.packet.onRespond) {\n                obj.packet.onRespond.apply(buster, [obj, {},\n                    buster.parent\n                ]);\n            }\n        },\n        unSendAll: function () {\n            var queued = this.get('queued');\n            while (queued[0]) {\n                this.unSend(queued.shift());\n            }\n        },\n        /**\n         * @func\n         * @name Buster#defaults\n         */\n        defaults: function () {\n            return {\n                currentState: 'collapse',\n                connectedUnder: [],\n                isConnected: 0,\n                sameSide: 0,\n                queuedMessageIndex: 0,\n                sent: []\n            };\n        },\n        // belongs on the outside\n        _stateCss: function (set0) {\n            var busterAttrs = get(this),\n                _sizing = busterAttrs._sizing,\n                margin = {\n                    transitionProperty: 'all'\n                };\n            if (_sizing) {\n                if (_sizing.vPushCount) {\n                    margin[marginBottomString] = busterAttrs.pushVerticalVal;\n                    margin.transitionDuration = _sizing.transitionDuration;\n                } else {\n                    if (set0) {\n                        margin[marginBottomString] = 0;\n                    } else {\n                        margin[marginBottomString] = 'auto';\n                    }\n                }\n                if (_sizing.hPushCount) {\n                    margin[marginRightString] = busterAttrs.pushHorizontalVal;\n                    margin.transitionDuration = _sizing.transitionDuration;\n                } else {\n                    if (set0) {\n                        margin[marginRightString] = 0;\n                    } else {\n                        margin[marginRightString] = 'auto';\n                    }\n                }\n            }\n            return margin;\n        },\n        /**\n         * initial setup for all busters\n         * @func\n         * @name Buster#initialize\n         */\n        initialize: function (opts, options) {\n            var receiveWin, registered, buster = this,\n                attrs = buster[attributesString];\n            buster.components = _.Collection();\n            buster.showing = _.Collection();\n            buster.on('before:responded', attrs.every);\n            buster.addCommand({\n                initialize: _setupInit,\n                begin: this.begin,\n                update: function (e) {\n                    this.respond(e.data());\n                },\n                unload: function () {\n                    this.destroy();\n                },\n                // belongs on the outside\n                updateAttributes: function (e) {\n                    var buster = this,\n                        data = e.data(),\n                        packet = data.packet;\n                    buster.set(packet.update);\n                    duff(packet.components, function (idx, com) {\n                        var component = buster.component(com.registeredAs);\n                        if (!component) {\n                            buster.components.add(com);\n                        } else {\n                            extend(component, com);\n                        }\n                    });\n                    buster.components.each(function (idx, com) {\n                        if (_.posit(packet.showing, com.registeredAs)) {\n                            com.isShowing = !0;\n                        } else {\n                            com.isShowing = !1;\n                        }\n                    });\n                    if (packet.shouldRespond) {\n                        buster.respond();\n                    }\n                }\n            });\n            buster.allListeners = _.Collection();\n            extend(attrs, {\n                frame: null\n            });\n            buster.el = $(buster.parts.frame);\n            registered = associator.get(attrs.id);\n            registered.buster = buster;\n            registered.postListener = receive;\n            receiveWin = $(buster.parts.receiveWin);\n            receiveWin.on('message', receive);\n            buster.allListeners.push({\n                els: receiveWin,\n                fn: receive,\n                name: 'message'\n            });\n            if (attrs.type === 'buster') {\n                if (!attrs.sameSide) {\n                    setups.notInner.noAccess(buster);\n                } else {\n                    setups.notInner.topAccess(buster);\n                }\n            }\n            // always assume the need to bust for these two\n            if (attrs.type !== 'buster') {\n                if (attrs.toInner) {\n                    setups.toInner(buster);\n                }\n                if (attrs.fromInner) {\n                    setups.fromInner(buster);\n                }\n            }\n            return buster;\n        },\n        component: function (registeredAs) {\n            return this.components.find(function (com, idx) {\n                return com.registeredAs === registeredAs || idx === registeredAs;\n            });\n        },\n        // this belongs on the outside\n        /**\n         * quick get parser to figure out if the wrapper, the frame element, it's parent, the document, or an other item is being selected by a post message\n         * @arg {string} target selector\n         * @returns {DOMM} with targets\n         * @func\n         * @name Buster#getTargets\n         */\n        getTargets: function (target) {\n            var buster = this,\n                attrs = buster[attributesString],\n                parts = buster.parts,\n                top = parts.top,\n                targets = [],\n                wrapper = parts.wrapper;\n            if (!target) {\n                targets = [top];\n            }\n            if (target === 'wrapper') {\n                targets = [wrapper];\n            }\n            if (target === 'self') {\n                targets = buster.el;\n            }\n            if (target === 'document') {\n                targets = [parts.doc];\n            }\n            if (target === 'parent') {\n                targets = buster.el.parent();\n            }\n            if (!targets[lengthString]) {\n                targets = parts.doc.querySelectorAll(target);\n            }\n            return $(targets);\n        },\n        /**\n         * tries to flush the cache. only works if the isConnected attribute is set to true. If it is, then the post message pipeline begins\n         * @returns {buster} returns this;\n         * @func\n         * @name Buster#flush\n         */\n        flush: function () {\n            var n, item, gah, childrenLen, queuedMsg, nuData, i = 0,\n                buster = this,\n                currentIdx = buster.get(queuedMessageIndexString),\n                connected = buster.get('isConnected'),\n                initedFrom = buster.get('initedFromPartner'),\n                flushing = buster.get('flushing');\n            if (!initedFrom || connected && ((connected || !currentIdx) && !flushing)) {\n                buster.set({\n                    flushing: !0\n                });\n                childrenLen = buster.children.length();\n                queuedMsg = buster.children.index(currentIdx);\n                while (queuedMsg && currentIdx < childrenLen) {\n                    queuedMsg.set({\n                        runCount: 0\n                    });\n                    postMessage(queuedMsg, buster);\n                    if (currentIdx) {\n                        currentIdx = (buster.get(queuedMessageIndexString) + 1) || 0;\n                        buster.set(queuedMessageIndexString, currentIdx);\n                        queuedMsg = buster.children.index(currentIdx);\n                    } else {\n                        childrenLen = false;\n                    }\n                }\n                buster.set({\n                    flushing: !1\n                });\n                if (buster.get('isConnected')) {\n                    if (buster.children.length() > buster.get(queuedMessageIndexString)) {\n                        buster.flush();\n                    }\n                }\n            }\n            return buster;\n        },\n        /**\n         * basic send message function, adds to queue, then calls flush\n         * @arg {string} can be string or object. if object, must have command property as string\n         * @arg {object} base object to be sent\n         * @returns {buster}\n         * @func\n         * @name Buster#send\n         */\n        send: function (command, packet, extra) {\n            var message, buster = this,\n                defaultObj = buster.defaultMessage();\n            message = buster.add(_.extend({\n                command: command,\n                packet: packet\n            }, defaultObj, extra));\n            return buster.children.index(defaultObj.index);\n        },\n        /**\n         * shorthand for creating a function that gets called after the buster's partner has responded\n         * @func\n         * @name Buster#sync\n         */\n        sync: function (fn) {\n            return this.send('update').respond(fn);\n        },\n        /**\n         * if a buster is found on the receive function, by the data's postTo property, then the run method is called\n         * @arg {object} the parsed data object\n         * @arg {event} the event object that wrapped the stringified data object\n         * @returns {buster}\n         * @func\n         * @name Buster#run\n         */\n        run: function (data, currentPoint_) {\n            var packet, format, retVal, messageJSON, responded, onResponse, originalMessage, responseType, methodName, buster = this,\n                attrs = buster[attributesString],\n                currentPoint = attrs.currentPoint = currentPoint_,\n                event = currentPoint,\n                messages = attrs.sent,\n                runCount = data.runCount,\n                children = buster.children,\n                eventname = 'respond',\n                args = _.toArray(arguments);\n            if (runCount) {\n                originalMessage = children.index(data.index);\n                if (originalMessage) {\n                    // messageJSON = originalMessage.toJSON();\n                    // found the message that i originally sent you\n                    // packet = originalMessage.packet;\n                    // allow the buster to set some things up\n                    buster.dispatchEvent('before:responded', data, buster.currentPoint());\n                    if (runCount === 1) {\n                        // stash it for later\n                        originalMessage.responseOptions = data;\n                    } else {\n                        eventname = 'deferred';\n                    }\n                    originalMessage.dispatchEvent(eventname, data, buster.currentPoint());\n                }\n            } else {\n                buster.dispatchEvent('receive:' + data.command, data, buster.currentPoint());\n                buster.dispatchEvent('receive', data, buster.currentPoint());\n            }\n            return buster;\n        },\n        /**\n         * skip the queue, and simply send a message\n         * @arg {object} message object to be sent\n         * @arg {object} optional object that is the original object. Usually only applicable when passed in through the send function, so that the response event can have all of the correct information\n         * @returns {buster}\n         * @func\n         * @name Buster#sendMessage\n         */\n        // sendMessage: function (message) {\n        //     var buster = this;\n        //     // set again to make sure that it has all the right info\n        //     // message.set(buster.defaultMessage());\n        //     postMessage(_.fullClone(message), buster);\n        //     return buster;\n        // },\n        /**\n         * creates a default message based on the attributes of the buster\n         * @returns {object} blank / default message object\n         * @func\n         * @name Buster#defaultMessage\n         */\n        defaultMessage: function () {\n            var attrs = get(this);\n            return {\n                from: attrs.id,\n                postTo: attrs.postTo,\n                sameSide: attrs.sameSide,\n                fromInner: attrs.fromInner,\n                toInner: attrs.toInner,\n                // runCount: 0,\n                index: this.children.length(),\n                preventResponse: false\n            };\n        },\n        /**\n         * @func\n         * @name Buster#shouldUpdate\n         */\n        shouldUpdate: function (args) {\n            var ret, buster = this,\n                attrs = _.get(buster),\n                lastUpdate = attrs.lastRespondUpdate,\n                lastFrameRect = attrs.lastFrameRect,\n                top = buster.parts.top || {},\n                width = top.innerWidth,\n                height = top.innerHeight,\n                nowish = _.nowish();\n            if (lastUpdate > nowish - 1000 && _.isObject(lastFrameRect)) {\n                ret = !(lastFrameRect[bottomString] < -height * 0.5 || lastFrameRect.top > height * 1.5 || lastFrameRect[rightString] < -width * 0.5 || lastFrameRect[leftString] > width * 1.5);\n            } else {\n                ret = 1;\n            }\n            clearTimeout(attrs.lastUpdateThrottledId);\n            if (!ret) {\n                attrs.lastUpdateThrottledId = setTimeout(function () {\n                    buster.respond.apply(buster, args);\n                }, -(nowish - lastUpdate - 1000));\n            }\n            return !buster.startThrottle || ret;\n        },\n        /**\n         * respond trigger.\n         * @arg {object} original data object (same pointer) that was sent over\n         * @arg {object} extend object, that will be applied to a base object, that is created by the responseExtend attribute set on the buster object\n         * @returns {buster}\n         * @func\n         * @name Buster#respond\n         */\n        respond: function (data, extendObj) {\n            var lastRespondUpdate, message, buster = this,\n                attrs = buster[attributesString],\n                sameSide = attrs.sameSide,\n                base = {};\n            if (!extendObj || !_.isObject(extendObj)) {\n                extendObj = {};\n            }\n            if (buster.el && (!data.canThrottle || buster.shouldUpdate(arguments))) {\n                // on the inner functions, we don't want to allow this\n                // module to be present, so the inner does not influence the outer\n                if (attrs.responseExtend) {\n                    base = attrs.responseExtend(buster, data);\n                }\n                ++data.runCount;\n                base = {\n                    from: data.postTo,\n                    postTo: data.from,\n                    index: data.index,\n                    isResponse: 1,\n                    isDeferred: data.isDeferred,\n                    runCount: data.runCount,\n                    command: data.command,\n                    packet: extend(base, extendObj)\n                };\n                // used for throttling\n                attrs.lastRespondUpdate = postMessage(base, buster);\n                buster.dispatchEvent('respond:' + data.command, buster, buster.currentPoint());\n                if (data.isDeferred) {\n                    buster.dispatchEvent('deferred:' + data.command, buster, buster.currentPoint());\n                }\n                data.isDeferred = 1;\n            }\n            return buster;\n        },\n        /**\n         * @returns {object} client rect duplicate of element\n         * @func\n         * @name Buster#getFrameRect\n         */\n        getFrameRect: function () {\n            var clientRect = this[attributesString].lastFrameRect = this.el.clientRect();\n            return clientRect;\n        },\n        /**\n         * @returns {object} client rect duplicate of parent element\n         * @func\n         * @name Buster#getParentRect\n         */\n        getParentRect: function () {\n            var parentRect = this[attributesString].lastParentRect = this.el.parent().clientRect();\n            return parentRect;\n        },\n        updateTopData: function () {\n            var buster = this,\n                attrs = get(buster),\n                parts = buster.parts,\n                topWin = parts.top || {},\n                location = topWin.location || {\n                    hash: '',\n                    pathname: '',\n                    protocol: '',\n                    search: ''\n                },\n                topData = attrs.topData = {\n                    location: {\n                        hash: location.hash.slice(1),\n                        host: location.host,\n                        href: location.href,\n                        origin: location.origin,\n                        pathname: location.pathname.slice(1),\n                        port: location.port,\n                        protocol: location.protocol.slice(0, location.protocol.length - 1),\n                        search: location.search.slice(1)\n                    },\n                    innerHeight: topWin.innerHeight || 0,\n                    outerHeight: topWin.outerHeight || 0,\n                    innerWidth: topWin.innerWidth || 0,\n                    outerWidth: topWin.outerWidth || 0,\n                    scrollX: topWin.scrollX || 0,\n                    scrollY: topWin.scrollY || 0\n                };\n            return topData;\n        },\n        /**\n         * gets the wrapper info, such as scroll height, id, and the classname\n         * @returns {object} key value pairs of all of the data that defines the wrapper\n         * @func\n         * @name Buster#wrapperInfo\n         */\n        wrapperInfo: function () {\n            var info, buster = this,\n                parts = buster.parts,\n                el = parts.wrapper || {},\n                doc = parts.doc || {\n                    body: {}\n                },\n                root = doc.body.parentNode,\n                getBoundingClientRect = {},\n                attrs = get(buster);\n            if (el.tagName) {\n                getBoundingClientRect = $(el).clientRect();\n            }\n            info = attrs.wrapperInfo = {\n                readyState: (doc.readyState === 'complete'),\n                scrollHeight: el.scrollHeight,\n                scrollWidth: el.scrollWidth,\n                scrollLeft: el.scrollLeft,\n                scrollTop: el.scrollTop,\n                className: el.className,\n                pageTitle: doc.title,\n                id: el.id,\n                height: pI(getBoundingClientRect.height),\n                bottom: pI(getBoundingClientRect.bottom),\n                width: pI(getBoundingClientRect.width),\n                right: pI(getBoundingClientRect.right),\n                left: pI(getBoundingClientRect.left),\n                top: pI(getBoundingClientRect.top)\n            };\n            return info;\n        },\n        /**\n         * @returns {object} position in document as calculated by the buster attributes\n         * @func\n         * @name Buster#positionInDocument\n         */\n        positionInDocument: function () {\n            var attrs = this[attributesString],\n                wrapperInfo = attrs.wrapperInfo,\n                contentRect = attrs.lastParentRect,\n                pos = attrs.lastPosInDoc = {\n                    top: pI(contentRect[topString] - wrapperInfo[topString]),\n                    bottom: pI(wrapperInfo[heightString] - contentRect[topString] - wrapperInfo.scrollTop - contentRect[heightString]),\n                    left: pI(contentRect[leftString] - wrapperInfo[leftString]),\n                    right: pI(wrapperInfo[widthString] - contentRect[rightString] - wrapperInfo.scrollLeft - wrapperInfo[leftString])\n                };\n            return pos;\n        },\n        calculateSizes: function () {\n            var buster = this,\n                attrs = get(buster),\n                parentStyle = attrs.lastParentStyle = buster.el.parent().getStyle(),\n                comSizes = attrs.componentSizes = buster.components.map(function (idx, com) {\n                    return buster.calculateSize(com);\n                });\n            return comSizes;\n        },\n        showComponents: function (showList) {\n            var buster = this;\n            duff(gapSplit(showList), function (id) {\n                var com = buster.component(id);\n                if (com) {\n                    com.isShowing = !0;\n                }\n            });\n        },\n        hideComponents: function (hideList) {\n            var buster = this;\n            duff(gapSplit(hideList), function (id) {\n                var com = buster.component(id);\n                if (com) {\n                    com.isShowing = !1;\n                }\n            });\n        },\n        calculateContainerSize: function (components) {\n            var buster = this,\n                attrs = get(buster),\n                parentRect = attrs.lastParentRect,\n                sizing = containerSize(components || buster.components);\n            attrs._sizing = sizing;\n            attrs.containerSize = {\n                top: sizing[topString],\n                left: sizing[leftString],\n                width: sizing[rightString] - sizing[leftString],\n                height: sizing[bottomString] - sizing[topString]\n            };\n            attrs.pushVerticalVal = Math.min(Math.max(sizing[bottomString] - parentRect[bottomString], 0), sizing[marginBottomString]);\n            attrs.pushHorizontalVal = Math.min(Math.max(sizing[rightString] - parentRect[rightString], 0), sizing[marginRightString]);\n            sizing = attrs.containerCss = {\n                top: sizing[topString] - parentRect[topString],\n                left: sizing[leftString] - parentRect[leftString],\n                width: sizing[rightString] - sizing[leftString],\n                height: sizing[bottomString] - sizing[topString],\n                zIndex: sizing.zIndex || 'inherit'\n            };\n            return sizing;\n        },\n        calculateSize: function (component) {\n            var buster = this,\n                attrs = get(buster),\n                expansion = factories.expansion[component.dimensionType || 'match'],\n                parentRect = attrs.lastParentRect,\n                parentStyle = attrs.lastParentStyle,\n                result = (expansion || factories.expansion.match).call(buster, component, parentRect, parentStyle, buster.parts[topString]),\n                // these are always relative to the viewport\n                calcSize = component.calculatedSize = _.floor({\n                    top: result[topString],\n                    left: result[leftString],\n                    width: result[widthString],\n                    height: result[heightString]\n                }, 2);\n            return calcSize;\n        },\n        /**\n         * uses the object condense utility to compress key, function pairs and applies them to the .commands object that handles all receive method commands\n         * @returns {buster}\n         * @func\n         * @name Buster#addCommand\n         */\n        addCommand: function (obj) {\n            this.on(_.foldl(obj, function (memo, name, handler) {\n                memo['receive:' + name] = handler;\n                return memo;\n            }, {}));\n            return this;\n        },\n        /**\n         * constantly posts until it gets a response\n         * @arg {object} message to go to the opposite buster pair\n         * @arg {number} optionally pass a number to change the setInterval time\n         * @returns {number} interval id that corresponds to the setInterval call id\n         * @func\n         * @name Buster#shout\n         */\n        shout: function (command, obj, extra, timer) {\n            var intervalId, buster = this,\n                message = buster.send(command, obj, extra);\n            // message.respond(_.once(function () {\n            //     _.AF.remove(intervalId);\n            //     if (_.isFunction(respondFn)) {\n            //         respondFn.apply(this, arguments);\n            //     }\n            // }));\n            intervalId = _.AF.time(timer || 100, function () {\n                postMessage(obj, buster);\n            });\n            return intervalId;\n        },\n        resetElements: function () {\n            var buster = this,\n                nextEl = buster.el,\n                finalRes = buster.parts.finalResponsified;\n            do {\n                _.resetAttrs(nextEl.get(0));\n                nextEl = nextEl.parent();\n            } while (nextEl.childOf(finalRes));\n            _.resetAttrs(finalRes.get(0));\n        },\n        /**\n         * starts a relationship between two busters. simplifies the initialization process.\n         * @returns {number} just for responding to the original message in case there's a handler\n         * @func\n         * @name Buster#begin\n         */\n        begin: function () {\n            var buster = this,\n                attrs = buster[attributesString],\n                inited = buster.initialized = 1,\n                message = buster.send('initialize', {\n                    expandConfig: attrs.expandConfig,\n                    referrer: attrs.publisher\n                });\n            message.respond(function (e) {\n                var data = e.data(),\n                    packet = data.packet;\n                buster.parent.set({\n                    initParentData: packet.parent\n                });\n                buster.set({\n                    isConnected: !0\n                });\n            });\n            return 1;\n        }\n    }, !0);\n    _.exports({\n        containerSize: containerSize\n    });\n});"],"sourceRoot":"/source/"}