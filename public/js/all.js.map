{"version":3,"sources":["setup.js","utils.js","shims.js","Strings.js","Collection.js","Events.js","Messenger.js","Box.js","Module.js","Looper.js","Promise.js","Ajax.js","Associator.js","DOMM.js","View.js","Buster.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvuCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7nBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzwEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACviBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"all.js","sourcesContent":["(function (win, where) {\n    'use strict';\n\n    function Application(name, parent) {\n        this.version = name;\n        this.scoped = true;\n        this.global = false;\n        return this;\n    }\n    var makeParody = function (parent, fn) {\n        return function () {\n            return fn.apply(parent, arguments);\n        };\n    };\n    Application.prototype.extend = function (obj) {\n        var n, app = this;\n        for (n in obj) {\n            if (obj.hasOwnProperty(n)) {\n                app[n] = obj[n];\n            }\n        }\n        return app;\n    };\n    Application.prototype.parody = function (list) {\n        var i = 0,\n            extendor = {},\n            parent = this.parent;\n        for (; i < list[LENGTH]; i++) {\n            extendor[list[i]] = makeParody(parent, parent[list[i]]);\n        }\n        this.extend(extendor);\n        return this;\n    };\n    var topmostDoc, MAKE_SCRIPT = 'makeScript',\n        LENGTH = 'length',\n        application = win[where] = win[where] || {\n            versions: {},\n            versionOrder: [],\n            global: true,\n            scoped: false,\n            registerVersion: function (name) {\n                var application = this,\n                    cachedOrCreated = application.versions[name],\n                    newApp = application.versions[name] = cachedOrCreated || new Application(name, application);\n                newApp.parent = application;\n                application.upsetDefaultVersion(name);\n                if (!cachedOrCreated) {\n                    application.versionOrder.push(name);\n                }\n                return newApp;\n            },\n            upsetDefaultVersion: function (version) {\n                var application = this;\n                if (application.defaultVersion) {\n                    // keyword version only works the first time then it's set for the lifespan\n                    if (+application.defaultVersion === +application.defaultVersion) {\n                        // keyword version overwrites default (dev / hotfix)\n                        if (+version !== +version) {\n                            application.defaultVersion = version;\n                        }\n                    }\n                } else {\n                    application.defaultVersion = version;\n                }\n            },\n            unRegisterVersion: function (name) {\n                var application = this,\n                    saved = application.versions[name],\n                    orderIdx = application.versionOrder.indexOf(name);\n                if (orderIdx !== -1) {\n                    application.versionOrder.splice(orderIdx, 1);\n                }\n                saved.parent = void 0;\n                application.versions[name] = void 0;\n                return saved;\n            },\n            scope: function (name_, fn_) {\n                var ret, app = this,\n                    hash = app.versions,\n                    name = fn_ ? name_ : app.defaultVersion,\n                    fn = fn_ ? fn_ : name_;\n                if (typeof name_ === 'string') {\n                    app.currentVersion = name_;\n                }\n                app.registerVersion(name);\n                ret = typeof fn === 'function' && fn(hash[name]);\n                return hash[name];\n            },\n            map: function (arra, fn, ctx) {\n                var i = 0,\n                    len = arra[LENGTH],\n                    arr = [];\n                while (len > i) {\n                    arr[i] = fn.call(ctx, i, arra[i], arra);\n                    i++;\n                }\n                return arr;\n            },\n            registerScopedMethod: function (name, expects_) {\n                var application = this,\n                    expects = expects_ || 3,\n                    method = application[name] = application[name] || function () {\n                        var version, i = 1,\n                            args = arguments,\n                            args_ = args,\n                            argLen = args[LENGTH];\n                        // expects is equivalent to what it would be if the version was passed in\n                        if (argLen < expects) {\n                            version = application.defaultVersion;\n                        } else {\n                            args_ = [];\n                            version = args[1];\n                            for (; i < args[LENGTH]; i++) {\n                                args_.push(args[i]);\n                            }\n                        }\n                        application.applyTo(version, name, args_);\n                    };\n                return application;\n            },\n            get: function (version) {\n                return this.versions[version];\n            },\n            applyTo: function (which, method, args) {\n                var application = this,\n                    app = application.get(which);\n                if (app) {\n                    return app[method].apply(app, args);\n                }\n            },\n            getCurrentScript: function (d) {\n                var allScripts = (d || doc).scripts,\n                    currentScript = d.currentScript,\n                    lastScript = allScripts[allScripts[LENGTH] - 1];\n                return currentScript || lastScript;\n            },\n            loadScript: function (url, callback, docu_) {\n                var scriptTag, application = this,\n                    // allow top doc to be overwritten\n                    docu = docu_ || topmostDoc || doc;\n                scriptTag = application[MAKE_SCRIPT](url, callback);\n                docu.head.appendChild(scriptTag);\n                return application;\n            },\n            makeScript: function (src, onload, docu_, preventappend) {\n                var docu = docu_ || topmostDoc || doc,\n                    script = docu.createElement('script');\n                script.type = 'text/javascript';\n                if (!preventappend) {\n                    docu.body.appendChild(script);\n                }\n                if (src) {\n                    if (onload) {\n                        script.onload = onload;\n                    }\n                    // src applied last for ie\n                    script.src = src;\n                }\n                return script;\n            },\n            touchTop: function (win) {\n                // assume you have top access\n                var href, topAccess = 1,\n                    application = this;\n                if (application.topAccess === void 0) {\n                    try {\n                        href = win.top.location.href;\n                        // safari bug where unfriendly frame returns undefined\n                        if (href) {\n                            topAccess = 0;\n                            application = win.top[where];\n                        }\n                    } catch (e) {\n                        topAccess = 1;\n                    }\n                    if (win === win.top) {\n                        topAccess = 0;\n                    }\n                    if (!topAccess) {\n                        topmostDoc = win.top.document;\n                        win.top[where] = application;\n                    }\n                    application.topAccess = !topAccess;\n                }\n                win[where] = application;\n                return application;\n            },\n        };\n}(window, 'application'));","application.scope('dev', function (app) {\n    var blank, _, object = Object,\n        win = window,\n        factories = {},\n        fn = Function,\n        array = Array,\n        string = String,\n        TO_STRING = 'toString',\n        PROTOTYPE = 'prototype',\n        CONSTRUCTOR = 'constructor',\n        LENGTH = 'length',\n        CONSTRUCTOR_KEY = '__constructor__',\n        stringProto = string[PROTOTYPE],\n        objectProto = object[PROTOTYPE],\n        arrayProto = array[PROTOTYPE],\n        funcProto = fn[PROTOTYPE],\n        nativeKeys = object.keys,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        NULL = null,\n        hasEnumBug = !{\n            toString: NULL\n        }.propertyIsEnumerable(TO_STRING),\n        noop = function () {},\n        /**\n         * @func\n         */\n        slice = function (obj, one, two) {\n            return stringProto.slice.call(obj, one, two);\n        },\n        listSlice = function (obj, one, two) {\n            return arrayProto.slice.call(obj, one, two);\n        },\n        /**\n         * @func\n         */\n        split = function (obj, str) {\n            return stringProto.split.call(obj, str);\n        },\n        /**\n         * @func\n         */\n        join = function (obj, str) {\n            return arrayProto.join.call(obj, str);\n        },\n        /**\n         * @func\n         */\n        pop = function (obj) {\n            return arrayProto.pop.call(obj);\n        },\n        /**\n         * @func\n         */\n        push = function (obj, item) {\n            var args = splice(arguments, 1);\n            return arrayProto.push.apply(obj, args);\n        },\n        /**\n         * @func\n         */\n        shift = function (o) {\n            return arrayProto.shift.call(o);\n        },\n        /**\n         * @func\n         */\n        indexOfNaN = function (array, fromIndex, toIndex, fromRight) {\n            if (!array) {\n                return -1;\n            }\n            var other, limit = array[LENGTH],\n                index = fromIndex + (fromRight ? 0 : -1),\n                incrementor = fromRight ? -1 : 1;\n            while ((index += incrementor) < limit) {\n                other = array[index];\n                if (other !== other) {\n                    return index;\n                }\n            }\n            return -1;\n        },\n        indexOf = function (array, value, fromIndex, toIndex, fromRight) {\n            var index, limit, incrementor;\n            if (!array) {\n                return -1;\n            }\n            if (value !== value) {\n                return indexOfNaN(array, fromIndex, toIndex, fromRight);\n            }\n            index = (fromIndex || 0) - 1;\n            limit = toIndex || array[LENGTH];\n            incrementor = fromRight ? -1 : 1;\n            while ((index += incrementor) < limit) {\n                if (array[index] === value) {\n                    return index;\n                }\n            }\n            return -1;\n        },\n        /**\n         * @func\n         */\n        splice = function () {\n            var ctx = shift(arguments);\n            return arrayProto.splice.apply(ctx, arguments);\n        },\n        reverse = function (arr) {\n            return arrayProto.reverse.call(arr);\n        },\n        /**\n         * @func\n         */\n        toString = function (obj) {\n            return (obj === NULL || obj === blank) ? '' : (obj + '');\n        },\n        /**\n         * @func\n         */\n        sort = function (obj, fn) {\n            var _fn;\n            if (isFunction(fn)) {\n                _fn = fn;\n                // normalization for safari\n                fn = function () {\n                    var res = +_fn.apply(this, arguments);\n                    if (isNaN(res)) {\n                        res = 0;\n                    }\n                    if (res > 1) {\n                        res = 1;\n                    }\n                    if (res < -1) {\n                        res = -1;\n                    }\n                    return res;\n                };\n            }\n            return arrayProto.sort.call(obj, fn);\n        },\n        /**\n         * @func\n         */\n        has = function (obj, prop) {\n            var val = !1;\n            if (obj && isFunction(obj.hasOwnProperty)) {\n                val = obj.hasOwnProperty(prop);\n            }\n            return val;\n        },\n        /**\n         * @func\n         */\n        previousConstructor = function (instance) {\n            return instance && instance[CONSTRUCTOR_KEY] && instance[CONSTRUCTOR_KEY][CONSTRUCTOR] || instance[CONSTRUCTOR];\n        },\n        nativeIsInstance = function (instance, constructor) {\n            var result = BOOLEAN_FALSE;\n            if (isFunction(constructor)) {\n                result = instance instanceof constructor;\n            }\n            return result;\n        },\n        isInstance = function (instance, constructor_) {\n            var constructor = constructor_;\n            while (has(constructor, CONSTRUCTOR)) {\n                constructor = constructor[CONSTRUCTOR];\n            }\n            return nativeIsInstance(instance, constructor);\n        },\n        /**\n         * @func\n         */\n        splitGen = function (delimiter) {\n            return function (list) {\n                if (isString(list)) {\n                    list = split(list, delimiter);\n                }\n                return list;\n            };\n        },\n        /**\n         * @func\n         */\n        joinGen = function (delimiter) {\n            return function (arr) {\n                return join(arr, delimiter);\n            };\n        },\n        /**\n         * @func\n         */\n        gapJoin = joinGen(' '),\n        /**\n         * @func\n         */\n        gapSplit = splitGen(' '),\n        /**\n         * @func\n         */\n        isWrap = function (type, fn) {\n            if (!fn) {\n                fn = function () {\n                    return 1;\n                };\n            }\n            return function (thing) {\n                var ret = 0;\n                if (typeof thing === type && fn(thing)) {\n                    ret = 1;\n                }\n                return !!ret;\n            };\n        },\n        /**\n         * @func\n         */\n        isFunction = isWrap('function'),\n        /**\n         * @func\n         */\n        isBoolean = isWrap('boolean'),\n        /**\n         * @func\n         */\n        isString = isWrap('string'),\n        /**\n         * @func\n         */\n        // isBlank = isWrap('undefined', function (thing) {\n        //     return thing === null;\n        // }),\n        isNull = function (thing) {\n            return thing === null;\n        },\n        isUndefined = function (thing) {\n            return thing === void 0;\n        },\n        isBlank = function (thing) {\n            return isUndefined(thing) || isNull(thing);\n        },\n        /**\n         * @func\n         */\n        isNaN = function (thing) {\n            return thing !== thing;\n        },\n        negate = function (fn) {\n            return function () {\n                return !fn.apply(this, arguments);\n            };\n        },\n        isNumber = isWrap('number', negate(isNaN)),\n        isFinite_ = win.isFinite,\n        isFinite = function (thing) {\n            return isNumber(thing) && isFinite_(thing);\n        },\n        /**\n         * @func\n         */\n        isObject = isWrap('object', function (thing) {\n            return !!thing;\n        }),\n        /**\n         * @func\n         */\n        isArray = Array.isArray,\n        /**\n         * @func\n         */\n        isEmpty = function (obj) {\n            return !keys(obj)[LENGTH];\n        },\n        nonEnumerableProps = gapSplit('valueOf isPrototypeOf ' + TO_STRING + ' propertyIsEnumerable hasOwnProperty toLocaleString'),\n        /**\n         * @func\n         */\n        invert = function (obj) {\n            var i = 0,\n                result = {},\n                objKeys = keys(obj),\n                length = objKeys[LENGTH];\n            for (; i < length; i++) {\n                result[obj[objKeys[i]]] = objKeys[i];\n            }\n            return result;\n        },\n        /**\n         * @func\n         */\n        collectNonEnumProps = function (obj, keys) {\n            var nonEnumIdx = nonEnumerableProps[LENGTH];\n            var constructor = obj[CONSTRUCTOR];\n            var proto = (isFunction(constructor) && constructor[PROTOTYPE]) || ObjProto;\n            // Constructor is a special case.\n            var prop = 'constructor';\n            if (has(obj, prop) && !contains(keys, prop)) keys.push(prop);\n            while (nonEnumIdx--) {\n                prop = nonEnumerableProps[nonEnumIdx];\n                if (prop in obj && obj[prop] !== proto[prop] && !contains(keys, prop)) {\n                    keys.push(prop);\n                }\n            }\n        },\n        /**\n         * @func\n         */\n        stringify = function (obj) {\n            if (isObject(obj)) {\n                obj = JSON.stringify(obj);\n            }\n            if (isFunction(obj)) {\n                obj = obj.toString();\n            }\n            return obj + '';\n        },\n        /**\n         * @func\n         */\n        uniqueId = (function () {\n            var cache = {},\n                global = 0;\n            return function (prefix, isInt) {\n                var val;\n                if (!prefix) {\n                    prefix = '';\n                }\n                prefix += '';\n                val = cache[prefix];\n                if (!val) {\n                    val = cache[prefix] = 0;\n                }\n                cache[prefix]++;\n                if (!isInt) {\n                    val = prefix + val;\n                }\n                return val;\n            };\n        }()),\n        now = function () {\n            return +(new Date());\n        },\n        allKeys = function (obj) {\n            var key, keys = [];\n            if (isObject(obj)) {\n                for (key in obj) {\n                    keys.push(key);\n                }\n                // Ahem, IE < 9.\n                if (hasEnumBug) {\n                    collectNonEnumProps(obj, keys);\n                }\n            }\n            return keys;\n        },\n        /**\n         * @func\n         */\n        extend = function () {\n            var deep = BOOLEAN_FALSE,\n                args = arguments,\n                length = args[LENGTH],\n                index = 1,\n                first = 0,\n                base = args[0];\n            if (base === BOOLEAN_TRUE) {\n                deep = BOOLEAN_TRUE;\n                base = args[1];\n                index = 2;\n            }\n            base = base || {};\n            for (; index < length; index++) {\n                merge(base, args[index], deep);\n            }\n            return base;\n        },\n        merge = function (obj1, obj2, deep) {\n            var key, val, i = 0,\n                keys = allKeys(obj2),\n                l = keys[LENGTH];\n            for (; i < l; i++) {\n                key = keys[i];\n                // ignore undefined\n                if (obj2[key] !== blank) {\n                    val = obj2[key];\n                    if (deep) {\n                        if (isObject(obj2[key])) {\n                            if (!isObject(obj1[key])) {\n                                obj1[key] = returnDismorphicBase(obj2[key]);\n                            }\n                            merge(obj1[key], obj2[key], deep);\n                        } else {\n                            obj1[key] = val;\n                        }\n                    } else {\n                        obj1[key] = val;\n                    }\n                }\n            }\n            return obj1;\n        },\n        /**\n         * @func\n         */\n        // Helper for collection methods to determine whether a collection\n        // should be iterated as an array or as an object\n        // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n        // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n        MAX_ARRAY_INDEX = Math.pow(2, 53) - 1,\n        /**\n         * @func\n         */\n        isArrayLike = function (collection) {\n            var length = !!collection && collection[LENGTH];\n            return isArray(collection) || (isNumber(length) && !isString(collection) && length >= 0 && length <= MAX_ARRAY_INDEX && !isFunction(collection));\n        },\n        eachProxy = function (fn) {\n            return function (obj_, iteratee_, context_, direction_) {\n                var ret, obj = obj_,\n                    list = obj,\n                    iteratee = iteratee_,\n                    iterator = iteratee,\n                    context = context_,\n                    direction = direction_;\n                if (obj) {\n                    if (!isArrayLike(obj)) {\n                        list = keys(obj);\n                        if (context) {\n                            iteratee = bind(iterator, context);\n                        }\n                        context = null;\n                        iterator = function (key, idx, list) {\n                            // gives you the key, use that to get the value\n                            return iteratee(obj[key], key, obj);\n                        };\n                    }\n                    return fn(list, iterator, context, direction);\n                }\n            };\n        },\n        /**\n         * @func\n         */\n        createPredicateIndexFinder = function (dir) {\n            return eachProxy(function (array, predicate, context, index_) {\n                var length = array[LENGTH],\n                    callback = bind(predicate, context),\n                    index = index_ || (dir > 0 ? 0 : length - 1);\n                for (; index >= 0 && index < length; index += dir) {\n                    if (callback(array[index], index, array)) {\n                        return index;\n                    }\n                }\n                return -1;\n            });\n        },\n        /**\n         * @func\n         */\n        // Returns the first index on an array-like that passes a predicate test\n        findIndex = createPredicateIndexFinder(1),\n        /**\n         * @func\n         */\n        findLastIndex = createPredicateIndexFinder(-1),\n        /**\n         * @func\n         */\n        validKey = function (key) {\n            // -1 for arrays\n            // any other data type ensures string\n            return key !== -1 && key === key && key !== blank && key !== null && key !== BOOLEAN_FALSE && key !== BOOLEAN_TRUE;\n        },\n        finder = function (findHelper) {\n            return function (obj, predicate, context, startpoint) {\n                var key = findHelper(obj, predicate, context, startpoint);\n                if (validKey(key)) {\n                    return obj[key];\n                }\n            };\n        },\n        find = finder(findIndex),\n        findLast = finder(findLastIndex),\n        bind = function (fn_, ctx) {\n            var fn = fn_;\n            if (ctx) {\n                fn = fn_.bind(ctx);\n            }\n            return fn;\n        },\n        duff = function (values, process, context, direction) {\n            var iterations, val, i, leftover, deltaFn;\n            if (values && isFunction(process)) {\n                i = 0;\n                val = values[LENGTH];\n                leftover = val % 8;\n                iterations = Math.floor(val / 8);\n                if (direction < 0) {\n                    i = val - 1;\n                }\n                direction = direction || 1;\n                process = bind(process, context);\n                if (leftover > 0) {\n                    do {\n                        process(values[i], i, values);\n                        i += direction;\n                    } while (--leftover > 0);\n                }\n                if (iterations) {\n                    do {\n                        process(values[i], i, values);\n                        i += direction;\n                        process(values[i], i, values);\n                        i += direction;\n                        process(values[i], i, values);\n                        i += direction;\n                        process(values[i], i, values);\n                        i += direction;\n                        process(values[i], i, values);\n                        i += direction;\n                        process(values[i], i, values);\n                        i += direction;\n                        process(values[i], i, values);\n                        i += direction;\n                        process(values[i], i, values);\n                        i += direction;\n                    } while (--iterations > 0);\n                }\n            }\n            return values;\n        },\n        each = eachProxy(duff),\n        /**\n         * @func\n         */\n        parseBool = function (thing) {\n            var ret, thingMod = thing + '';\n            thingMod = thingMod.trim();\n            if (thingMod === BOOLEAN_FALSE + '') {\n                ret = BOOLEAN_FALSE;\n            }\n            if (thingMod === BOOLEAN_TRUE + '') {\n                ret = BOOLEAN_TRUE;\n            }\n            if (ret === blank) {\n                ret = thing;\n            }\n            return ret;\n        },\n        /**\n         * @func\n         */\n        parseDecimal = function (num) {\n            return parseFloat(num) || 0;\n        },\n        pI = function (num) {\n            return parseInt(num, 10) || 0;\n        },\n        // math = Math,\n        // mathMix = function (method) {\n        //     return function (arr) {\n        //         return math[method].apply(math, arr);\n        //     };\n        // },\n        // random = function () {\n        //     return math.random();\n        // },\n        // mathMixCaller = function (method) {\n        //     return function (num) {\n        //         math[method](num);\n        //     };\n        // },\n        // mathMixComparer = function (method) {\n        //     return function (num, num2) {\n        //         math[method](num, num2);\n        //     };\n        // },\n        // min = mathMix('min'),\n        // max = mathMix('max'),\n        // abs = mathMixCaller('abs'),\n        // acos = mathMixCaller('acos'),\n        // asin = mathMixCaller('asin'),\n        // atan = mathMixCaller('atan'),\n        // ceil = mathMixCaller('ceil'),\n        // cos = mathMixCaller('cos'),\n        // exp = mathMixCaller('exp'),\n        // floor = mathMixCaller('floor'),\n        // log = mathMixCaller('log'),\n        // round = mathMixCaller('round'),\n        // sin = mathMixCaller('sin'),\n        // sqrt = mathMixCaller('sqrt'),\n        // tan = mathMixCaller('tan'),\n        /**\n         * @func\n         */\n        keys = function (obj) {\n            var key, keys = [];\n            if (!obj || (!isObject(obj) && !isFunction(obj))) {\n                return keys;\n            }\n            if (nativeKeys) {\n                return nativeKeys(obj);\n            }\n            for (key in obj) {\n                if (has(obj, key)) {\n                    keys.push(key);\n                }\n            }\n            // Ahem, IE < 9.\n            if (hasEnumBug) {\n                collectNonEnumProps(obj, keys);\n            }\n            return keys;\n        },\n        /**\n         * @func\n         */\n        constructorExtend = function (name, protoProps, attach) {\n            var nameString, child, passedParent, hasConstructor, constructor, parent = this,\n                nameIsStr = isString(name);\n            if (!nameIsStr) {\n                protoProps = name;\n            }\n            hasConstructor = has(protoProps, CONSTRUCTOR);\n            if (protoProps && hasConstructor) {\n                child = protoProps[CONSTRUCTOR];\n            }\n            if (nameIsStr) {\n                passedParent = parent;\n                if (child) {\n                    passedParent = child;\n                }\n                child = new Function[CONSTRUCTOR]('var parent=arguments[0];return function ' + name + '(){return parent.apply(this,arguments);}')(passedParent);\n                // factories[name] = child;\n            } else {\n                child = function () {\n                    return parent.apply(this, arguments);\n                };\n            }\n            // extend(child, parent);\n            child.extend = constructorExtend;\n            var Surrogate = function () {\n                this[CONSTRUCTOR] = child;\n            };\n            Surrogate[PROTOTYPE] = parent[PROTOTYPE];\n            child[PROTOTYPE] = new Surrogate;\n            // don't call the function if nothing exists\n            if (protoProps) {\n                extend(child[PROTOTYPE], protoProps);\n            }\n            constructor = child;\n            child = constructorWrapper(constructor);\n            child.__super__ = parent;\n            constructor[PROTOTYPE][CONSTRUCTOR_KEY] = child;\n            if (nameIsStr && attach) {\n                factories[name] = child;\n            }\n            return child;\n        },\n        constructorWrapper = function (Constructor) {\n            var __ = function (attributes, options) {\n                if (isInstance(attributes, Constructor)) {\n                    return attributes;\n                }\n                return new Constructor(attributes, options);\n            };\n            __[CONSTRUCTOR] = Constructor;\n            __.extend = function () {\n                return Constructor.extend.apply(Constructor, arguments);\n            };\n            return __;\n        },\n        /**\n         * @func\n         */\n        once = function (fn) {\n            var doIt;\n            return function () {\n                if (!doIt) {\n                    doIt = 1;\n                    fn.apply(this, arguments);\n                }\n            };\n        },\n        /**\n         * @func\n         */\n        // Internal recursive comparison function for `isEqual`.\n        eq = function (a, b, aStack, bStack) {\n            // Identical objects are equal. `0 === -0`, but they aren't identical.\n            // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n            if (a === b) {\n                return a !== 0 || 1 / a === 1 / b;\n            }\n            // A strict comparison is necessary because `null == undefined`.\n            if (a === null || a === blank || b === blank || b === null) {\n                return a === b;\n            }\n            // Unwrap any wrapped objects.\n            // if (a instanceof _) a = a._wrapped;\n            // if (b instanceof _) b = b._wrapped;\n            // Compare `[[Class]]` names.\n            var className = toString.call(a);\n            if (className !== toString.call(b)) return BOOLEAN_FALSE;\n            switch (className) {\n                // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n            case '[object RegExp]':\n                // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n            case '[object String]':\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n                // equivalent to `new String(\"5\")`.\n                return '' + a === '' + b;\n            case '[object Number]':\n                // `NaN`s are equivalent, but non-reflexive.\n                // Object(NaN) is equivalent to NaN\n                if (+a !== +a) return +b !== +b;\n                // An `egal` comparison is performed for other numeric values.\n                return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n            case '[object Date]':\n            case '[object Boolean]':\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n                // millisecond representations. Note that invalid dates with millisecond representations\n                // of `NaN` are not equivalent.\n                return +a === +b;\n            }\n            var areArrays = className === '[object Array]';\n            if (!areArrays) {\n                if (typeof a != 'object' || typeof b != 'object') return BOOLEAN_FALSE;\n                // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n                // from different frames are.\n                var aCtor = a[CONSTRUCTOR],\n                    bCtor = b[CONSTRUCTOR];\n                if (aCtor !== bCtor && !(isFunction(aCtor) && nativeIsInstance(aCtor, aCtor) && isFunction(bCtor) && nativeIsInstance(bCtor, bCtor)) && ('constructor' in a && 'constructor' in b)) {\n                    return BOOLEAN_FALSE;\n                }\n            }\n            // Assume equality for cyclic structures. The algorithm for detecting cyclic\n            // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n            // Initializing stack of traversed objects.\n            // It's done here since we only need them for objects and arrays comparison.\n            // aStack = aStack || [];\n            // bStack = bStack || [];\n            var length = aStack[LENGTH];\n            while (length--) {\n                // Linear search. Performance is inversely proportional to the number of\n                // unique nested structures.\n                if (aStack[length] === a) {\n                    return bStack[length] === b;\n                }\n            }\n            // Add the first object to the stack of traversed objects.\n            aStack.push(a);\n            bStack.push(b);\n            // Recursively compare objects and arrays.\n            if (areArrays) {\n                // Compare array lengths to determine if a deep comparison is necessary.\n                length = a[LENGTH];\n                if (length !== b[LENGTH]) {\n                    return BOOLEAN_FALSE;\n                }\n                // Deep compare the contents, ignoring non-numeric properties.\n                while (length--) {\n                    if (!eq(a[length], b[length], aStack, bStack)) {\n                        return BOOLEAN_FALSE;\n                    }\n                }\n            } else {\n                // Deep compare objects.\n                var objKeys = keys(a),\n                    key;\n                length = objKeys[LENGTH];\n                // Ensure that both objects contain the same number of properties before comparing deep equality.\n                if (keys(b)[LENGTH] !== length) return BOOLEAN_FALSE;\n                while (length--) {\n                    // Deep compare each member\n                    key = objKeys[length];\n                    if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return BOOLEAN_FALSE;\n                }\n            }\n            // Remove the first object from the stack of traversed objects.\n            aStack.pop();\n            bStack.pop();\n            return BOOLEAN_TRUE;\n        },\n        /**\n         * @func\n         */\n        // Perform a deep comparison to check if two objects are equal.\n        isEqual = function (a, b) {\n            return eq(a, b, [], []);\n        },\n        /**\n         * @func\n         */\n        // very shallow clone\n        clone = function (a) {\n            return map(a, function (value, key) {\n                return value;\n            });\n        },\n        fullClone = function (obj) {\n            return parse(stringify(obj));\n        },\n        /**\n         * @func\n         */\n        wrap = function (obj, fn, noExecute) {\n            var newObj = {},\n                _isArray = isArray(obj),\n                wasfunction = isFunction(fn);\n            each(obj, function (value, key) {\n                if (_isArray) {\n                    if (!wasfunction || noExecute) {\n                        newObj[value] = fn;\n                    } else {\n                        newObj[value] = fn(value);\n                    }\n                } else {\n                    newObj[key] = fn(obj[key], key);\n                }\n            });\n            return newObj;\n        },\n        /**\n         * @func\n         */\n        unshift = function (thing) {\n            var ret, items = [];\n            duff(arguments, function (arg, idx) {\n                if (idx) {\n                    items.push(arg);\n                }\n            });\n            return [].unshift.apply(thing, items);\n        },\n        /**\n         * @func\n         */\n        exports = function (obj) {\n            return extend(_, obj);\n        },\n        mix = function () {},\n        // cachable = function (fn) {\n        //     var cache = {};\n        //     return function () {\n        //         var key = JSON.stringify(arguments);\n        //         if (!cache[key]) {\n        //             cache[key] = JSON.stringify(fn.apply(this, arguments));\n        //         }\n        //         return JSON.parse(cache[key]);\n        //     };\n        // },\n        /**\n         * @func\n         */\n        Image = win.Image,\n        fetch = function (url, callback) {\n            var img = new Image();\n            url = stringifyQuery(url);\n            if (callback) {\n                img.onload = function () {\n                    _.unshift(arguments, url);\n                    callback.apply(this, arguments);\n                };\n            }\n            img.src = url;\n            return img;\n        },\n        /**\n         * @func\n         */\n        // returnBuild = function (obj, array, def) {\n        //     var attach, last, depth = obj;\n        //     duff(gapSplit(array), function (key, idx) {\n        //         last = key;\n        //         if (!isObject(depth[key])) {\n        //             if (def[idx] === blank) {\n        //                 depth[key] = {};\n        //             } else {\n        //                 depth[key] = def[idx];\n        //             }\n        //             attach = 1;\n        //         }\n        //         depth = depth[key];\n        //     });\n        //     return depth;\n        // },\n        // log = function (type, args) {\n        //     if (!_.isFunction(console[type])) {\n        //         type = 'log';\n        //     }\n        //     console[type].apply(console, args);\n        // },\n        /**\n         * @func\n         */\n        parse = function (val_) {\n            var val = val_;\n            if (isString(val)) {\n                val = val.trim();\n                if (val[0] === '{' || val[0] === '[') {\n                    wraptry(function () {\n                        val = JSON.parse(val);\n                    }, function () {\n                        console.error('could not parse', val);\n                    });\n                }\n            }\n            return val;\n        },\n        debounce = function (func, wait, immediate) {\n            var timeout;\n            return function () {\n                var context = this,\n                    args = arguments,\n                    callNow = immediate && !timeout,\n                    later = function () {\n                        timeout = null;\n                        if (!immediate) {\n                            func.apply(context, args);\n                        }\n                    };\n                clearTimeout(timeout);\n                timeout = setTimeout(later, wait);\n                if (callNow) {\n                    func.apply(context, args);\n                }\n                return timeout;\n            };\n        },\n        returnDismorphicBase = function (obj) {\n            return isArrayLike(obj) ? [] : {};\n        },\n        map = function (objs, iteratee, context) {\n            var collection = returnDismorphicBase(objs);\n            var bound = bind(iteratee, context);\n            each(objs, function (item, index) {\n                collection[index] = bound(item, index, objs);\n            });\n            return collection;\n        },\n        toArray = function (obj) {\n            var array = [];\n            each(obj, function (value, key) {\n                array.push(value);\n            });\n            return array;\n        },\n        /**\n         * @func\n         */\n        throttle = function (fn, threshold, scope) {\n            var last,\n                deferTimer;\n            if (!threshold) {\n                threshold = 250;\n            }\n            return function () {\n                var context = scope || this,\n                    _now = now(),\n                    args = arguments;\n                if (last && _now < last + threshold) {\n                    // hold on to it\n                    clearTimeout(deferTimer);\n                    deferTimer = setTimeout(function () {\n                        last = _now;\n                        fn.apply(context, args);\n                    }, threshold);\n                } else {\n                    last = _now;\n                    fn.apply(context, args);\n                }\n            };\n        },\n        /**\n         * @func\n         */\n        stringifyQuery = function (obj) {\n            var val, n, base = obj.url,\n                query = [];\n            if (isObject(obj)) {\n                for (n in obj.query) {\n                    val = obj.query[n];\n                    if (val !== blank) {\n                        val = encodeURIComponent(stringify(val));\n                        query.push(n + '=' + val);\n                    }\n                }\n                if (query[LENGTH]) {\n                    base += '?';\n                }\n                base += query.join('&');\n                if (obj.hash) {\n                    obj.hash = _.stringify(obj.hash);\n                    base += ('#' + obj.hash);\n                }\n            } else {\n                base = obj;\n            }\n            return base;\n        },\n        protoProp = function (instance, key, farDown) {\n            var val, proto, constructor = previousConstructor(instance);\n            farDown = farDown || 1;\n            do {\n                proto = constructor[PROTOTYPE];\n                val = proto[key];\n                constructor = previousConstructor(proto);\n            } while (--farDown > 0 && constructor && isFinite(farDown));\n            return val;\n        },\n        uuid = function () {\n            var blank, cryptoCheck = 'crypto' in window && 'getRandomValues' in crypto,\n                sid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n                    var rnd, r, v;\n                    if (cryptoCheck) {\n                        rnd = win.crypto.getRandomValues(new Uint32Array(1));\n                        if (rnd === blank) {\n                            cryptoCheck = false;\n                        }\n                    }\n                    if (!cryptoCheck) {\n                        rnd = [Math.floor(Math.random() * 10000000000)];\n                    }\n                    rnd = rnd[0];\n                    r = rnd % 16;\n                    v = (c === 'x') ? r : (r & 0x3 | 0x8);\n                    return v.toString(16);\n                });\n            return cryptoCheck ? sid : 'SF' + sid;\n        },\n        intendedArray = function (array, fn_) {\n            var fn = fn_;\n            if (isArrayLike(array)) {\n                duff(array, fn);\n            } else {\n                if (array) {\n                    fn(array, 0, [array]);\n                }\n            }\n        },\n        intendedObject = function (key, value, fn_) {\n            var fn = fn_,\n                obj = isObject(key) ? key : BOOLEAN_FALSE;\n            if (obj) {\n                each(obj, reverseParams(fn));\n            } else {\n                fn(key, value);\n            }\n        },\n        reverseParams = function (iteratorFn, ctx) {\n            return function (value, key, third) {\n                iteratorFn(key, value, third);\n            };\n        },\n        /**\n         * @func\n         */\n        reference = function (str) {\n            var match;\n            if (!isString(str)) {\n                str = str.referrer;\n            }\n            match = str.match(/^https?:\\/\\/.*?\\//);\n            if (match) {\n                match = match[0];\n            }\n            return match || '';\n        },\n        /**\n         * @func\n         */\n        roundFloat = function (val, power, base) {\n            var mult;\n            if (!isNumber(power)) {\n                power = 1;\n            }\n            mult = Math.pow(base || 10, power);\n            return (parseInt((mult * val), 10) / mult);\n        },\n        /**\n         * @func\n         */\n        cssTemplater = function (str, obj) {\n            str += '';\n            each(obj, function (key, val) {\n                str = str.split('\\\\\\\\' + key + '\\\\\\\\').join(val);\n            });\n            return str;\n        },\n        result = function (obj, str, arg) {\n            return isFunction(obj[str]) ? obj[str](arg) : obj[str];\n        },\n        mathArray = function (method) {\n            return function (args) {\n                return Math[method].apply(maths, args);\n            };\n        },\n        mathMix = function (key) {\n            var doIt = function (x, mult) {\n                var ret;\n                if (isArrayLike(x)) {\n                    ret = Math[key].apply(Math, x);\n                } else {\n                    ret = Math[key](x * mult);\n                    ret = ret / mult;\n                }\n                return ret;\n            };\n            return function (thing, mult) {\n                if (!isNumber(mult)) {\n                    mult = 1;\n                }\n                if (isNumber(thing) || isString(thing)) {\n                    return doIt(thing, mult);\n                } else {\n                    return duff(thing, function (val, key, obj) {\n                        obj[key] = doIt(val, mult);\n                    });\n                }\n            };\n        },\n        floor = mathMix('floor'),\n        ceil = mathMix('ceil'),\n        ensureFunction = function (fn) {\n            return function (_fn) {\n                _fn = _fn || function () {};\n                return fn.call(this, _fn);\n            };\n        },\n        _console = win.console || {},\n        _log = _console.log || noop,\n        console = wrap(gapSplit('trace log dir error'), function (key) {\n            var method = _console[key];\n            return function () {\n                if (method) {\n                    return method.apply(_console, arguments);\n                } else {\n                    return _log.apply(_console, arguments);\n                }\n            };\n        }),\n        wraptry = function (trythis, errthat, finalfunction) {\n            try {\n                return trythis();\n            } catch (e) {\n                return errthat && errthat(e);\n            } finally {\n                return finalfunction && finalfunction();\n            }\n        };\n    /**\n     * @class Model\n     */\n    function Model(attributes, secondary) {\n        return this;\n    }\n    factories.Model = Model;\n    Model[PROTOTYPE] = {};\n    Model.extend = constructorExtend;\n    _ = app._ = {\n        noop: noop,\n        months: gapSplit('january feburary march april may june july august september october november december'),\n        weekdays: gapSplit('sunday monday tuesday wednesday thursday friday saturday'),\n        constructorWrapper: constructorWrapper,\n        stringifyQuery: stringifyQuery,\n        intendedObject: intendedObject,\n        intendedArray: intendedArray,\n        ensureFunction: ensureFunction,\n        parseDecimal: parseDecimal,\n        reference: reference,\n        cssTemplater: cssTemplater,\n        isArrayLike: isArrayLike,\n        isInstance: isInstance,\n        hasEnumBug: hasEnumBug,\n        roundFloat: roundFloat,\n        factories: factories,\n        listSlice: listSlice,\n        fullClone: fullClone,\n        parseBool: parseBool,\n        stringify: stringify,\n        splitGen: splitGen,\n        gapSplit: gapSplit,\n        uniqueId: uniqueId,\n        wraptry: wraptry,\n        toString: toString,\n        throttle: throttle,\n        debounce: debounce,\n        protoProp: protoProp,\n        reverse: reverse,\n        indexOfNaN: indexOfNaN,\n        indexOf: indexOf,\n        joinGen: joinGen,\n        toArray: toArray,\n        isEqual: isEqual,\n        unshift: unshift,\n        gapJoin: gapJoin,\n        isArray: isArray,\n        isEmpty: isEmpty,\n        splice: splice,\n        isBoolean: isBoolean,\n        invert: invert,\n        extend: extend,\n        now: now,\n        map: map,\n        result: result,\n        isBlank: isBlank,\n        isUndefined: isUndefined,\n        isNull: isNull,\n        merge: merge,\n        fetch: fetch,\n        split: split,\n        clone: clone,\n        isObject: isObject,\n        isNaN: isNaN,\n        isNumber: isNumber,\n        isFinite: isFinite,\n        isString: isString,\n        isFunction: isFunction,\n        parse: parse,\n        shift: shift,\n        eachProxy: eachProxy,\n        exports: exports,\n        slice: slice,\n        bind: bind,\n        duff: duff,\n        sort: sort,\n        join: join,\n        wrap: wrap,\n        uuid: uuid,\n        allKeys: allKeys,\n        keys: keys,\n        once: once,\n        each: each,\n        push: push,\n        pop: pop,\n        has: has,\n        negate: negate,\n        pI: pI,\n        createPredicateIndexFinder: createPredicateIndexFinder,\n        findIndex: findIndex,\n        findLastIndex: findLastIndex,\n        validKey: validKey,\n        finder: finder,\n        find: find,\n        findLast: findLast,\n        console: console,\n        floor: floor,\n        ceil: ceil,\n        min: mathArray('min'),\n        max: mathArray('max'),\n        math: wrap(gapSplit('E LN2 LN10 LOG2E LOG10E PI SQRT1_2 SQRT2 abs acos acosh asin asinh atan atan2 atanh cbrt ceil clz32 cos cosh exp expm1 floor fround hypot imul log log1p log2 log10 max min pow random round sign sin sinh sqrt tan tanh trunc'), function (key) {\n            return Math[key];\n        })\n    };\n});","application.scope(function (app) {\n    app.shims = function (win) {\n        var fn = function () {\n            var win = this,\n                lengthString = 'length';\n            win.performance = win.performance || {};\n            win.performance.now = (function () {\n                var performance = win.performance;\n                return performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {\n                    return new Date().getTime();\n                };\n            })();\n\n            function f(n) {\n                return n < 10 ? \"0\" + n : n;\n            }\n\n            function quote(string) {\n                escapable.lastIndex = 0;\n                return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n                    var c = meta[a];\n                    return typeof c === \"string\" ? c : \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n                }) + '\"' : '\"' + string + '\"';\n            }\n\n            function str(key, holder) {\n                var i, k, v, length, mind = gap,\n                    partial, value = holder[key];\n                if (value && typeof value === \"object\" && typeof value.toJSON === \"function\") {\n                    value = value.toJSON(key);\n                }\n                if (typeof rep === \"function\") {\n                    value = rep.call(holder, key, value);\n                }\n                switch (typeof value) {\n                case \"string\":\n                    return quote(value);\n                case \"number\":\n                    return isFinite(value) ? String(value) : \"null\";\n                case \"boolean\":\n                case \"null\":\n                    return String(value);\n                case \"object\":\n                    if (!value) {\n                        return \"null\";\n                    }\n                    gap += indent;\n                    partial = [];\n                    if (Object.prototype.toString.apply(value) === \"[object Array]\") {\n                        length = value[lengthString];\n                        for (i = 0; i < length; i += 1) {\n                            partial[i] = str(i, value) || \"null\";\n                        }\n                        v = partial[lengthString] === 0 ? \"[]\" : gap ? \"[\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"]\" : \"[\" + partial.join(\",\") + \"]\";\n                        gap = mind;\n                        return v;\n                    }\n                    if (rep && typeof rep === \"object\") {\n                        length = rep[lengthString];\n                        for (i = 0; i < length; i += 1) {\n                            if (typeof rep[i] === \"string\") {\n                                k = rep[i];\n                                v = str(k, value);\n                                if (v) {\n                                    partial.push(quote(k) + (gap ? \": \" : \":\") + v);\n                                }\n                            }\n                        }\n                    } else {\n                        for (k in value) {\n                            if (Object.prototype.hasOwnProperty.call(value, k)) {\n                                v = str(k, value);\n                                if (v) {\n                                    partial.push(quote(k) + (gap ? \": \" : \":\") + v);\n                                }\n                            }\n                        }\n                    }\n                    v = partial[lengthString] === 0 ? \"{}\" : gap ? \"{\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"}\" : \"{\" + partial.join(\",\") + \"}\";\n                    gap = mind;\n                    return v;\n                }\n            }\n            if (!JSON) {\n                if (typeof Date.prototype.toJSON !== \"function\") {\n                    Date.prototype.toJSON = function (key) {\n                        return isFinite(this.valueOf()) ? this.getUTCFullYear() + \"-\" + f(this.getUTCMonth() + 1) + \"-\" + f(this.getUTCDate()) + \"T\" + f(this.getUTCHours()) + \":\" + f(this.getUTCMinutes()) + \":\" + f(this.getUTCSeconds()) + \"Z\" : null;\n                    };\n                    String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function (key) {\n                        return this.valueOf();\n                    };\n                }\n                var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n                    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n                    gap, indent, meta = {\n                        \"\\b\": \"\\\\b\",\n                        \"\\t\": \"\\\\t\",\n                        \"\\n\": \"\\\\n\",\n                        \"\\f\": \"\\\\f\",\n                        \"\\r\": \"\\\\r\",\n                        '\"': '\\\\\"',\n                        \"\\\\\": \"\\\\\\\\\"\n                    },\n                    rep;\n                if (typeof JSON.stringify !== \"function\") {\n                    JSON.stringify = function (value, replacer, space) {\n                        var i;\n                        gap = \"\";\n                        indent = \"\";\n                        if (typeof space === \"number\") {\n                            for (i = 0; i < space; i += 1) {\n                                indent += \" \";\n                            }\n                        } else {\n                            if (typeof space === \"string\") {\n                                indent = space;\n                            }\n                        }\n                        rep = replacer;\n                        if (replacer && typeof replacer !== \"function\" && (typeof replacer !== \"object\" || typeof replacer[lengthString] !== \"number\")) {\n                            throw new Error(\"JSON.stringify\");\n                        }\n                        return str(\"\", {\n                            \"\": value\n                        });\n                    };\n                }\n                if (typeof JSON.parse !== \"function\") {\n                    JSON.parse = function (text, reviver) {\n                        var j;\n\n                        function walk(holder, key) {\n                            var k, v, value = holder[key];\n                            if (value && typeof value === \"object\") {\n                                for (k in value) {\n                                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                                        v = walk(value, k);\n                                        if (v !== undefined) {\n                                            value[k] = v;\n                                        } else {\n                                            delete value[k];\n                                        }\n                                    }\n                                }\n                            }\n                            return reviver.call(holder, key, value);\n                        }\n                        text = String(text);\n                        cx.lastIndex = 0;\n                        if (cx.test(text)) {\n                            text = text.replace(cx, function (a) {\n                                return \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n                            });\n                        }\n                        if (/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, \"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, \"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g, \"\"))) {\n                            j = Function.prototype.constructor(\"(\" + text + \")\");\n                            return typeof reviver === \"function\" ? walk({\n                                \"\": j\n                            }, \"\") : j;\n                        }\n                        throw new SyntaxError(\"JSON.parse\");\n                    };\n                }\n            }\n            if (!Function.prototype.bind) {\n                Function.prototype.bind = function (oThis) {\n                    if (typeof this !== 'function') {\n                        // closest thing possible to the ECMAScript 5\n                        // internal IsCallable function\n                        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n                    }\n                    var aArgs = Array.prototype.slice.call(arguments, 1),\n                        fToBind = this,\n                        FNOP = function () {},\n                        fBound = function () {\n                            return fToBind.apply(this instanceof FNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n                        };\n                    if (this.prototype) {\n                        // native functions don't have a prototype\n                        FNOP.prototype = this.prototype;\n                    }\n                    fBound.prototype = new FNOP();\n                    return fBound;\n                };\n            }\n            window.matchMedia = window.matchMedia || function () {\n                // \"use strict\";\n                // For browsers that support matchMedium api such as IE 9 and webkit\n                var styleMedia = (window.styleMedia || window.media);\n                // For those that don't support matchMedium\n                if (!styleMedia) {\n                    var style = document.createElement('style'),\n                        script = document.getElementsByTagName('script')[0],\n                        info = null;\n                    style.type = 'text/css';\n                    style.id = 'matchmediajs-test';\n                    script.parentNode.insertBefore(style, script);\n                    // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n                    info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;\n                    styleMedia = {\n                        matchMedium: function (media) {\n                            var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\n                            // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n                            if (style.styleSheet) {\n                                style.styleSheet.cssText = text;\n                            } else {\n                                style.textContent = text;\n                            }\n                            // Test if media query is true or false\n                            return info.width === '1px';\n                        }\n                    };\n                }\n                return function (media) {\n                    media = media || 'all';\n                    return {\n                        matches: styleMedia.matchMedium(media),\n                        media: media\n                    };\n                };\n            }();\n        };\n        fn.call(win);\n    };\n    app.shims(window);\n});","application.scope(function (app) {\n    var blank, _ = app._,\n        toArray = _.toArray,\n        map = _.map,\n        indexOf = _.indexOf,\n        gapSplit = _.gapSplit,\n        isString = _.isString,\n        slice = _.slice,\n        split = _.split,\n        extend = _.extend,\n        wrap = _.wrap,\n        LENGTH = 'length',\n        HTTP = 'http',\n        falseBool = false,\n        has = _.has,\n        join = _.join,\n        cacheable = function (fn) {\n            var cache = {};\n            return function (input) {\n                if (!has(cache, input)) {\n                    cache[input] = fn(input);\n                }\n                return cache[input];\n            };\n        },\n        categoricallyCacheable = function (fn, baseCategory) {\n            var cache = {};\n            return function (string, category) {\n                var cacher;\n                category = category || baseCategory;\n                cacher = cache[category] = cache[category] || cacheable(fn(category));\n                return cacher(string);\n            };\n        },\n        string = extend(wrap(gapSplit('toLowerCase toUpperCase trim'), function (method) {\n            return cacheable(function (item) {\n                return item[method]();\n            });\n        }), wrap(gapSplit('indexOf match search'), function (method) {\n            return categoricallyCacheable(function (input) {\n                return function (item) {\n                    return item[method](input);\n                };\n            });\n        })),\n        wrapAll = function (fn) {\n            return function () {\n                var args = toArray(arguments),\n                    ctx = this;\n                return map(args[0], function (thing) {\n                    args[0] = thing;\n                    return fn.apply(ctx, args);\n                });\n            };\n        },\n        deprefix = function (str, prefix, unUpcase) {\n            var nuStr = str.slice(prefix[LENGTH]),\n                first = nuStr[0];\n            if (unUpcase) {\n                first = nuStr[0].toLowerCase();\n            }\n            nuStr = first + nuStr.slice(1);\n            return nuStr;\n        },\n        deprefixAll = wrapAll(deprefix),\n        prefix = function (str, prefix, camelcase, splitter) {\n            var myStr = prefix + str;\n            if (camelcase !== blank) {\n                myStr = prefix + (splitter || '-') + str;\n                if (camelcase) {\n                    myStr = camelCase(myStr, splitter);\n                } else {\n                    myStr = unCamelCase(myStr, splitter);\n                }\n            }\n            return myStr;\n        },\n        prefixAll = wrapAll(prefix),\n        parseObject = (function () {\n            var cache = {};\n            return function (string) {\n                var found = cache[string];\n                if (!found) {\n                    cache[string] = found = new Function.constructor('return ' + string);\n                }\n                return found();\n            };\n        }()),\n        /**\n         * @func\n         */\n        camelCase = categoricallyCacheable(function (splitter) {\n            return function (str) {\n                var i, s, val;\n                if (isString(str)) {\n                    if (str[0] === splitter) {\n                        str = slice(str, 1);\n                    }\n                    s = split(str, splitter);\n                    for (i = s[LENGTH] - 1; i >= 1; i--) {\n                        if (s[i]) {\n                            s[i] = upCase(s[i]);\n                        }\n                    }\n                    val = join(s, '');\n                }\n                return val;\n            };\n        }, '-'),\n        /**\n         * @func\n         */\n        upCase = cacheable(function (s) {\n            return s[0].toUpperCase() + slice(s, 1);\n        }),\n        /**\n         * @func\n         */\n        unCamelCase = categoricallyCacheable(function (splitter) {\n            return function (str) {\n                return str.replace(/([a-z])([A-Z])/g, '$1' + splitter + '$2').replace(/[A-Z]/g, function (s) {\n                    return s.toLowerCase();\n                });\n            };\n        }, '-'),\n        /**\n         * @func\n         */\n        customUnits = categoricallyCacheable(function (unitList_) {\n            var unitList = gapSplit(unitList_);\n            return function (str) {\n                var i, ch, unitStr, unit = [];\n                // make sure it's a string\n                str += '';\n                // make sure there is no trailing whitespace\n                str = str.trim();\n                i = str[LENGTH];\n                // work from the back\n                while (str[--i]) {\n                    // for (i = str[LENGTH] - 1; i >= 0; i--) {\n                    unit.unshift(str[i]);\n                    unitStr = unit.join('');\n                    if (indexOf(unitList, unitStr) >= 0) {\n                        if (unitStr === 'em') {\n                            if (str[i - 1] === 'r') {\n                                unitStr = 'rem';\n                            }\n                        }\n                        if (unitStr === 'in') {\n                            if (str[i - 2] === 'v' && str[i - 1] === 'm') {\n                                unitStr = 'vmin';\n                            }\n                        }\n                        return unitStr;\n                    }\n                }\n                return falseBool;\n            };\n        }),\n        baseUnitList = gapSplit('px em ex in cm % vh vw pc pt mm vmax vmin'),\n        units = function (str) {\n            return customUnits(str, baseUnitList);\n        },\n        isHttp = cacheable(function (str) {\n            var ret = !1;\n            if ((str.indexOf(HTTP) === 0 && str.split('//').length >= 2) || str.indexOf('//') === 0) {\n                ret = !0;\n            }\n            return ret;\n        }),\n        parseHash = cacheable(function (url) {\n            var hash = '',\n                hashIdx = indexOf(url, '#') + 1;\n            if (hashIdx) {\n                hash = url.slice(hashIdx - 1);\n            }\n            return hash;\n        }),\n        parseURL = function (url) {\n            var firstSlash, hostSplit, originNoProtocol, search = '',\n                hash = '',\n                host = '',\n                pathname = '',\n                protocol = '',\n                port = '',\n                hostname = '',\n                origin = url,\n                searchIdx = indexOf(url, '?') + 1,\n                searchObject = {},\n                protocols = [HTTP, HTTP + 's', 'file', 'about'],\n                protocolLength = protocols.length,\n                doubleSlash = '//';\n            if (searchIdx) {\n                search = url.slice(searchIdx - 1);\n                origin = origin.split(search).join('');\n                hash = parseHash(search);\n                search = search.split(hash).join('');\n                searchObject = app.parseSearch(search);\n            } else {\n                hash = parseHash(url);\n                origin = origin.split(hash).join('');\n            }\n            if (url[0] === '/' && url[1] === '/') {\n                protocol = window.location.protocol;\n                url = protocol + url;\n                origin = protocol + origin;\n            } else {\n                while (protocolLength-- && !protocol) {\n                    if (url.slice(0, protocols[protocolLength].length) === protocols[protocolLength]) {\n                        protocol = protocols[protocolLength];\n                    }\n                }\n                if (!protocol) {\n                    protocol = HTTP;\n                }\n                protocol += ':';\n                if (origin.slice(0, protocol.length) + doubleSlash !== protocol + doubleSlash) {\n                    url = protocol + doubleSlash + url;\n                    origin = protocol + doubleSlash + origin;\n                }\n            }\n            originNoProtocol = origin.split(protocol + doubleSlash).join('');\n            firstSlash = indexOf(originNoProtocol, '/') + 1;\n            pathname = originNoProtocol.slice(firstSlash - 1);\n            host = originNoProtocol.slice(0, firstSlash - 1);\n            origin = origin.split(pathname).join('');\n            hostSplit = host.split(':');\n            hostname = hostSplit.shift();\n            port = hostSplit.join(':');\n            return {\n                port: port,\n                hostname: hostname,\n                pathname: pathname,\n                search: search,\n                host: host,\n                hash: hash,\n                href: url,\n                protocol: protocol,\n                origin: origin,\n                searchObject: searchObject\n            };\n        };\n    _.exports({\n        // constants\n        customUnits: customUnits,\n        // cache makers\n        cacheable: cacheable,\n        categoricallyCacheable: categoricallyCacheable,\n        // cacheable\n        deprefix: deprefix,\n        deprefixAll: deprefixAll,\n        prefix: prefix,\n        prefixAll: prefixAll,\n        upCase: upCase,\n        unCamelCase: unCamelCase,\n        camelCase: camelCase,\n        string: string,\n        units: units,\n        baseUnitList: baseUnitList,\n        isHttp: isHttp,\n        parseHash: parseHash,\n        parseURL: parseURL,\n        parseObject: parseObject\n    });\n});","application.scope(function (app) {\n    var blank, _ = app._,\n        factories = _.factories,\n        isObject = _.isObject,\n        isNumber = _.isNumber,\n        isFunction = _.isFunction,\n        isInstance = _.isInstance,\n        LENGTH = 'length',\n        ITEMS = '_items',\n        BY_ID = '_byId',\n        ID = 'id',\n        PREVIOUS = '_previous',\n        each = _.each,\n        duff = _.duff,\n        push = _.push,\n        wrap = _.wrap,\n        keys = _.keys,\n        find = _.find,\n        map = _.map,\n        has = _.has,\n        isBlank = _.isBlank,\n        stringify = _.stringify,\n        findLast = _.findLast,\n        allKeys = _.allKeys,\n        splice = _.splice,\n        toArray = _.toArray,\n        gapSplit = _.gapSplit,\n        sort = _.sort,\n        bind = _.bind,\n        extend = _.extend,\n        result = _.result,\n        isArrayLike = _.isArrayLike,\n        negate = _.negate,\n        isArray = _.isArray,\n        indexOf = _.indexOf,\n        clone = _.clone,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        eachCall = function (array, method, arg) {\n            return duff(array, function (item) {\n                result(item, method, arg);\n            });\n        },\n        eachRevCall = function (array, method, arg) {\n            return duff(array, function (item) {\n                result(item, method, arg);\n            }, null, -1);\n        },\n        doToEverything = function (doLater, direction) {\n            return function () {\n                var args = toArray(arguments),\n                    one = args.shift();\n                duff(args, function (items) {\n                    duff(items, function (item) {\n                        doLater(one, item);\n                    }, null, direction || 1);\n                });\n                return one;\n            };\n        },\n        /**\n         * @func\n         */\n        remove = function (list, item, lookAfter) {\n            var index = posit(list, item, lookAfter);\n            if (index) {\n                removeAt(list, index - 1);\n            }\n            return !!index;\n        },\n        removeAll = doToEverything(remove, -1),\n        removeAt = function (list, index) {\n            return splice(list, index, 1)[0];\n        },\n        add = function (list, item) {\n            var val = 0,\n                index = posit(list, item);\n            if (!index) {\n                val = push(list, item);\n            }\n            return !!val;\n        },\n        addAll = doToEverything(add),\n        addAt = function (list, item, index) {\n            var len = list[LENGTH],\n                lastIdx = len || 0;\n            splice(list, index || 0, 0, item);\n            return len !== list[LENGTH];\n        },\n        range = function (start, stop, step, inclusive) {\n            var length, range, idx;\n            if (isBlank(stop)) {\n                stop = start || 0;\n                start = 0;\n            }\n            if (!isFinite(start) || !isNumber(start)) {\n                start = 0;\n            }\n            step = +step || 1;\n            length = Math.max(Math.ceil((stop - start) / step), 0) + (+inclusive || 0);\n            range = [];\n            idx = 0;\n            while (idx < length) {\n                range[idx] = start;\n                idx++;\n                start += step;\n            }\n            return range;\n        },\n        count = function (list, start, end, runner_) {\n            var runner, obj, idx, ctx = this;\n            if (start < end && isNumber(start) && isNumber(end) && isFinite(start) && isFinite(end)) {\n                end = Math.abs(end);\n                idx = start;\n                runner = bind(runner_, ctx);\n                while (idx < end) {\n                    obj = null;\n                    if (has(list, idx)) {\n                        obj = list[idx];\n                    }\n                    runner(obj, idx, list);\n                    idx++;\n                }\n            }\n            return list;\n        },\n        // array, startIndex, endIndex\n        between = function (fn) {\n            return function (list, startIdx_, endIdx_) {\n                var ret = [],\n                    startIdx = startIdx_ || 0,\n                    endIdx = endIdx_ || list[LENGTH],\n                    findResult = find(list, function (item, idx, list) {\n                        fn(ret, item, idx, list);\n                    }, null, endIdx);\n                return ret;\n            };\n        },\n        /**\n         * @func\n         */\n        closest = function (list, target) {\n            var match, path, diff, valuesLen, possible, i = 0,\n                previousAbs = Infinity;\n            // trying to avoid running through 20 matchs\n            // when i'm already at the exact one\n            if (!isArrayLike(list)) {\n                return;\n            }\n            valuesLen = list[LENGTH];\n            if (valuesLen === 1) {\n                match = list[0];\n            }\n            if (indexOf(list, target) !== -1) {\n                match = target;\n            }\n            if (!match) {\n                // try doing this later with no sorting\n                sort(list);\n                for (i = valuesLen - 1;\n                    (i >= 0 && !match); i--) {\n                    path = list[i];\n                    diff = Math.abs(target - path);\n                    if (diff < previousAbs) {\n                        possible = path;\n                        previousAbs = diff;\n                    }\n                }\n                match = possible;\n            }\n            if (!match) {\n                match = target;\n            }\n            return match;\n        },\n        countTo = function (list, num, runner) {\n            return count(list, 0, num, runner);\n        },\n        countFrom = function (list, num, runner) {\n            return count(list, num, list[LENGTH], runner);\n        },\n        /**\n         * @func\n         */\n        posit = function (list, item, lookAfter) {\n            return indexOf(list, item, lookAfter) + 1;\n        },\n        /**\n         * @func\n         */\n        concat = function () {\n            var array = [];\n            duff(arguments, function (arg) {\n                duff(arg, function (item) {\n                    array.push(item);\n                });\n            });\n            return array;\n        },\n        /**\n         * @func\n         */\n        concatUnique = function () {\n            var array = [];\n            duff(concat.apply(null, arguments), function (item) {\n                if (!posit(array, item)) {\n                    array.push(item);\n                }\n            });\n            return array;\n        },\n        cycle = function (arr, num) {\n            var piece, len = arr[LENGTH];\n            if (isNumber(len)) {\n                num = num % len;\n                piece = arr.splice(num);\n                arr.unshift.apply(arr, piece);\n            }\n            return arr;\n        },\n        internalMambo = function (fn) {\n            return function (arr) {\n                arr.reverse();\n                fn.apply(this, arguments);\n                arr.reverse();\n                return arr;\n            };\n        },\n        // Returns whether an object has a given set of `key:value` pairs.\n        isMatch = function (object, attrs) {\n            var key, i = 0,\n                keysResult = keys(attrs),\n                obj = Object(object);\n            return !find(keysResult, function (val) {\n                if (attrs[val] !== obj[val] || !(val in obj)) {\n                    return BOOLEAN_TRUE;\n                }\n            });\n        },\n        // Returns a predicate for checking whether an object has a given set of\n        // `key:value` pairs.\n        matches = function (obj1) {\n            return function (obj2) {\n                return isMatch(obj2, obj1);\n            };\n        },\n        uncycle = internalMambo(cycle),\n        externalMambo = internalMambo(function (list, fn) {\n            return fn.apply(this, arguments);\n        }),\n        pluck = function (arr, key) {\n            var items = [];\n            duff(arr, function (item) {\n                if (isObject(item) && item[key] !== void 0) {\n                    items.push(item[key]);\n                }\n            });\n            return items;\n        },\n        // Convenience version of a common use case of `filter`: selecting only objects\n        // containing specific `key:value` pairs.\n        where = function (obj, attrs) {\n            return filter(obj, matches(attrs));\n        },\n        // Convenience version of a common use case of `find`: getting the first object\n        // containing specific `key:value` pairs.\n        findWhere = function (obj, attrs) {\n            return find(obj, matches(attrs));\n        },\n        // Convenience version of a common use case of `find`: getting the first object\n        // containing specific `key:value` pairs.\n        findLastWhere = function (obj, attrs) {\n            return findLast(obj, matches(attrs));\n        },\n        whereNot = function (obj, attrs) {\n            return filter(obj, negate(matches(attrs)));\n        },\n        flatten = function () {\n            return foldl(arguments, function (memo, item) {\n                if (isArrayLike(item)) {\n                    memo = memo.concat(flatten.apply(null, item));\n                } else {\n                    memo.push(item);\n                }\n                return memo;\n            }, []);\n        },\n        splat = function (fn, spliceat) {\n            spliceat = spliceat || 0;\n            return function () {\n                var ctx = this,\n                    arr = toArray(arguments),\n                    args = splice(arr, spliceat);\n                // return duff(args, fn, this, arr);\n                duff(args, function (idx, item, list) {\n                    fn.apply(ctx, arr.concat([idx, item, list]));\n                });\n            };\n        },\n        // merge = splat(function (item, idx, list) {\n        //     var len, collection = this,\n        //         last = collection[LENGTH];\n        //     if (isArrayLike(item)) {\n        //         len = item[LENGTH];\n        //         duff(item, function (key, val) {\n        //             if (val !== blank) {\n        //                 // removes any undefined items\n        //                 len = key + 1;\n        //                 collection[key] = val;\n        //             }\n        //         });\n        //         if (len > (last || 0)) {\n        //             collection[LENGTH] = len;\n        //         }\n        //     }\n        // }),\n        eq = function (list, num) {\n            var n, thisNum, items = [],\n                numb = num || 0,\n                evaluatedIsNumber = isNumber(numb),\n                isArray = isArrayLike(numb);\n            if (numb < 0) {\n                evaluatedIsNumber = BOOLEAN_FALSE;\n            }\n            if (list[LENGTH]) {\n                if (evaluatedIsNumber) {\n                    items = [list[numb]];\n                }\n                if (isArray) {\n                    items = clone(numb);\n                }\n                if (!isArray && !evaluatedIsNumber && list[0]) {\n                    items = [list[0]];\n                }\n            }\n            return items;\n        },\n        tackRev = function (fn, index, ctx) {\n            return function () {\n                var args = toArray(arguments);\n                while (args[LENGTH] < index) {\n                    // fill it out with null\n                    args.push(null);\n                }\n                // put -1 on as the last arg\n                args.push(-1);\n                return fn.apply(ctx || _, args);\n            };\n        },\n        duffRev = tackRev(duff, 3),\n        eachRev = tackRev(each, 3),\n        recreateSelf = function (fn, ctx) {\n            return function () {\n                return new this.__constructor__(fn.apply(ctx || this, arguments));\n            };\n        },\n        /**\n         * @func\n         */\n        // Create a reducing function iterating left or right.\n        createReduce = function (dir) {\n            // Optimized iterator function as using arguments[LENGTH]\n            // in the main function will deoptimize the, see #1991.\n            var iterator = function (obj, iteratee, memo, keys, index, length) {\n                var currentKey;\n                for (; index >= 0 && index < length; index += dir) {\n                    currentKey = keys ? keys[index] : index;\n                    memo = iteratee(memo, obj[currentKey], currentKey, obj);\n                }\n                return memo;\n            };\n            return function (obj, iteratee, memo, context) {\n                // iteratee = optimizeCb(iteratee, context, 4);\n                var actualKeys = !isArrayLike(obj) && keys(obj),\n                    length = (actualKeys || obj)[LENGTH],\n                    index = dir > 0 ? 0 : length - 1;\n                // Determine the initial value if none is provided.\n                if (arguments[LENGTH] < 3) {\n                    memo = obj[actualKeys ? actualKeys[index] : index];\n                    index += dir;\n                }\n                return iterator(obj, iteratee, memo, actualKeys, index, length);\n            };\n        },\n        // **Reduce** builds up a single result from a list of values, aka `inject`,\n        // or `foldl`.\n        /**\n         * @func\n         */\n        foldl = createReduce(1),\n        // The right-associative version of reduce, also known as `foldr`.\n        /**\n         * @func\n         */\n        foldr = createReduce(-1),\n        /**\n         * @func\n         */\n        filter = function (obj, iteratee, context) {\n            var isArrayResult = isArrayLike(obj),\n                bound = bind(iteratee, context),\n                runCount = 0;\n            return foldl(obj, function (memo, item, key, all) {\n                runCount++;\n                if (bound(item, key, all)) {\n                    if (isArrayResult) {\n                        memo.push(item);\n                    } else {\n                        memo[key] = item;\n                    }\n                }\n                return memo;\n            }, isArrayResult ? [] : {});\n        },\n        unwrapper = function (fn) {\n            return function (args) {\n                args[0] = args[0][ITEMS];\n                return fn.call(this, args);\n            };\n        },\n        unwrapInstance = function (instance_) {\n            return isInstance(instance, factories.Collection) ? instance_ : instance.unwrap();\n        },\n        unwrapAll = function (fn) {\n            return function (args) {\n                duff(args, function (arg, idx, args) {\n                    args[idx] = unwrapInstance(arg);\n                });\n                return fn.call(this, args);\n            };\n        },\n        unwrap = function () {\n            return this[ITEMS];\n        },\n        canRunHash = {},\n        wrappedCollectionMethods = extend(wrap({\n            each: duff,\n            duff: duff,\n            forEach: duff,\n            eachRev: duffRev,\n            duffRev: duffRev,\n            forEachRev: duffRev\n        }, function (fn, key) {\n            canRunHash[key] = 1;\n            return function (iterator) {\n                var items = this[ITEMS];\n                if (canRunHash[key] <= items[LENGTH]) {\n                    fn(this[ITEMS], iterator, this);\n                }\n                return this;\n            };\n        }), wrap(gapSplit('addAll removeAll'), function (name) {\n            return function () {\n                var args = toArray(arguments);\n                args.unshift(this);\n                // unwrapAll\n                duff(args, function (arg, idx, args) {\n                    if (isInstance(arg, Collection)) {\n                        arg = arg.unwrap();\n                    }\n                    args[idx] = arg;\n                });\n                // custom\n                _[name].apply(_, args);\n                return this;\n            };\n        }), wrap(gapSplit('sort unshift push cycle uncycle reverse count countTo countFrom eachCall eachRevCall'), function (name) {\n            return function () {\n                var args = toArray(arguments);\n                args.unshift(this[ITEMS]);\n                // unwrapper\n                // custom\n                _[name].apply(_, args);\n                return this;\n            };\n        }), wrap(gapSplit('has add addAt remove removeAt pop shift indexOf find findLast findWhere findLastWhere posit foldr foldl reduce'), function (name) {\n            return function () {\n                var args = toArray(arguments);\n                args.unshift(this[ITEMS]);\n                // custom\n                return _[name].apply(_, args);\n            };\n        }), wrap(gapSplit('merge eq map filter pluck where whereNot'), function (name) {\n            // always responds with an array\n            return function () {\n                var args = toArray(arguments);\n                args.unshift(this[ITEMS]);\n                // unwrapper\n                // custom\n                return new Collection(_[name].apply(_, args));\n            };\n        })),\n        ret = _.exports({\n            eachCall: eachCall,\n            eachRevCall: eachRevCall,\n            closest: closest,\n            // map: map,\n            filter: filter,\n            reduce: foldl,\n            foldl: foldl,\n            foldr: foldr,\n            matches: matches,\n            add: add,\n            addAt: addAt,\n            addAll: addAll,\n            concatUnique: concatUnique,\n            removeAt: removeAt,\n            remove: remove,\n            removeAll: removeAll,\n            cycle: cycle,\n            uncycle: uncycle,\n            mamboWrap: internalMambo,\n            mambo: externalMambo,\n            concat: concat,\n            // listMerge: merge,\n            pluck: pluck,\n            where: where,\n            findWhere: findWhere,\n            findLastWhere: findLastWhere,\n            between: between,\n            eq: eq,\n            posit: posit,\n            range: range,\n            count: count,\n            countTo: countTo,\n            countFrom: countFrom,\n            whereNot: whereNot,\n            eachRev: eachRev,\n            duffRev: duffRev,\n            flatten: flatten\n        }),\n        interactWithById = function (fun, expecting) {\n            return function (one, two, three) {\n                var instance = this,\n                    bycategories = instance[BY_ID],\n                    passedCategory = arguments[LENGTH] === expecting,\n                    category = passedCategory ? one : ID,\n                    categoryHash = bycategories[category] = bycategories[category] || {},\n                    key = passedCategory ? two : one,\n                    thing = passedCategory ? three : two;\n                return fun(instance, categoryHash, category, key, thing, passedCategory);\n            };\n        },\n        Collection = factories.Model.extend('Collection', extend({\n            unwrap: unwrap,\n            range: recreateSelf(range),\n            flatten: recreateSelf(function () {\n                // return\n                return flatten.apply(null, this[ITEMS]);\n            }),\n            concat: recreateSelf(function () {\n                var args = [],\n                    base = this[ITEMS];\n                // this allows us to mix collections with regular arguments\n                return base.concat.apply(base, map(arguments, function (arg) {\n                    return Collection(arg)[ITEMS];\n                }));\n            }),\n            length: function () {\n                return this[ITEMS][LENGTH];\n            },\n            first: function () {\n                return this[ITEMS][0];\n            },\n            last: function () {\n                return this[ITEMS][this[LENGTH]() - 1];\n            },\n            index: function (number) {\n                return this[ITEMS][number || 0];\n            },\n            constructor: function (arr) {\n                var collection = this;\n                if (!isArray(arr) && isArrayLike(arr)) {\n                    arr = toArray(arr);\n                }\n                if (!isBlank(arr) && !isArrayLike(arr)) {\n                    arr = [arr];\n                }\n                collection[BY_ID] = {};\n                collection[ITEMS] = arr || [];\n                return collection;\n            },\n            toString: function () {\n                return stringify(this);\n            },\n            toJSON: function () {\n                // subtle distinction here\n                return map(this[ITEMS], function (item) {\n                    var ret;\n                    if (isObject(item) && isFunction(item.toJSON)) {\n                        ret = item.toJSON();\n                    } else {\n                        ret = item;\n                    }\n                    return ret;\n                });\n            },\n            join: function (delimiter) {\n                return this[ITEMS].join(delimiter);\n            },\n            get: interactWithById(function (instance, categoryHash, category, key) {\n                return categoryHash[key];\n            }, 2),\n            register: interactWithById(function (instance, categoryHash, category, key, newItem) {\n                categoryHash[key] = newItem;\n            }, 3),\n            unRegister: interactWithById(function (instance, categoryHash, category, key) {\n                var registeredItem = categoryHash[key];\n                if (registeredItem !== blank) {\n                    categoryHash[key] = blank;\n                }\n                return registeredItem;\n            }, 2),\n            swapRegister: interactWithById(function (instance, categoryHash, category, key, newItem) {\n                var registeredItem = categoryHash[key];\n                if (registeredItem !== blank) {\n                    categoryHash[key] = blank;\n                }\n                categoryHash[key] = newItem;\n                return registeredItem;\n            }, 3),\n            /**\n             * @description adds models to the children array\n             * @param {Object|Object[]} objs - object or array of objects to be passed through the model factory and pushed onto the children array\n             * @param {Object} [secondary] - secondary hash that is common among all of the objects being created. The parent property is automatically overwritten as the object that the add method was called on\n             * @returns {Object|Box} the object that was just created, or the object that the method was called on\n             * @name Box#add\n             * @func\n             */\n            mambo: function (fn) {\n                var collection = this;\n                externalMambo(collection[ITEMS], function () {\n                    fn(collection);\n                });\n                return collection;\n            }\n        }, wrappedCollectionMethods), !0);\n});","application.scope(function (app) {\n    var blank, _ = app._,\n        factories = _.factories,\n        gapSplit = _.gapSplit,\n        simpleObject = _.simpleObject,\n        isObject = _.isObject,\n        isString = _.isString,\n        isNum = _.isNum,\n        isFunction = _.isFunction,\n        each = _.each,\n        duff = _.duff,\n        isBlank = _.isBlank,\n        duffRev = _.duffRev,\n        push = _.push,\n        has = _.has,\n        map = _.map,\n        bind = _.bind,\n        find = _.find,\n        isInstance = _.isInstance,\n        camelCase = _.camelCase,\n        intendedObject = _.intendedObject,\n        toArray = _.toArray,\n        clone = _.clone,\n        once = _.once,\n        extend = _.extend,\n        remove = _.remove,\n        stringify = _.stringify,\n        isArrayLike = _.isArrayLike,\n        isArray = _.isArray,\n        upCase = _.upCase,\n        LENGTH = 'length',\n        PARENT = 'parent',\n        _EVENTS = '_events',\n        EVENT_REMOVE = '_removeEventList',\n        CURRENT_EVENTS = '_currentEventList',\n        _LISTENING_TO = '_listeningTo',\n        modifiedTriggerString = 'change:',\n        IMMEDIATE_PROP_IS_STOPPED = 'immediatePropagationIsStopped',\n        SERIALIZED_DATA = 'serializedData',\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        iterateOverObject = function (box, ctx, key, value, iterator, firstarg, allowNonFn) {\n            intendedObject(key, value, function (evnts, funs_) {\n                // only accepts a string or a function\n                var fn = isString(funs_) ? box[funs_] : funs_,\n                    splitevents = gapSplit(evnts);\n                if (!allowNonFn && !isFunction(fn)) {\n                    return splitevents;\n                }\n                return duff(splitevents, function (eventName) {\n                    var namespace = eventName.split(':')[0];\n                    iterator(box, eventName, {\n                        disabled: BOOLEAN_FALSE,\n                        namespace: namespace,\n                        name: eventName,\n                        handler: fn,\n                        ctx: ctx,\n                        origin: box\n                    }, firstarg);\n                });\n            });\n        },\n        // user friendly version\n        flattenMatrix = function (iterator, nameOrObjectIndex) {\n            return function () {\n                var names, box = this,\n                    args = toArray(arguments),\n                    handlersIndex = nameOrObjectIndex,\n                    list = args.splice(nameOrObjectIndex),\n                    nameOrObject = list[0];\n                if (!nameOrObjectIndex || args[0]) {\n                    iterateOverObject(box, args[handlersIndex + 1], nameOrObject, list[1], iterator, args[0]);\n                }\n                return box;\n            };\n        },\n        removeEventObject = function (box, arr, handler, ctx) {\n            var current = getCurrentEventList(box);\n            duffRev(arr, function (obj, idx, array) {\n                if ((!handler || obj.handler === handler) && (!ctx || obj.ctx === ctx)) {\n                    // because event triggers are always syncronous,\n                    // we can just wait until the dispatchEvent function is done\n                    if (current[LENGTH]) {\n                        getRemoveList(box).push(obj);\n                    } else {\n                        removeEvent(obj);\n                    }\n                }\n            });\n        },\n        removeEvent = function (evnt) {\n            var listeningTo, listening = evnt.listening;\n            remove(evnt.list, evnt);\n            // disconnect it from the list above it\n            evnt.list = blank;\n            // check to see if it was a listening type\n            if (listening) {\n                // if it was then decrement it\n                listening.count--;\n                if (!listening.count) {\n                    listeningTo = listening.listeningTo;\n                    listeningTo[listening.obj._listenId] = blank;\n                }\n            }\n        },\n        retreiveEventList = function (model, name) {\n            var internalevents = model[_EVENTS] = model[_EVENTS] || {};\n            return internalevents[name];\n        },\n        getRemoveList = function (model) {\n            var list = model[EVENT_REMOVE] = model[EVENT_REMOVE] = [];\n            return list;\n        },\n        getCurrentEventList = function (box) {\n            var list = box[CURRENT_EVENTS];\n            if (!list) {\n                list = box[CURRENT_EVENTS] = [];\n            }\n            return list;\n        },\n        attachEventObject = function (obj, name, eventObject) {\n            var events, list;\n            if (!obj) {\n                return;\n            }\n            eventObject.ctx = eventObject.ctx || eventObject.origin;\n            eventObject.fn = eventObject.fn || eventObject.handler;\n            eventObject.fn = bind(eventObject.fn, eventObject.ctx);\n            events = obj[_EVENTS] = obj[_EVENTS] || {};\n            list = events[name] = events[name] || [];\n            // attached so event can remove itself\n            eventObject.list = list;\n            list.push(eventObject);\n        },\n        extrapolateContext = function (fn) {\n            return function () {\n                var args = toArray(arguments);\n                if (!args[2]) {\n                    args.push(this);\n                }\n                return fn.apply(this, args);\n            };\n        },\n        listenToWrap = function (fn) {\n            return function () {\n                var args = toArray(arguments);\n                if (!args[3]) {\n                    args.push(this);\n                }\n                args = _.cycle(args, 1);\n                return fn.apply(this, args);\n            };\n        },\n        unrollName = function (fn, expectsNameAt) {\n            return function () {\n                var args = toArray(arguments);\n                if (isString(args[expectsNameAt])) {\n                    args[expectsNameAt] = this[args[expectsNameAt]];\n                }\n                fn.apply(this, args);\n            };\n        },\n        retreiveListeningObject = function (thing, obj) {\n            var listeningTo, listening, thisId, id = obj._listenId;\n            if (!id) {\n                id = obj._listenId = _.uniqueId('l');\n            }\n            listeningTo = thing[_LISTENING_TO] || (thing[_LISTENING_TO] = {});\n            listening = listeningTo[id];\n            // This object is not listening to any other events on `obj` yet.\n            // Setup the necessary references to track the listening callbacks.\n            if (!listening) {\n                thisId = thing._listenId;\n                if (!thisId) {\n                    thisId = thing._listenId = _.uniqueId('l');\n                }\n                listening = listeningTo[id] = {\n                    obj: obj,\n                    objId: id,\n                    id: thisId,\n                    listeningTo: listeningTo,\n                    ctx: thing,\n                    count: 0\n                };\n            }\n            return listening;\n        },\n        ObjectEvent = factories.Model.extend('ObjectEvent', {\n            constructor: function (name, target, data) {\n                var evnt = this;\n                if (isInstance(data, Event)) {\n                    return data;\n                }\n                evnt.bubbles = BOOLEAN_FALSE;\n                evnt.dispatchChildren = BOOLEAN_FALSE;\n                evnt.dispatchTree = BOOLEAN_FALSE;\n                evnt.onMethodName = upCase(camelCase('on:' + name, ':'));\n                evnt.propagationIsStopped = evnt[IMMEDIATE_PROP_IS_STOPPED] = BOOLEAN_FALSE;\n                evnt.target = target;\n                evnt.name = name;\n                evnt.type = name.split(':')[0];\n                evnt.timestamp = _.now();\n                evnt.data(data);\n                evnt.originalStack = BOOLEAN_TRUE;\n                return evnt;\n            },\n            isStopped: function () {\n                return this.propagationIsStopped || this.immediatePropagationIsStopped;\n            },\n            data: function (arg) {\n                var ret = this[SERIALIZED_DATA];\n                if (arguments[LENGTH]) {\n                    ret = this[SERIALIZED_DATA] = _.parse(_.stringify(isBlank(arg) ? {} : arg));\n                }\n                this[SERIALIZED_DATA] = ret;\n                ret = this[SERIALIZED_DATA];\n                return ret;\n            },\n            get: function (key) {\n                return this[SERIALIZED_DATA][key];\n            },\n            set: function (key, value) {\n                var evnt = this;\n                intendedObject(key, value, function (key, value) {\n                    evnt[SERIALIZED_DATA][key] = value;\n                });\n                return this;\n            },\n            stopImmediatePropagation: function () {\n                this.stopPropagation();\n                this[IMMEDIATE_PROP_IS_STOPPED] = BOOLEAN_TRUE;\n            },\n            stopPropagation: function () {\n                this.propagationIsStopped = BOOLEAN_TRUE;\n            },\n            toJSON: function () {\n                return this.data(this.data());\n            },\n            toString: function () {\n                return stringify(this.toJSON());\n            },\n            preventDefault: function () {\n                this.defaultPrevented = BOOLEAN_TRUE;\n            },\n            action: function (fn) {\n                var evnt = this;\n                evnt._actions = evnt._actions || [];\n                evnt._actions.push(fn);\n                return evnt;\n            },\n            finished: function () {\n                var evnt = this;\n                duff(evnt._actions, function (fn) {\n                    fn(evnt);\n                });\n                evnt.originalStack = BOOLEAN_FALSE;\n            }\n        }),\n        bindOnce = function (box, name, obj) {\n            var fn = obj.handler;\n            obj.fn = _.once(function () {\n                box.off();\n                fn.apply(this, arguments);\n            });\n        },\n        listenToHandler = function (box, name, obj, target) {\n            var listeningObject = retreiveListeningObject(box, target);\n            preBindListeners(obj, listeningObject);\n            attachEventObject(target, name, obj);\n        },\n        onceHandler = function (box, name, obj) {\n            bindOnce(box, name, obj);\n            attachEventObject(box, name, obj);\n        },\n        preBindListeners = function (obj, listening) {\n            listening.count++;\n            obj.listening = listening;\n        },\n        listenToOnceHandler = function (box, name, obj, extra) {\n            bindOnce(box, name, obj);\n            listenToHandler(box, name, obj, extra);\n        },\n        // makeValidEvent = ,\n        getEventList = function (box, name) {\n            var events = box[_EVENTS] = box[_EVENTS] || {};\n            return events[name] || [];\n        },\n        overrideEventCreation = function (obj) {\n            return obj && (obj.bubbles || obj.dispatchChildren || opts.dispatchTree);\n        },\n        Events = factories.Model.extend('Events', {\n            /**\n             * @description attach event handlers to the Box event loop\n             * @func\n             * @name Box#on\n             * @param {String} str - event name to listen to\n             * @param {Function|String} fn - event handler or string corresponding to handler on prototype to use for handler\n             * @param {Object} ctx - context that the handler will run in\n             * @returns {Box} instance\n             */\n            initialize: _.noop,\n            constructor: function (opts) {\n                var model = this;\n                model._makeValid();\n                model.on(model.events);\n                model.initialize(opts);\n                return model;\n            },\n            _makeValid: function () {\n                var model = this;\n                model[CURRENT_EVENTS] = model[CURRENT_EVENTS] || [];\n                model[_EVENTS] = model[_EVENTS] || {};\n                model[EVENT_REMOVE] = model[EVENT_REMOVE] || [];\n                return model;\n            },\n            on: flattenMatrix(attachEventObject, 0),\n            once: flattenMatrix(onceHandler, 0),\n            listenTo: flattenMatrix(listenToHandler, 1),\n            /**\n             * @description attaches an event handler to the events object, and takes it off as soon as it runs once\n             * @func\n             * @name Box#once\n             * @param {String} string - event name that will be triggered\n             * @param {Function} fn - event handler that will run only once\n             * @param {Object} ctx - context that will be applied to the handler\n             * @returns {Box} instance\n             */\n            listenToOnce: flattenMatrix(listenToOnceHandler, 1),\n            /**\n             * @description remove event objects from the _events object\n             * @param {String|Function} type - event type or handler. If a match is found, then the event object is removed\n             * @param {Function} handler - event handler to be matched and removed\n             * @func\n             * @name Box#off\n             * @returns {Box} instance\n             */\n            wipeEvents: function () {\n                var box = this;\n                each(box[_EVENTS], function (array, key, obj) {\n                    duffRev(array, removeEvent);\n                });\n                return box;\n            },\n            off: function (name_, fn_, ctx_) {\n                var currentEventList, currentObj, box = this,\n                    name = name_;\n                box._makeValid();\n                if (arguments[LENGTH]) {\n                    if (!name) {\n                        each(box[_EVENTS], function (list, name) {\n                            removeEventObject(box, list, fn_, ctx_);\n                        });\n                    } else {\n                        iterateOverObject(box, isObject(name_) ? fn_ : ctx_, name, fn_, function (box, name, obj) {\n                            removeEventObject(box, !name || box[_EVENTS][name], obj.handler, obj.ctx);\n                        });\n                    }\n                } else {\n                    currentEventList = getCurrentEventList(box);\n                    currentObj = currentEventList[currentEventList[LENGTH] - 1];\n                    if (currentObj) {\n                        removeEventObject(box, [currentObj]);\n                    }\n                }\n            },\n            stopListening: function (obj, name, callback) {\n                var ids, listening, stillListening = 0,\n                    origin = this,\n                    listeningTo = origin[_LISTENING_TO];\n                if (listeningTo && (!obj || obj._listenId)) {\n                    duff(obj ? [obj._listenId] : _.keys(listeningTo), function (id) {\n                        var listening = listeningTo[id];\n                        if (listening) {\n                            listening.obj.off(name, callback);\n                        }\n                        stillListening += listeningTo[id] ? 1 : 0;\n                    });\n                    if (!stillListening && !find(ids, function (id, key) {\n                        return listeningTo[id];\n                    })) {\n                        origin[_LISTENING_TO] = blank;\n                    }\n                }\n                return origin;\n            },\n            /**\n             * @description triggers a event loop\n             * @func\n             * @name Box#fire\n             * @param {String} name of the event loop to be triggered\n             * @returns {Box} object instance the method is being called on\n             */\n            dispatchEvents: function (names, data, eventOptions) {\n                var box = this;\n                duff(gapSplit(names), function (str) {\n                    box.dispatchEvent(str, data, eventOptions);\n                });\n                return box;\n            },\n            _eventDispatcher: function (evnt) {\n                var box = this,\n                    valid = box._makeValid(),\n                    name = evnt.name,\n                    currentEventArray = getCurrentEventList(box),\n                    list = getEventList(box, name),\n                    ret = isFunction(box[evnt.methodName]) && box[evnt.methodName](evnt),\n                    anotherRet = !evnt[IMMEDIATE_PROP_IS_STOPPED] && !!find(list, function (obj) {\n                        var gah;\n                        currentEventArray.push(obj);\n                        obj.fn(evnt);\n                        gah = currentEventArray.pop();\n                        return evnt[IMMEDIATE_PROP_IS_STOPPED];\n                    });\n                if (!currentEventArray[LENGTH] && box[EVENT_REMOVE][LENGTH] && box[EVENT_REMOVE][LENGTH]) {\n                    duffRev(box[EVENT_REMOVE], removeEvent);\n                    box[EVENT_REMOVE] = [];\n                }\n                return box;\n            },\n            _createEvent: function (name, data) {\n                return new ObjectEvent(name, this, data);\n            },\n            dispatchEvent: function (name, data, evnt_) {\n                var box = this,\n                    methodName = upCase(camelCase('on:' + name, ':')),\n                    evnt = evnt_ || box._createEvent(name, data);\n                box._eventDispatcher(evnt);\n                evnt.finished();\n                return evnt;\n            }\n        }, !0);\n});","application.scope(function (app) {\n    var blank, _ = app._,\n        factories = _.factories,\n        Events = factories.Events,\n        result = _.result,\n        isFunction = _.isFunction,\n        isObject = _.isObject,\n        intendedObject = _.intendedObject,\n        PARENT = 'parent',\n        NAME = 'name',\n        basicData = function (basic) {\n            return function () {\n                return basic;\n            };\n        },\n        messengerHash = {},\n        attachToHash = function (key, obj) {\n            if (messengerHash[key]) {\n                messengerHash[key].destroy();\n            }\n            obj[NAME] = key;\n            messengerHash[key] = obj;\n        },\n        removeFromHash = function (obj) {\n            messengerHash[obj[NAME]] = blank;\n        },\n        Messenger = factories.Events.extend('Messenger', {\n            constructor: function (parent) {\n                var ret, scopedHash = {};\n                this._getHash = function (key, arg) {\n                    return result(scopedHash, key, arg);\n                };\n                this._setHash = function (key, val) {\n                    scopedHash[key] = val;\n                };\n                ret = isObject(parent) ? this.attachParent(parent) : attachToHash(key, this);\n                this.on('before:destroy', function () {\n                    var obj = this;\n                    if (obj[NAME]) {\n                        removeFromHash(obj);\n                    }\n                });\n                return Events.constructor.call(this);\n            },\n            attachParent: function (parent) {\n                this[PARENT] = parent;\n                parent.message = this;\n                return this;\n            },\n            request: function (key, arg) {\n                return this._getHash(key, arg);\n            },\n            reply: function (key, handler) {\n                var messenger = this;\n                intendedObject(key, handler, function (key, handler_) {\n                    var handler = handler_;\n                    if (!isFunction(handler_)) {\n                        handler = basicData(handler_);\n                    }\n                    messenger._setHash(key, bind(handler, this[PARENT] || {}));\n                });\n                return messenger[PARENT];\n            }\n        }, true);\n    factories.Messenger(app);\n});","application.scope(function (app) {\n    var blank, _ = app._,\n        factories = _.factories,\n        Collection = factories.Collection,\n        Events = factories.Events,\n        gapSplit = _.gapSplit,\n        isObject = _.isObject,\n        isString = _.isString,\n        isNumber = _.isNumber,\n        isEqual = _.isEqual,\n        isBlank = _.isBlank,\n        isFunction = _.isFunction,\n        each = _.each,\n        duff = _.duff,\n        find = _.find,\n        duffRev = _.duffRev,\n        push = _.push,\n        has = _.has,\n        map = _.map,\n        result = _.result,\n        toArray = _.toArray,\n        remove = _.remove,\n        clone = _.clone,\n        once = _.once,\n        parse = _.parse,\n        extend = _.extend,\n        listDrop = _.remove,\n        stringify = _.stringify,\n        isInstance = _.isInstance,\n        isArrayLike = _.isArrayLike,\n        upCase = _.upCase,\n        camelCase = _.camelCase,\n        isArray = _.isArray,\n        intendedObject = _.intendedObject,\n        uniqueId = _.uniqueId,\n        BOOLEAN_FALSE = !1,\n        BOOLEAN_TRUE = !0,\n        ID = 'id',\n        SORT = 'sort',\n        ADDED = 'added',\n        UNWRAP = 'unwrap',\n        REMOVED = 'removed',\n        LENGTH = 'length',\n        PARENT = 'parent',\n        DESTROY = 'destroy',\n        BEFORE_COLON = 'before:',\n        INTERNAL_EVENTS = '_events',\n        ATTRIBUTES = 'attributes',\n        STOP_LISTENING = 'stopListening',\n        DISPATCH_EVENT = 'dispatchEvent',\n        EVENT_REMOVE = '_removeEventList',\n        ATTRIBUTE_HISTORY = '_attributeHistory',\n        _DELEGATED_CHILD_EVENTS = '_delegatedParentEvents',\n        _PARENT_DELEGATED_CHILD_EVENTS = '_parentDelgatedChildEvents',\n        CHILD = 'child',\n        CHILDREN = CHILD + 'ren',\n        CHANGE = 'change',\n        CHANGE_COUNTER = '_changeCounter',\n        PREVIOUS_ATTRIBUTES = '_previousAttributes',\n        /**\n         * @class Box\n         * @description event and attribute extensor object that creates the Box Constructor and convenience method at _.Box\n         * @augments Model\n         */\n        Container = factories.Events.extend('Container', {\n            // this id prefix is nonsense\n            // define the actual key\n            uniqueKey: 'cid',\n            idAttribute: ID,\n            constructor: function (attributes, secondary) {\n                var model = this;\n                model[model.uniqueKey] = model[model.uniqueKey] = uniqueId(model.uniqueKey);\n                extend(model, secondary);\n                model.reset(attributes);\n                Events.constructor.apply(this, arguments);\n                return model;\n            },\n            _reset: function (attributes_) {\n                var childModel, children, model = this,\n                    _altered = model._altered = {},\n                    // automatically checks to see if the attributes are a string\n                    attributes = parse(attributes_) || {},\n                    // default attributes\n                    attrs = result(model, 'defaults', attributes),\n                    // build new attributes\n                    newAttributes = extend(attrs, attributes),\n                    // get the id\n                    idAttr = result(model, 'idAttribute', newAttributes),\n                    // stale attributes\n                    ret = model[ATTRIBUTES] || {},\n                    history = model[ATTRIBUTE_HISTORY] = {};\n                // set id and let parent know what your new id is\n                this[DISPATCH_EVENT](BEFORE_COLON + 'reset');\n                model._setId(model.id || newAttributes[idAttr] || uniqueId());\n                model[PREVIOUS_ATTRIBUTES] = {};\n                // swaps attributes hash\n                model[ATTRIBUTES] = newAttributes;\n                // let everything know that it is changing\n                model[DISPATCH_EVENT]('reset');\n                return ret;\n            },\n            /**\n             * @description remove attributes from the Box object. Does not completely remove from object with delete, but instead simply sets it to blank / undefined\n             * @param {String} attr - property string that is on the attributes object\n             * @returns {Box} instance the method was called on\n             * @func\n             * @name Box#unset\n             */\n            unset: function (attrs) {\n                var attrObj = this[ATTRIBUTES];\n                duff(gapSplit(attrs), function (attr) {\n                    attrObj[attr] = blank;\n                });\n                return this;\n            },\n            /**\n             * @description returns attribute passed into\n             * @param {String} attr - property string that is being gotten from the attributes object\n             * @returns {*} value that is present on the attributes object\n             * @func\n             * @name Box#get\n             */\n            get: function (attr) {\n                return this[ATTRIBUTES][attr];\n            },\n            /**\n             * @func\n             * @param {String} attr - property string that is being gotten from the attributes object\n             * @returns {Boolean} evaluation of whether or not the Box instance has a value at that attribute key\n             * @description checks to see if the current attribute is on the attributes object as anything other an undefined\n             * @name Box#has\n             */\n            has: function (attrs) {\n                var box = this,\n                    attributes = box[ATTRIBUTES];\n                return !find(gapSplit(attrs), function (attr) {\n                    return attributes[attr] === blank;\n                });\n            },\n            /**\n             * @description collects a splat of arguments and condenses them into a single object. Object is then extended onto the attributes object and any items that are different will be fired as events\n             * @param {...*} series - takes a series of key value pairs. can be mixed with objects. All key value pairs will be placed on a new object, which is to be passed into the function below\n             * @func\n             * @name Box#set\n             * @returns {Box} instance\n             */\n            _set: function (key, newValue) {\n                var model = this,\n                    didChange = BOOLEAN_FALSE,\n                    attrs = model[ATTRIBUTES],\n                    history = model[ATTRIBUTE_HISTORY],\n                    oldValue = attrs[key],\n                    previousAttrsObject = model[PREVIOUS_ATTRIBUTES] = model[PREVIOUS_ATTRIBUTES] || {};\n                if (!isEqual(oldValue, newValue)) {\n                    previousAttrsObject[key] = oldValue;\n                    history[key] = oldValue;\n                    attrs[key] = newValue;\n                    didChange = BOOLEAN_TRUE;\n                }\n                return didChange;\n            },\n            digester: function (fn) {\n                var ret, model = this;\n                model[CHANGE_COUNTER] = model[CHANGE_COUNTER] || 0;\n                ++model[CHANGE_COUNTER];\n                ret = fn();\n                --model[CHANGE_COUNTER];\n                // this event should only ever exist here\n                if (!model[CHANGE_COUNTER]) {\n                    model[DISPATCH_EVENT]('digest', model[PREVIOUS_ATTRIBUTES]);\n                    model[PREVIOUS_ATTRIBUTES] = {};\n                }\n                return ret;\n            },\n            set: function (key, value) {\n                var changedList = [],\n                    model = this,\n                    compiled = {};\n                intendedObject(key, value, function (key, value) {\n                    if (model._set(key, value)) {\n                        changedList.push(key);\n                        compiled[key] = value;\n                    }\n                });\n                if (!changedList[LENGTH]) {\n                    // do not digest... this time\n                    return model;\n                }\n                model.digester(function () {\n                    duff(changedList, function (name) {\n                        model[DISPATCH_EVENT](CHANGE + ':' + name);\n                    });\n                    model[DISPATCH_EVENT](CHANGE, compiled);\n                });\n                return model;\n            },\n            /**\n             * @description basic json clone of the attributes object\n             * @func\n             * @name Box#toJSON\n             * @returns {Object} json clone of the attributes object\n             */\n            toJSON: function () {\n                // does not prevent circular dependencies.\n                // swap this out for something else if you want\n                // to prevent circular dependencies\n                return clone(this[ATTRIBUTES]);\n            },\n            /**\n             * @description stringified version of attributes object\n             * @func\n             * @name Box#stringify\n             * @returns {String} stringified json version of\n             */\n            toString: function () {\n                return stringify(this);\n            },\n            _setId: function (id_) {\n                var model = this,\n                    id = id_ === blank ? uniqueId(BOOLEAN_FALSE) : id_ + '';\n                model.id = id;\n            },\n            reset: function (attrs) {\n                this._reset(attrs);\n                return this;\n            }\n        }, BOOLEAN_TRUE),\n        ModelMaker = function (attributes, secondary) {\n            return new Box(attributes, secondary);\n        },\n        constuctor = ModelMaker.constructor = Box,\n        Box = factories.Container.extend('Box', {\n            /**\n             * @description constructor function for the Box Object\n             * @name Box#constructor\n             * @func\n             */\n            constructor: function (attributes, secondary) {\n                var model = this;\n                model._ensureChildren();\n                Container.constructor.apply(model, arguments);\n                return model;\n            },\n            _ensureChildren: function () {\n                this[CHILDREN] = Collection();\n            },\n            _gatherChildren: function () {\n                return [];\n            },\n            /**\n             * @description resets the box's attributes to the object that is passed in\n             * @name Box#reset\n             * @func\n             * @param {Object} attributes - non circular hash that is extended onto what the defaults object produces\n             * @returns {Box} instance the method was called on\n             */\n            // _registerChild: function (category, id, model) {\n            //     var parent = this;\n            //     if (id !== blank) {\n            //         parent[CHILDREN].register(category, id, model);\n            //     }\n            // },\n            // _unRegisterChild: function (category, id) {\n            //     var parent = this;\n            //     if (id !== blank) {\n            //         parent[CHILDREN].unRegister(category, id);\n            //     }\n            // },\n            resetChildren: function (newChildren) {\n                var length, child, box = this,\n                    children = box[CHILDREN],\n                    arr = children[UNWRAP]();\n                // this can be made far more efficient\n                while (arr[LENGTH]) {\n                    child = arr[0];\n                    length = arr[LENGTH];\n                    if (child) {\n                        result(child, DESTROY);\n                    }\n                    // if it didn't remove itself,\n                    // then you should remove it here\n                    // this gets run if the child is a basic data type\n                    if (arr[0] === child && arr[LENGTH] === length) {\n                        remove(arr, child);\n                    }\n                }\n                box.add(newChildren);\n                return box;\n            },\n            // registers and actually adds child to hash\n            _addToHash: function (newModel, where) {\n                var parent = this,\n                    children = this[where || CHILDREN];\n                // add to collection\n                children.add(newModel);\n                // register with parent\n                children.register(newModel.id, newModel);\n                children.register(newModel.uniqueKey, newModel[newModel.uniqueKey], newModel);\n            },\n            // ties child events to new child\n            _delegateChildEvents: function (model) {\n                var parent = this,\n                    childEvents = _.result(parent, CHILD + 'Events');\n                if (model && childEvents) {\n                    model[_PARENT_DELEGATED_CHILD_EVENTS] = childEvents;\n                    parent.listenTo(model, childEvents);\n                }\n            },\n            // ties child events to new child\n            _unDelegateChildEvents: function (model) {\n                if (model && model[_PARENT_DELEGATED_CHILD_EVENTS] && this[STOP_LISTENING]) {\n                    this[STOP_LISTENING](model, model[_PARENT_DELEGATED_CHILD_EVENTS]);\n                }\n            },\n            _delegateParentEvents: function (model) {\n                var parent = model[PARENT],\n                    parentEvents = _.result(model, 'parentEvents');\n                if (parent && parentEvents) {\n                    model[_DELEGATED_CHILD_EVENTS] = parentEvents;\n                    model.listenTo(parent, parentEvents);\n                }\n            },\n            // ties child events to new child\n            _unDelegateParentEvents: function (model) {\n                var parent = this;\n                if (model[STOP_LISTENING] && model[_DELEGATED_CHILD_EVENTS]) {\n                    model[STOP_LISTENING](parent, model[_DELEGATED_CHILD_EVENTS]);\n                }\n            },\n            _isChildType: function (child) {\n                return isInstance(child, this.Model);\n            },\n            // this one forcefully adds\n            _add: function (model) {\n                var parent = this,\n                    children = parent[CHILDREN],\n                    evt = model[DISPATCH_EVENT] && model[DISPATCH_EVENT](BEFORE_COLON + ADDED);\n                // let the child know it's about to be added\n                // (tied to it's parent via events)\n                // unties boxes\n                parent._remove(model);\n                // explicitly tie to parent\n                model[PARENT] = parent;\n                // attach events from parent\n                parent._addToHash(model);\n                // ties boxes together\n                parent._delegateParentEvents(model);\n                parent._delegateChildEvents(model);\n                evt = model[DISPATCH_EVENT] && model[DISPATCH_EVENT](ADDED);\n                // notify that you were added\n                return model;\n            },\n            Model: ModelMaker,\n            // public facing version filters\n            add: function (objs_, secondary_) {\n                var childAdded, parent = this,\n                    children = parent[CHILDREN],\n                    secondary = extend(result(parent, CHILD + 'Options'), secondary_ || {}),\n                    list = Collection(objs_);\n                // unwrap it if you were passed a collection\n                if (!parent.Model || !list[LENGTH]()) {\n                    return list[UNWRAP]();\n                }\n                list = list.foldl(function (memo, obj) {\n                    var isChildType = parent._isChildType(obj),\n                        // create a new model\n                        // call it with new in case they use a constructor\n                        newModel = isChildType ? obj : new parent.Model(obj, secondary),\n                        // find by the newly created's id\n                        foundModel = children.get(newModel.id);\n                    if (foundModel) {\n                        // update the old\n                        foundModel.set(obj);\n                        newModel = foundModel;\n                    } else {\n                        // add the new\n                        childAdded = BOOLEAN_TRUE;\n                        parent._add(newModel);\n                    }\n                    memo.push(newModel);\n                    return memo;\n                }, []);\n                if (childAdded) {\n                    parent[DISPATCH_EVENT](CHILD + ':' + ADDED);\n                }\n                return list;\n            },\n            _removeFromHash: function (child) {\n                var parent = this,\n                    children = parent[CHILDREN];\n                if (!children || !child) {\n                    return;\n                }\n                // remove the child from the children hash\n                children.remove(child);\n                parent[CHILDREN].unRegister(ID, child.id);\n                // unregister from the child hash keys\n                parent[CHILDREN].unRegister(child.uniqueKey, child[child.uniqueKey]);\n            },\n            // only place that we mention parents\n            _collectParents: function () {\n                var eventr = this,\n                    parents = [],\n                    parent = eventr[PARENT];\n                while (parent) {\n                    if (isInstance(parent, Events)) {\n                        parents.push(parent);\n                    }\n                    parent = parent[PARENT];\n                }\n                return parents;\n            },\n            // has to completely replace previous event dispatcher\n            dispatchEvent: function (name_, data, evnt_) {\n                var origin = this,\n                    name = (evnt_ && evnt_.methodName) || name_,\n                    methodName = (evnt_ && evnt_.methodName) || upCase(camelCase('on:' + name, ':')),\n                    childMethodName = upCase(camelCase('on:bubble:' + name, ':')),\n                    // onMethod = isFunction(origin[methodName]),\n                    evnt = evnt_ || origin._createEvent(name, data),\n                    parents = origin._collectParents(),\n                    i = parents[LENGTH] - 1;\n                // should all be BOOLEAN_TRUE the first time around\n                while (origin && origin._eventDispatcher && !evnt.isStopped()) {\n                    origin._eventDispatcher(evnt);\n                    origin = !evnt.isStopped() && evnt.bubbles && origin[PARENT];\n                }\n                evnt.finished();\n                return evnt;\n            },\n            _remove: function (model) {\n                // cache the parent\n                var parent = this;\n                // let everyone know that this object is about to be removed\n                model[DISPATCH_EVENT](BEFORE_COLON + REMOVED);\n                // notify the child that the remove pipeline is starting\n                // remove the parent events\n                parent._unDelegateParentEvents(model);\n                // have parent remove it's child events\n                parent._unDelegateChildEvents(model);\n                // attach events from parent\n                parent._removeFromHash(model);\n                // void out the parent member tied directly to the model\n                model[PARENT] = blank;\n                // let everyone know that you've offically separated\n                model[DISPATCH_EVENT](REMOVED);\n                // notify the child that the remove pipeline is done\n                return model;\n            },\n            remove: function (idModel_) {\n                var parent = this,\n                    children = parent[CHILDREN],\n                    retList = Collection(),\n                    args = toArray(arguments).splice(1),\n                    idModel = idModel_;\n                if (!isObject(idModel)) {\n                    // it's a string\n                    idModel = parent[CHILDREN].get(ID, idModel + '');\n                }\n                if (!idModel || !isObject(idModel)) {\n                    return retList;\n                }\n                if (isInstance(idModel, Collection)) {\n                    idModel = idModel[UNWRAP]();\n                }\n                if (!isArray(idModel)) {\n                    idModel = [idModel];\n                }\n                duff(idModel, function (model) {\n                    parent._remove(model);\n                    retList.add(model);\n                });\n                if (retList[LENGTH]()) {\n                    parent[DISPATCH_EVENT](CHILD + ':' + REMOVED);\n                }\n                return retList;\n            },\n            /**\n             * @description removes pointers from parent\n             * @func\n             * @name Box#destroy\n             * @returns {Box} instance\n             */\n            destroy: function () {\n                var removeRet, box = this;\n                // notify things like parent that it's about to destroy itself\n                box[DISPATCH_EVENT](BEFORE_COLON + 'destroy');\n                // destroys it's children\n                box.resetChildren();\n                // removes all parent / parent's child listeners\n                removeRet = box[PARENT] && box[PARENT].remove(box);\n                // stop listening to other views\n                box[DISPATCH_EVENT](DESTROY);\n                // stops listening to everything\n                box[STOP_LISTENING]();\n                // takes off all other event handlers\n                box.wipeEvents();\n                return box;\n            },\n            /**\n             * @description basic sort function\n             * @param {Function|String} comparator - argument to sort children against\n             * @returns {Box} instance\n             * @func\n             * @name Box#sort\n             */\n            sort: function (comparator_) {\n                var compString, isReversed, model = this,\n                    children = model[CHILDREN],\n                    comparator = comparator_ || result(model, 'comparator');\n                if (isString(comparator)) {\n                    isReversed = comparator[0] === '!';\n                    compString = comparator;\n                    if (isReversed) {\n                        compString = comparator.slice(1);\n                    }\n                    comparator = function (a, b) {\n                        var val_, val_A = a.get(compString),\n                            val_B = b.get(compString);\n                        if (isReversed) {\n                            val_ = val_B - val_A;\n                        } else {\n                            val_ = val_A - val_B;\n                        }\n                        return val_;\n                    };\n                }\n                model[DISPATCH_EVENT](BEFORE_COLON + SORT, model);\n                children[SORT](comparator);\n                model[DISPATCH_EVENT](SORT, model);\n                return model;\n            }\n        }, BOOLEAN_TRUE);\n});","application.scope(function (app) {\n    var blank, _ = app._,\n        factories = _.factories,\n        Box = factories.Box,\n        Collection = factories.Collection,\n        isFunction = _.isFunction,\n        extend = _.extend,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        PARENT = 'parent',\n        STOP = 'stop',\n        START = 'start',\n        _EXTRA_MODULE_ARGS = '_extraModuleArgs',\n        startableMethods = {\n            start: function (evnt) {\n                var startable = this;\n                if (!startable.started) {\n                    startable.dispatchEvent('before:' + START, evnt);\n                    startable.started = BOOLEAN_TRUE;\n                    startable.dispatchEvent(START, evnt);\n                }\n                return startable;\n            },\n            stop: function (evnt) {\n                var startable = this;\n                if (startable.started) {\n                    startable.dispatchEvent('before:' + STOP, evnt);\n                    startable.started = BOOLEAN_FALSE;\n                    startable.dispatchEvent(STOP, evnt);\n                }\n                return startable;\n            },\n            toggle: function () {\n                var startable = this;\n                if (startable.started) {\n                    startable[STOP](evnt);\n                } else {\n                    startable[START](evnt);\n                }\n                return startable;\n            }\n        },\n        Startable = factories.Box.extend('Startable', startableMethods, BOOLEAN_TRUE),\n        doStart = function (e) {\n            if (this.get('startWithParent')) {\n                this[START](e);\n            }\n        },\n        doStop = function (e) {\n            if (this.get('stopWithParent')) {\n                this[STOP](e);\n            }\n        },\n        // moduleHandler = ,\n        // moduleRunner = ,\n        moduleMethods = extend({}, startableMethods, {\n            // idAttribute: 'name',\n            module: function (name_, fn) {\n                var module, modules, attrs, parentIsModule, nametree, parent = this,\n                    originalParent = parent,\n                    name = name_,\n                    globalname = name,\n                    namespace = name.split('.');\n                while (namespace.length > 1) {\n                    parent = parent.module(namespace[0]);\n                    namespace.shift();\n                }\n                modules = parent.modules;\n                name = namespace.join('.');\n                module = parent.modules.get(name);\n                if (!module) {\n                    parentIsModule = _.isInstance(parent, Module);\n                    if (parentIsModule) {\n                        namespace.unshift(globalname);\n                    }\n                    namespace = namespace.join('.');\n                    module = Module({\n                        id: name,\n                        globalname: namespace\n                    }, {\n                        application: app,\n                        parent: parent\n                    });\n                    if (module.topLevel()) {\n                        modules.add(module);\n                    } else {\n                        parent.add(module);\n                    }\n                    modules.register(name, module);\n                    app.modules.register(globalname, module);\n                }\n                if (!module.hasInitialized && isFunction(fn)) {\n                    module.hasInitialized = BOOLEAN_TRUE;\n                    module.handler(fn);\n                }\n                return module;\n            },\n            run: function (fn) {\n                var module = this;\n                fn.apply(module, module.createArguments());\n                return module;\n            },\n            parentEvents: function () {\n                return {\n                    start: doStart,\n                    stop: doStop\n                };\n            },\n            exports: function (obj) {\n                extend(BOOLEAN_TRUE, this.get('exports'), obj);\n                return this;\n            },\n            createArguments: function () {\n                return [this].concat(this.application.createArguments());\n            },\n            constructor: function (attrs, opts) {\n                var module = this;\n                module.application = opts.application;\n                module.handlers = Collection();\n                factories.Messenger(this);\n                module.modules = Collection();\n                Box.constructor.apply(this, arguments);\n                return module;\n            },\n            defaults: function () {\n                return {\n                    startWithParent: BOOLEAN_TRUE,\n                    stopWithParent: BOOLEAN_TRUE,\n                    exports: {}\n                };\n            },\n            topLevel: function () {\n                return this.application === this[PARENT];\n            },\n            childOptions: function () {\n                return {\n                    application: this.application,\n                    parent: this\n                };\n            },\n            handler: function (fn) {\n                var module = this;\n                module.handlers.push(fn);\n                module.run(fn);\n                return module;\n            }\n        }),\n        Module = factories.Box.extend('Module', moduleMethods, BOOLEAN_TRUE),\n        appextendresult = app.extend(extend({}, factories.Events.constructor.prototype, moduleMethods, {\n            _extraModuleArgs: [],\n            children: Collection(),\n            // module: moduleHandler,\n            modules: Collection(),\n            /**\n             * @func\n             * @name Specless#baseModuleArguments\n             * @returns {Array} list of base arguments to apply to submodules\n             */\n            baseModuleArguments: function () {\n                var app = this;\n                return [app, app._, app._ && app._.factories];\n            },\n            /**\n             * @func\n             * @name Specless#addModuleArgs\n             * @param {Array} arr - list of arguments that will be added to the extraModule args list\n             * @returns {Specless} instance\n             */\n            addModuleArgs: function (arr) {\n                var app = this;\n                app._.addAll(app[_EXTRA_MODULE_ARGS], arr);\n                return app;\n            },\n            /**\n             * @func\n             * @name Specless#removeModuleArgs\n             * @param {Array} arr - list of objects or functions that will be removed from the extraModuleArgs\n             * @returns {Specless} instance\n             */\n            removeModuleArgs: function (arr) {\n                this.utils.removeAll(this[_EXTRA_MODULE_ARGS], arr);\n                return this;\n            },\n            /**\n             * @func\n             * @name Specless#createArguments\n             * @returns {Object[]}\n             */\n            createArguments: function () {\n                return this.baseModuleArguments().concat(this[_EXTRA_MODULE_ARGS]);\n            },\n            require: function (modulename) {\n                var module = this.module(modulename);\n                return module.getExports();\n            }\n        }));\n});","application.scope().module('Looper', function (module, app, _, factories) {\n    'use strict';\n    var blank, x = 0,\n        lastTime = 0,\n        LENGTH = 'length',\n        isFunction = _.isFunction,\n        isNumber = _.isNumber,\n        pI = _.pI,\n        posit = _.posit,\n        nowish = _.now,\n        gapSplit = _.gapSplit,\n        win = window,\n        vendors = gapSplit('ms moz webkit o'),\n        REQUEST_ANIMATION_FRAME = 'requestAnimationFrame',\n        allLoopers = [],\n        runningLoopers = [],\n        bind = _.bind,\n        duff = _.duff,\n        remove = _.remove,\n        removeAll = _.removeAll,\n        duffRev = _.duffRev,\n        extend = _.extend,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        running = BOOLEAN_FALSE,\n        setup = function () {\n            running = BOOLEAN_TRUE;\n            win[REQUEST_ANIMATION_FRAME](function (time) {\n                duff(runningLoopers, function (looper) {\n                    looper.run(time);\n                });\n                teardown();\n            });\n        },\n        teardown = function () {\n            duffRev(runningLoopers, function (looper, idx) {\n                if (looper.halted() || looper.stopped() || looper.destroyed() || !looper.length()) {\n                    runningLoopers.splice(idx, 1);\n                }\n            });\n            running = BOOLEAN_FALSE;\n            if (runningLoopers[LENGTH]) {\n                setup();\n            }\n        },\n        add = function (looper) {\n            allLoopers.push(looper);\n        },\n        start = function (looper) {\n            if (!posit(runningLoopers, looper)) {\n                runningLoopers.push(looper);\n            }\n            if (!running) {\n                setup();\n            }\n        },\n        shim = (function () {\n            for (; x < vendors[LENGTH] && !win[REQUEST_ANIMATION_FRAME]; ++x) {\n                win[REQUEST_ANIMATION_FRAME] = win[vendors[x] + 'RequestAnimationFrame'];\n                win.cancelAnimationFrame = win[vendors[x] + 'CancelAnimationFrame'] || win[vendors[x] + 'CancelRequestAnimationFrame'];\n            }\n            if (!win[REQUEST_ANIMATION_FRAME]) {\n                win[REQUEST_ANIMATION_FRAME] = function (callback) {\n                    var currTime = new Date().getTime(),\n                        timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n                        id = win.setTimeout(function () {\n                            callback(currTime + timeToCall);\n                        }, timeToCall);\n                    lastTime = currTime + timeToCall;\n                    return id;\n                };\n            }\n            if (!win.cancelAnimationFrame) {\n                win.cancelAnimationFrame = function (id) {\n                    win.clearTimeout(id);\n                };\n            }\n        }()),\n        Looper = factories.Model.extend('Looper', {\n            constructor: function (_runner) {\n                var fns, stopped = BOOLEAN_FALSE,\n                    halted = BOOLEAN_FALSE,\n                    destroyed = BOOLEAN_FALSE,\n                    running = BOOLEAN_FALSE,\n                    looper = this,\n                    counter = 0,\n                    fnList = [],\n                    addList = [],\n                    removeList = [],\n                    combineAdd = function () {\n                        if (addList[LENGTH]) {\n                            fnList = fnList.concat(addList);\n                            addList = [];\n                        }\n                    };\n                extend(looper, {\n                    length: function () {\n                        return fnList[LENGTH];\n                    },\n                    destroy: function () {\n                        destroyed = BOOLEAN_TRUE;\n                        remove(allLoopers, this);\n                        return this.halt();\n                    },\n                    destroyed: function () {\n                        return destroyed;\n                    },\n                    running: function () {\n                        return !!running;\n                    },\n                    run: function () {\n                        var tween = this,\n                            removeLater = [],\n                            _nowish = nowish();\n                        if (halted || stopped) {\n                            return;\n                        }\n                        combineAdd();\n                        duff(fnList, function (fnObj) {\n                            if (!posit(removeList, fnObj)) {\n                                if (!fnObj.disabled && !halted) {\n                                    running = fnObj;\n                                    fnObj.fn(_nowish);\n                                }\n                            } else {\n                                removeLater.push(fnObj);\n                            }\n                        });\n                        running = BOOLEAN_FALSE;\n                        combineAdd();\n                        removeAll(fnList, removeList.concat(removeLater));\n                        removeList = [];\n                    },\n                    remove: function (id) {\n                        var ret, fnObj, i = 0;\n                        if (!arguments[LENGTH]) {\n                            if (running) {\n                                id = running.id;\n                            }\n                        }\n                        if (isNumber(id)) {\n                            for (; i < fnList[LENGTH] && !ret; i++) {\n                                fnObj = fnList[i];\n                                if (fnObj.id === id) {\n                                    if (!posit(removeList, fnObj)) {\n                                        removeList.push(fnObj);\n                                        ret = 1;\n                                    }\n                                }\n                            }\n                        }\n                        return !!ret;\n                    },\n                    stop: function () {\n                        stopped = BOOLEAN_TRUE;\n                        return this;\n                    },\n                    start: function () {\n                        var looper = this;\n                        stopped = BOOLEAN_FALSE;\n                        halted = BOOLEAN_FALSE;\n                        return looper;\n                    },\n                    halt: function () {\n                        halted = BOOLEAN_TRUE;\n                        return this.stop();\n                    },\n                    halted: function () {\n                        return halted;\n                    },\n                    stopped: function () {\n                        return stopped;\n                    },\n                    reset: function () {\n                        fnList = [];\n                        removeList = [];\n                        addList = [];\n                        return this;\n                    },\n                    add: function (fn) {\n                        var obj, id = counter,\n                            tween = this;\n                        if (!isFunction(fn)) {\n                            return;\n                        }\n                        if (!fnList[LENGTH]) {\n                            tween.start();\n                        }\n                        start(tween);\n                        obj = {\n                            fn: tween.bind(fn),\n                            id: id,\n                            disabled: BOOLEAN_FALSE,\n                            bound: tween\n                        };\n                        if (tween.running()) {\n                            addList.push(obj);\n                        } else {\n                            fnList.push(obj);\n                        }\n                        counter++;\n                        return id;\n                    }\n                });\n                add(looper);\n                return looper;\n            },\n            bind: function (fn) {\n                return bind(fn, this);\n            },\n            once: function (fn) {\n                return this.count(1, fn);\n            },\n            count: function (timey, fn_) {\n                var fn, count = 0,\n                    times = pI(timey) || 1;\n                if (!fn_ && isFunction(times)) {\n                    fn_ = timey;\n                    times = 1;\n                }\n                if (!isFunction(fn_)) {\n                    return;\n                }\n                fn = this.bind(fn_);\n                if (times < 1 || !isNumber(times)) {\n                    times = 1;\n                }\n                return this.add(function (ms) {\n                    var last = 1;\n                    count++;\n                    if (count >= times) {\n                        this.remove();\n                        last = 0;\n                    }\n                    fn(ms, !last, count);\n                });\n            },\n            tween: function (time, fn_) {\n                var fn, added = nowish();\n                if (!time) {\n                    time = 0;\n                }\n                if (!isFunction(fn)) {\n                    return;\n                }\n                fn = this.bind(fn_);\n                return this.interval(0, function (ms) {\n                    var tween = 1,\n                        diff = ms - added;\n                    if (diff >= time) {\n                        tween = 0;\n                        this.remove();\n                    }\n                    fn(ms, Math.min(1, (diff / time)), !tween);\n                });\n            },\n            time: function (time, fn_) {\n                var fn;\n                if (!isFunction(fn)) {\n                    return this;\n                }\n                fn = this.bind(fn_);\n                return this.interval(time, function (ms) {\n                    this.remove();\n                    fn(ms);\n                });\n            },\n            frameRate: function (time, fn_, min) {\n                var fn, tween = this,\n                    minimum = Math.min(min || 0.8, 0.8),\n                    expectedFrameRate = 30 * minimum,\n                    lastDate = 1,\n                    lastSkip = nowish();\n                time = time || 125;\n                if (!isFunction(fn_)) {\n                    return tween;\n                }\n                fn = bind(fn_, this);\n                return tween.add(function (ms) {\n                    var frameRate = 1000 / (ms - lastDate);\n                    if (frameRate > 40) {\n                        expectedFrameRate = 60 * minimum;\n                    }\n                    if (frameRate < expectedFrameRate) {\n                        lastSkip = ms;\n                    }\n                    if (ms - lastSkip > time) {\n                        this.remove();\n                        fn(ms);\n                    }\n                    lastDate = ms;\n                });\n            },\n            interval: function (time, fn_) {\n                var fn, last = nowish();\n                if (!isFunction(fn)) {\n                    return;\n                }\n                if (!time) {\n                    time = 0;\n                }\n                fn = this.bind(fn);\n                return this.add(function (ms) {\n                    if (ms - time >= last) {\n                        last = ms;\n                        fn(ms);\n                    }\n                });\n            }\n        }, !0);\n    _.exports({\n        AF: new Looper()\n    });\n});","application.scope().module('Promise', function (module, app, _, factories) {\n    var blank, LENGTH = 'length',\n        FAILURE = 'failure',\n        SUCCESS = 'success',\n        STATE = 'state',\n        ALWAYS = 'always',\n        IS_EMPTYING = 'isEmptying',\n        ALL_STATES = 'allStates',\n        STASHED_ARGUMENT = 'stashedArgument',\n        flatten = _.flatten,\n        bind = _.bind,\n        isString = _.isString,\n        intendedObject = _.intendedObject,\n        duff = _.duff,\n        each = _.each,\n        extend = _.extend,\n        toArray = _.toArray,\n        isFunction = _.isFunction,\n        foldl = _.foldl,\n        result = _.result,\n        wraptry = _.wraptry,\n        indexOf = _.indexOf,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        NULL = null,\n        when = function () {\n            var promise = factories.Promise();\n            promise.add(foldl(flatten(arguments), function (memo, pro) {\n                if (promise._isChildType(pro)) {\n                    memo.push(pro);\n                }\n                return memo;\n            }, []));\n            return promise;\n        },\n        dispatch = function (promise, name, opts) {\n            var shouldstop, finalName = name,\n                allstates = result(promise, ALL_STATES),\n                collected = [];\n            while (!shouldstop) {\n                if (indexOf(collected, finalName) === -1) {\n                    collected.push(finalName);\n                    promise.executeHandlers(finalName);\n                    finalName = allstates[finalName];\n                } else {\n                    finalName = BOOLEAN_FALSE;\n                }\n                shouldstop = !isString(finalName);\n            }\n        },\n        executeIfNeeded = function (promise, name) {\n            return function () {\n                each(flatten(arguments), function (fn) {\n                    if (isFunction(fn)) {\n                        promise.executeHandler(name, fn, BOOLEAN_TRUE);\n                    }\n                });\n                return promise;\n            };\n        },\n        addState = function (key) {\n            var promise = this;\n            // if you haven't already attached a method, then do so now\n            if (!promise[key]) {\n                promise[key] = executeIfNeeded(promise, key);\n            }\n            return promise;\n        },\n        stateChecker = function (lookingfor) {\n            return function () {\n                var resulting = BOOLEAN_FALSE,\n                    allstates = result(this, ALL_STATES),\n                    next = this.get(STATE);\n                while (isString(next) && !resulting) {\n                    if (next === lookingfor) {\n                        resulting = BOOLEAN_TRUE;\n                    }\n                }\n                return resulting;\n            };\n        },\n        Promise = factories.Box.extend('Promise', {\n            addState: addState,\n            childEvents: {\n                always: 'check'\n            },\n            events: {\n                'child:added': 'check'\n            },\n            baseStates: function () {\n                return {\n                    success: ALWAYS,\n                    failure: ALWAYS,\n                    error: ALWAYS,\n                    always: BOOLEAN_TRUE\n                };\n            },\n            constructor: function () {\n                var promise = this;\n                factories.Box.constructor.call(promise);\n                promise.restart();\n                // cannot have been resolved in any way yet\n                intendedObject(extend({}, result(promise, 'baseStates'), result(promise, 'associativeStates')), NULL, bind(addState, promise));\n                // add passed in success handlers\n                promise.success(arguments);\n                return promise;\n            },\n            check: function () {\n                var notSuccessful, resolveAs, parent = this,\n                    children = parent.children,\n                    argumentAggregate = [];\n                if (children.length() && !children.find(function (child) {\n                    notSuccessful = notSuccessful || child.state() !== SUCCESS;\n                    argumentAggregate.push(child.get(STASHED_ARGUMENT));\n                    return !child.resolved();\n                })) {\n                    parent.resolveAs(notSuccessful ? FAILURE : SUCCESS, argumentAggregate);\n                }\n            },\n            _isChildType: function (promise) {\n                return promise[SUCCESS] && promise[FAILURE] && promise[ALWAYS];\n            },\n            defaults: function () {\n                return {\n                    state: 'pending',\n                    resolved: BOOLEAN_FALSE,\n                    stashedArgument: NULL,\n                    stashedHandlers: {},\n                    reason: BOOLEAN_FALSE\n                };\n            },\n            restart: function () {\n                return this.set(this.defaults());\n            },\n            state: function () {\n                return this.get(STATE);\n            },\n            auxilaryStates: function () {\n                return BOOLEAN_FALSE;\n            },\n            allStates: function () {\n                var resultResult = this._allStates = this._allStates || extend({}, result(this, 'baseStates'), result(this, 'auxilaryStates') || {});\n                return resultResult;\n            },\n            fullfillments: function () {\n                var allstates = result(this, ALL_STATES);\n                var results = this._fullfillments = this._fullfillments || wrap(allstates, function (value, key_) {\n                    var key = key_;\n                    while (isString(key)) {\n                        key = allstates[key];\n                    }\n                    // has to end in a boolean\n                    return key;\n                });\n                return results;\n            },\n            isFulfilled: stateChecker(SUCCESS),\n            isRejected: stateChecker(FAILURE),\n            resolved: function () {\n                // allows resolved to be defined in a different way\n                return this.get('resolved');\n            },\n            isPending: function () {\n                return this.get(STATE) === 'pending';\n            },\n            resolveAs: function (resolveAs_, opts_, reason_) {\n                var opts = opts_,\n                    resolveAs = resolveAs_,\n                    promise = this;\n                if (promise.resolved()) {\n                    return promise;\n                }\n                if (!isString(resolveAs)) {\n                    opts = resolveAs;\n                    resolveAs = BOOLEAN_FALSE;\n                }\n                promise.set({\n                    resolved: BOOLEAN_TRUE,\n                    // default state if none is given, is to have it succeed\n                    state: resolveAs || FAILURE,\n                    stashedArgument: opts,\n                    reason: reason_ ? reason_ : BOOLEAN_FALSE\n                });\n                resolveAs = promise.get(STATE);\n                return wraptry(function () {\n                    dispatch(promise, resolveAs);\n                    return promise;\n                }, function () {\n                    promise.set(STASHED_ARGUMENT, {\n                        // nest the sucker again in case it's an array or something else\n                        options: opts,\n                        message: 'javascript execution error'\n                    });\n                    dispatch(promise, 'error');\n                    return promise;\n                }, function () {\n                    return promise;\n                });\n            },\n            // convenience functions\n            resolve: function (opts) {\n                return this.resolveAs(SUCCESS, opts);\n            },\n            reject: function (opts) {\n                return this.resolveAs(FAILURE, opts);\n            },\n            executeHandlers: function (name) {\n                var handler, countLimit, promise = this,\n                    arg = promise.get(STASHED_ARGUMENT),\n                    handlers = promise.get('stashedHandlers')[name];\n                if (!handlers || !handlers[LENGTH]) {\n                    return promise;\n                }\n                countLimit = handlers[LENGTH];\n                promise.set(IS_EMPTYING, BOOLEAN_TRUE);\n                while (handlers[0] && --countLimit >= 0) {\n                    handler = handlers.shift();\n                    // should already be bound\n                    handler(arg);\n                }\n                promise.set(IS_EMPTYING, BOOLEAN_FALSE);\n                return promise;\n            },\n            executeHandler: function (name, fn_, needsbinding) {\n                var promise = this,\n                    arg = promise.get(STASHED_ARGUMENT),\n                    fn = fn_;\n                promise.stashHandler(name, fn);\n                if (promise.resolved() && !promise.get(IS_EMPTYING)) {\n                    promise.executeHandlers(name);\n                }\n                return promise;\n            },\n            stashHandler: function (name, fn, needsbinding) {\n                var promise = this,\n                    stashedHandlers = promise.get('stashedHandlers'),\n                    byName = stashedHandlers[name] = stashedHandlers[name] || [];\n                if (isFunction(fn)) {\n                    byName.push(bind(fn, this));\n                }\n            },\n            handle: function (resolutionstate, fun) {\n                this.addState(resolutionstate);\n                this.executeHandler(resolutionstate, fun, BOOLEAN_TRUE);\n                return this;\n            }\n        }, BOOLEAN_TRUE);\n    _.exports({\n        when: when\n    });\n});","application.scope().module('Ajax', function (module, app, _, factories) {\n    var gapSplit = _.gapSplit,\n        duff = _.duff,\n        each = _.each,\n        unCamelCase = _.unCamelCase,\n        posit = _.posit,\n        result = _.result,\n        wraptry = _.wraptry,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        STATUS = 'status',\n        FAILURE = 'failure',\n        SUCCESS = 'success',\n        READY_STATE = 'readyState',\n        isObject = _.isObject,\n        isArray = _.isArray,\n        stringify = _.stringify,\n        parse = _.parse,\n        extend = _.extend,\n        stringifyQuery = _.stringifyQuery,\n        validTypes = gapSplit('GET POST PUT DELETE'),\n        baseEvents = gapSplit('progress timeout abort error'),\n        cache = {},\n        /**\n         * @description helper function to attach a bunch of event listeners to the request object as well as help them trigger the appropriate events on the Ajax object itself\n         * @private\n         * @arg {Ajax} instance to listen to\n         * @arg {Xhr} instance to place event handlers to trigger events on the Ajax instance\n         * @arg {string} event name\n         */\n        attachBaseListeners = function (ajax) {\n            var prog = 0,\n                req = ajax.requestObject;\n            duff(baseEvents, function (evnt) {\n                if (evnt === 'progress') {\n                    req['on' + evnt] = function (e) {\n                        prog++;\n                        ajax.executeHandlers(evnt, {\n                            percent: (e.loaded / e.total) || (prog / (prog + 1)),\n                            counter: prog\n                        });\n                    };\n                } else {\n                    req['on' + evnt] = function (e) {\n                        ajax.resolveAs(evnt);\n                    };\n                }\n            });\n        },\n        sendthething = function (xhrReq, args) {\n            return function () {\n                wraptry(function () {\n                    xhrReq.send.apply(xhrReq, args);\n                }, function (e) {\n                    // handle an xhr req send error here\n                    factories.reportError('xhr', e + '');\n                });\n            };\n        },\n        alterurlHandler = function () {\n            var ajax = this,\n                xhrReq = ajax.requestObject,\n                type = ajax.get('type'),\n                url = ajax.getUrl(),\n                args = [],\n                data = ajax.get('data');\n            if (!url) {\n                return;\n            }\n            ajax.attachResponseHandler();\n            xhrReq.open(type, url, ajax.get('async'));\n            if (data) {\n                args.push(stringify(data));\n            }\n            ajax.setHeaders(ajax.get('headers'));\n            attachBaseListeners(ajax);\n            // have to wrap in set timeout for ie\n            setTimeout(sendthething(xhrReq, args));\n        },\n        /**\n         * @class Ajax\n         * @alias factories.Ajax\n         * @augments Box\n         * @augments Model\n         * @classdesc XHR object wrapper Triggers events based on xhr state changes and abstracts many anomalies that have to do with IE\n         */\n        Ajax = factories.Promise.extend('Ajax', {\n            /**\n             * @func\n             * @name Ajax#constructor\n             * @param {string} str - url to get from\n             * @returns {Ajax} new ajax object\n             */\n            constructor: function (str, secondary) {\n                var promise, url, thingToDo, typeThing, type, xhrReq, ajax = this,\n                    method = 'onreadystatechange';\n                // Add a cache buster to the url\n                // ajax.async = BOOLEAN_TRUE;\n                xhrReq = new XMLHttpRequest();\n                // covers ie9\n                if (typeof XDomainRequest !== 'undefined') {\n                    xhrReq = new XDomainRequest();\n                    method = 'onload';\n                }\n                if (!_.isObject(str)) {\n                    str = str || '';\n                    type = 'GET';\n                    typeThing = str.toUpperCase();\n                    if (posit(validTypes, typeThing)) {\n                        type = typeThing;\n                    } else {\n                        url = str;\n                    }\n                    str = {\n                        url: url || '',\n                        type: type\n                    };\n                }\n                str.async = BOOLEAN_TRUE;\n                str.type = (str.type || 'GET').toUpperCase();\n                str.method = method;\n                factories.Promise.constructor.apply(ajax);\n                ajax.on('change:url', alterurlHandler);\n                extend(ajax, secondary);\n                ajax.requestObject = xhrReq;\n                ajax.set(str);\n                return ajax;\n            },\n            status: function (code, handler) {\n                return this.handle(STATUS + ':' + code, handler);\n            },\n            setHeaders: function (headers) {\n                var ajax = this,\n                    xhrReq = ajax.requestObject;\n                each(headers, function (val, key) {\n                    xhrReq.setRequestHeader(unCamelCase(key), val);\n                });\n                return ajax;\n            },\n            /**\n             * @description specialized function to stringify url if it is an object\n             * @returns {string} returns the completed string that will be fetched / posted / put / or deleted against\n             * @name Ajax#getUrl\n             */\n            getUrl: function () {\n                var url = this.get('url');\n                if (isObject(url) && !isArray(url)) {\n                    url = stringifyQuery(url);\n                }\n                return url;\n            },\n            /**\n             * @description makes public the ability to attach a response handler if one has not already been attached. We recommend not passing a function in and instead just listening to the various events that the xhr object will trigger directly, or indirectly on the ajax object\n             * @param {function} [fn=handler] - pass in a function to have a custom onload, onreadystatechange handler\n             * @returns {ajax}\n             * @name Ajax#attachResponseHandler\n             */\n            auxilaryStates: function () {\n                return {\n                    'status:200': SUCCESS,\n                    'status:202': SUCCESS,\n                    'status:205': SUCCESS,\n                    'status:302': SUCCESS,\n                    'status:304': SUCCESS,\n                    'status:400': FAILURE,\n                    'status:401': FAILURE,\n                    'status:403': FAILURE,\n                    'status:404': FAILURE,\n                    'status:405': FAILURE,\n                    'status:406': FAILURE,\n                    'status:500': FAILURE,\n                    'status:502': FAILURE,\n                    'status:505': FAILURE,\n                    'status:511': FAILURE,\n                    timeout: FAILURE,\n                    abort: FAILURE\n                };\n            },\n            parse: function (rawData) {\n                return parse(rawData);\n            },\n            attachResponseHandler: function () {\n                var ajax = this,\n                    xhrReqObj = ajax.requestObject,\n                    hasFinished = BOOLEAN_FALSE,\n                    method = ajax.get('method'),\n                    handler = function (evnt) {\n                        var status, doIt, allStates, rawData, readystate, xhrReqObj = this;\n                        if (!xhrReqObj || hasFinished) {\n                            return;\n                        }\n                        status = xhrReqObj[STATUS];\n                        readystate = xhrReqObj[READY_STATE];\n                        rawData = xhrReqObj.responseText;\n                        ajax.currentEvent = evnt;\n                        ajax.set('readystate', readystate);\n                        if (method === 'onload' || (method === 'onreadystatechange' && readystate === 4)) {\n                            ajax.set(STATUS, status);\n                            allStates = result(ajax, 'allStates');\n                            if (allStates[STATUS + ':' + xhrReqObj[STATUS]] === SUCCESS) {\n                                rawData = result(ajax, 'parse', rawData);\n                            }\n                            rawData = parse(rawData);\n                            hasFinished = BOOLEAN_TRUE;\n                            ajax.resolveAs(STATUS + ':' + xhrReqObj[STATUS], rawData);\n                        }\n                    };\n                if (!xhrReqObj[method]) {\n                    xhrReqObj[method] = handler;\n                }\n                return ajax;\n            }\n        }, BOOLEAN_TRUE);\n    _.exports(_.foldl(validTypes, function (memo, key_) {\n        var key = key_;\n        key = key.toLowerCase();\n        memo[key] = function (url) {\n            return Ajax({\n                type: key,\n                url: url\n            });\n        };\n        return memo;\n    }, {}));\n});","application.scope().module('Associator', function (module, app, _, factories) {\n    /**\n     * @class Associator\n     * @augments Model\n     */\n    var LENGTH = 'length',\n        extend = _.extend,\n        isObject = _.isObject,\n        removeAt = _.removeAt,\n        Associator = factories.Model.extend('Associator', {\n            /**\n             * @func\n             * @name Associator#get\n             * @param {Object} obj - object that data is being gotten against in the Associator\n             * @param {String} [type] - toString version of the object being passed in\n             */\n            get: function (obj, type) {\n                var returnData, idxOf, dataset, n, els, dataArray, current,\n                    instance = this,\n                    canRead = 0,\n                    data = {\n                        dataset: {}\n                    };\n                current = this.sameType(obj);\n                els = current.items;\n                dataArray = current.data;\n                if (!els) {\n                    els = current.items = [];\n                }\n                if (!dataArray) {\n                    dataArray = current.data = [];\n                }\n                if (obj && _.isDom && current.readData) {\n                    dataset = obj.dataset;\n                    // copy dataset over from one to the other\n                    if (isObject(dataset) && _.isDom(obj)) {\n                        data.dataset = extend(data.dataset, dataset);\n                    }\n                }\n                idxOf = current.items.indexOf(obj);\n                if (idxOf === -1) {\n                    idxOf = current.items[LENGTH];\n                    current.items.push(obj);\n                    dataArray[idxOf] = data;\n                }\n                return dataArray[idxOf];\n            },\n            /**\n             * @func\n             * @name Associator#set\n             * @param {Node} el - Element to store data against\n             * @param {Object} obj - object to extend onto current data\n             * @param {String} [type] - toString evaluation of element, if it has already been evaluated\n             * @returns {Object} data that is being held on the Associator\n             */\n            set: function (el, extensor, type) {\n                var n, data = this.get(el, type);\n                extend(data, extensor || {});\n                return data;\n            },\n            remove: function (el) {\n                var type = this.sameType(el);\n                var idx = _.indexOf(type.items, el);\n                var ret = removeAt(type.data, idx);\n                removeAt(type.items, idx);\n                return ret;\n            },\n            /**\n             * @func\n             * @name Associator#sameType\n             * @param {Object} obj - object to find matched types against\n             */\n            sameType: function (obj) {\n                var instance = this,\n                    type = _.toString(obj),\n                    current = instance[type],\n                    lowerType = type.toLowerCase();\n                if (!current) {\n                    // makes things easier to find\n                    current = instance[type] = {};\n                }\n                // skip reading data\n                if (lowerType.indexOf('global') === -1 && lowerType.indexOf('window') === -1) {\n                    current.readData = 1;\n                }\n                return current;\n            }\n        }, !0);\n    _.exports({\n        associator: factories.Associator()\n    });\n});","application.scope().module('DOMM', function (module, app, _, factories) {\n    var blank, sizzleDoc = document,\n        eq = _.eq,\n        once = _.once,\n        elementData = _.associator,\n        result = _.result,\n        uniqueId = _.uniqueId,\n        isFunction = _.isFunction,\n        Collection = factories.Collection,\n        wraptry = _.wraptry,\n        now = _.now,\n        each = _.each,\n        bind = _.bind,\n        duff = _.duff,\n        find = _.find,\n        wrap = _.wrap,\n        trace = _.trace,\n        posit = _.posit,\n        foldl = _.foldl,\n        filter = _.filter,\n        isString = _.isString,\n        isObject = _.isObject,\n        isNumber = _.isNumber,\n        isBoolean = _.isBoolean,\n        stringify = _.stringify,\n        parse = _.parse,\n        isArrayLike = _.isArrayLike,\n        objectMatches = _.matches,\n        merge = _.merge,\n        console = _.console,\n        remove = _.splice,\n        extend = _.extend,\n        negate = _.negate,\n        intendedObject = _.intendedObject,\n        isInstance = _.isInstance,\n        isBlank = _.isBlank,\n        gapJoin = _.gapJoin,\n        isArray = _.isArray,\n        toArray = _.toArray,\n        duffRev = _.duffRev,\n        indexOf = _.indexOf,\n        clone = _.clone,\n        units = _.units,\n        gapSplit = _.gapSplit,\n        camelCase = _.camelCase,\n        unCamelCase = _.unCamelCase,\n        parseDecimal = _.parseDecimal,\n        add = _.add,\n        removeAll = _.removeAll,\n        addAll = _.addAll,\n        NODE_TYPE = 'nodeType',\n        PARENT_NODE = 'parentNode',\n        LENGTH = 'length',\n        ITEMS = '_items',\n        DELEGATE_COUNT = '__delegateCount',\n        REMOVE_QUEUE = 'removeQueue',\n        ADD_QUEUE = 'addQueue',\n        CLASSNAME = 'className',\n        DEFAULT_VIEW = 'defaultView',\n        WINDOW = 'window',\n        DOCUMENT = 'document',\n        CLASS = 'class',\n        STYLE = 'style',\n        BODY = 'body',\n        TOP = 'top',\n        LEFT = 'left',\n        RIGHT = 'right',\n        BOTTOM = 'bottom',\n        WIDTH = 'width',\n        HEIGHT = 'height',\n        INDEX = 'index',\n        INNER_HEIGHT = 'innerHeight',\n        INNER_WIDTH = 'innerWidth',\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        NULL = null,\n        win = window,\n        devicePixelRatio = (win.devicePixelRatio || 1),\n        ua = navigator.userAgent,\n        isElement = function (object) {\n            return !!(object && isNumber(object[NODE_TYPE]) && object[NODE_TYPE] === object.ELEMENT_NODE);\n        },\n        /**\n         * @private\n         * @func\n         */\n        isWindow = function (obj) {\n            return obj && obj === obj[WINDOW];\n        },\n        /**\n         * @private\n         * @func\n         */\n        isDocument = function (obj) {\n            return obj && isNumber(obj[NODE_TYPE]) && obj[NODE_TYPE] === obj.DOCUMENT_NODE;\n        },\n        isFragment = function (frag) {\n            return frag && frag[NODE_TYPE] === sizzleDoc.DOCUMENT_FRAGMENT_NODE;\n        },\n        getClosestWindow = function (windo_) {\n            var windo = windo_ || win;\n            return isWindow(windo) ? windo : (windo && windo[DEFAULT_VIEW] ? windo[DEFAULT_VIEW] : (windo.ownerGlobal ? windo.ownerGlobal : $(windo).parent(WINDOW)[INDEX](0) || win));\n        },\n        getComputed = function (el, ctx) {\n            var ret = getClosestWindow(ctx).getComputedStyle(el);\n            return ret ? ret : getClosestWindow(el).getComputedStyle(el) || clone(el[STYLE]) || {};\n        },\n        allStyles = getComputed(sizzleDoc[BODY], win),\n        rkeyEvent = /^key/,\n        rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n        rforceEvent = /^webkitmouseforce/,\n        hasWebP = (function () {\n            var countdown = 4,\n                result = BOOLEAN_TRUE,\n                queue = [],\n                emptyqueue = function (fn) {\n                    return function () {\n                        countdown--;\n                        fn();\n                        if (!countdown) {\n                            duff(queue, function (item) {\n                                item(result);\n                            });\n                            queue = [];\n                        }\n                    };\n                };\n            duff([\"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\", \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\", \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\", \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"], function (val) {\n                var img = new Image();\n                img.onload = emptyqueue(_.noop);\n                img.onerror = emptyqueue(function () {\n                    result = BOOLEAN_FALSE;\n                });\n                img.src = \"data:image/webp;base64,\" + val;\n            });\n            return function (cb) {\n                if (!countdown || !result) {\n                    cb(result);\n                } else {\n                    queue.push(cb);\n                }\n            };\n        }()),\n        saveDOMContentLoadedEvent = function (doc) {\n            var data = elementData.get(doc);\n            if (data.isReady === blank) {\n                data.isReady = BOOLEAN_FALSE;\n                DOMM(doc).on('DOMContentLoaded', function (e) {\n                    data.DOMContentLoadedEvent = e;\n                    data.isReady = BOOLEAN_TRUE;\n                });\n            }\n        },\n        _DOMM = factories._DOMM = function (doc) {\n            saveDOMContentLoadedEvent(doc);\n            return function (sel, ctx) {\n                return DOMM(sel, ctx || doc);\n            };\n        },\n        setAttribute = function (el, key, val_) {\n            var val = val_;\n            if (val === BOOLEAN_TRUE) {\n                val = '';\n            } else {\n                val = stringify(val);\n            }\n            val += '';\n            el.setAttribute(key, val);\n        },\n        getAttribute = function (el, key, val) {\n            var converted;\n            val = parse(el.getAttribute(key));\n            val = +val == val ? +val : val;\n            if (val === '') {\n                val = BOOLEAN_TRUE;\n            }\n            if (isBlank(val)) {\n                val = BOOLEAN_FALSE;\n            }\n            return val;\n        },\n        /**\n         * @private\n         * @func\n         */\n        attributeInterface = function (el, key, val) {\n            // set or remove if not undefined\n            // undefined fills in the gap by returning some value, which is never undefined\n            if (val !== blank) {\n                if (!val && val !== 0) {\n                    el.removeAttribute(key);\n                } else {\n                    setAttribute(el, key, val);\n                }\n            } else {\n                return getAttribute(el, key, val);\n            }\n        },\n        getClassName = function (el, key) {\n            var className = el[CLASSNAME];\n            if (!isString(className)) {\n                className = getAttribute(el, CLASS);\n            }\n            return (className || '').split(' ');\n        },\n        setClassName = function (el, val) {\n            var value = val.join(' ').trim();\n            if (isString(el[CLASSNAME])) {\n                el[CLASSNAME] = value;\n            } else {\n                setAttribute(el, CLASS, value);\n            }\n        },\n        triggerEventWrapper = function (attr, api) {\n            attr = attr || api;\n            return function (fn, fn2) {\n                var args, evnt, count = 0,\n                    domm = this;\n                if (isFunction(fn) || isFunction(fn2)) {\n                    args = toArray(arguments);\n                    args.unshift(attr);\n                    domm.on.apply(domm, args);\n                } else {\n                    domm.duff(function (el) {\n                        var whichever = api || attr;\n                        if (isFunction(el[whichever])) {\n                            el[whichever]();\n                        } else {\n                            $(el).dispatchEvent(whichever);\n                        }\n                    });\n                }\n                return domm;\n            };\n        },\n        /**\n         * @private\n         * @func\n         */\n        htmlDataMatch = function (string, regexp, callback, nameFinder) {\n            var matches = string.trim().match(regexp);\n            duff(matches, function (match) {\n                var value;\n                match = match.trim();\n                value = match.match(/~*=[\\'|\\\"](.*?)[\\'|\\\"]/);\n                name = match.match(/(.*)(?:~*=)/igm);\n                name = _.join(_.split(name, '='), '').trim();\n                callback(value[1], name, match);\n            });\n        },\n        Events = gapSplit('abort afterprint beforeprint blocked cached canplay canplaythrough change chargingchange chargingtimechange checking close complete dischargingtimechange DOMContentLoaded downloading durationchange emptied ended error fullscreenchange fullscreenerror input invalid languagechange levelchange loadeddata loadedmetadata message noupdate obsolete offline online open pagehide pageshow paste pause pointerlockchange pointerlockerror play playing ratechange reset seeked seeking stalled storage submit success suspend timeupdate updateready upgradeneeded versionchange visibilitychange'),\n        SVGEvent = gapSplit('SVGAbort SVGError SVGLoad SVGResize SVGScroll SVGUnload SVGZoom volumechange waiting'),\n        KeyboardEvent = gapSplit('keydown keypress keyup'),\n        GamePadEvent = gapSplit('gamepadconnected gamepadisconnected'),\n        CompositionEvent = gapSplit('compositionend compositionstart compositionupdate drag dragend dragenter dragleave dragover dragstart drop'),\n        MouseEvents = gapSplit('click contextmenu dblclick mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup show wheel'),\n        TouchEvents = gapSplit('touchcancel touchend touchenter touchleave touchmove touchstart'),\n        DeviceEvents = gapSplit('devicemotion deviceorientation deviceproximity devicelight'),\n        FocusEvent = gapSplit('blur focus'),\n        // BeforeUnloadEvent = gapSplit(''),\n        TimeEvent = gapSplit('beginEvent endEvent repeatEvent'),\n        AnimationEvent = gapSplit('animationend animationiteration animationstart transitionend'),\n        AudioProcessingEvent = gapSplit('audioprocess complete'),\n        UIEvents = gapSplit('abort error hashchange load orientationchange readystatechange resize scroll select unload beforeunload'),\n        ProgressEvent = gapSplit('abort error load loadend loadstart popstate progress timeout'),\n        AllEvents = _.concatUnique(Events, SVGEvent, KeyboardEvent, CompositionEvent, GamePadEvent, MouseEvents, TouchEvents, DeviceEvents, FocusEvent, TimeEvent, AnimationEvent, AudioProcessingEvent, UIEvents, ProgressEvent),\n        knownPrefixes = gapSplit('-o- -ms- -moz- -webkit- mso- -xv- -atsc- -wap- -khtml- -apple- prince- -ah- -hp- -ro- -rim- -tc-'),\n        trustedEvents = gapSplit('load scroll resize orientationchange click dblclick mousedown mouseup mouseover mouseout mouseenter mouseleave mousemove change contextmenu hashchange load mousewheel wheel readystatechange'),\n        ALL_EVENTS_HASH = wrap(AllEvents, BOOLEAN_TRUE),\n        knownPrefixesHash = wrap(knownPrefixes, BOOLEAN_TRUE),\n        /**\n         * @private\n         * @func\n         */\n        // changeClass = function (el, remove, add) {\n        //     var subdata = queuedata.className.get(el);\n        //     queuedata.className.remove(el, remove, subdata);\n        //     queuedata.className.add(el, add, subdata);\n        // },\n        changeClass = function (el, remove, add) {\n            var n, val, command, classList;\n            if (el) {\n                classList = getClassName(el);\n                if (remove) {\n                    removeAll(classList, gapSplit(remove));\n                }\n                if (add) {\n                    addAll(classList, gapSplit(add));\n                }\n                // val = gapJoin(classList).trim();\n                setClassName(el, classList);\n                return el;\n            }\n        },\n        // removeClass = function (el, remove) {\n        //     var subdata = queuedata.className.get(el);\n        //     queuedata.className.remove(el, remove, subdata);\n        // },\n        // addClass = function (el, add) {\n        //     var subdata = queuedata.className.get(el);\n        //     queuedata.className.add(el, add, subdata);\n        // },\n        eventNameProperties = function (str) {},\n        /**\n         * @private\n         * @func\n         */\n        toStyleString = function (css) {\n            var cssString = [];\n            each(css, function (name, val) {\n                var nameSplit;\n                name = unCamelCase(name);\n                nameSplit = name.split('-');\n                if (knownPrefixesHash[nameSplit[0]]) {\n                    nameSplit.unshift('');\n                }\n                name = nameSplit.join('-');\n                cssString.push(name + ': ' + val + ';');\n            });\n            return cssString.join(' ');\n        },\n        // toCssObject = function () {},\n        /**\n         * @private\n         * @func\n         */\n        ensureDOM = function (fn) {\n            return function (el) {\n                if (isElement(el)) {\n                    fn(el);\n                }\n            };\n        },\n        /**\n         * @private\n         * @func\n         */\n        // returns the flow of the element passed on relative to the element's bounding window\n        flow = function (el, ctx) {\n            var clientRect = el.getBoundingClientRect(),\n                computedStyle = getComputed(el, ctx),\n                marginTop = parseFloat(computedStyle.marginTop),\n                marginLeft = parseFloat(computedStyle.marginLeft),\n                marginRight = parseFloat(computedStyle.marginRight),\n                marginBottom = parseFloat(computedStyle.marginBottom);\n            return {\n                height: clientRect[HEIGHT],\n                width: clientRect[WIDTH],\n                top: clientRect[TOP] - marginTop,\n                left: clientRect[LEFT] - marginLeft,\n                right: clientRect[LEFT] - marginLeft + clientRect[WIDTH] - marginRight,\n                bottom: clientRect[TOP] - marginTop + clientRect[HEIGHT] - marginBottom\n            };\n        },\n        numberBasedCss = {\n            columnCount: BOOLEAN_TRUE,\n            columns: BOOLEAN_TRUE,\n            fontWeight: BOOLEAN_TRUE,\n            lineHeight: BOOLEAN_TRUE,\n            opacity: BOOLEAN_TRUE,\n            zIndex: BOOLEAN_TRUE,\n            zoom: BOOLEAN_TRUE,\n            animationIterationCount: BOOLEAN_TRUE,\n            boxFlex: BOOLEAN_TRUE,\n            boxFlexGroup: BOOLEAN_TRUE,\n            boxOrdinalGroup: BOOLEAN_TRUE,\n            flex: BOOLEAN_TRUE,\n            flexGrow: BOOLEAN_TRUE,\n            flexPositive: BOOLEAN_TRUE,\n            flexShrink: BOOLEAN_TRUE,\n            flexNegative: BOOLEAN_TRUE,\n            flexOrder: BOOLEAN_TRUE,\n            lineClamp: BOOLEAN_TRUE,\n            order: BOOLEAN_TRUE,\n            orphans: BOOLEAN_TRUE,\n            tabSize: BOOLEAN_TRUE,\n            widows: BOOLEAN_TRUE,\n            // SVG-related properties\n            fillOpacity: BOOLEAN_TRUE,\n            stopOpacity: BOOLEAN_TRUE,\n            strokeDashoffset: BOOLEAN_TRUE,\n            strokeOpacity: BOOLEAN_TRUE,\n            strokeWidth: BOOLEAN_TRUE\n        },\n        timeBasedCss = {\n            transitionDuration: BOOLEAN_TRUE,\n            animationDuration: BOOLEAN_TRUE,\n            transitionDelay: BOOLEAN_TRUE,\n            animationDelay: BOOLEAN_TRUE\n        },\n        /**\n         * @private\n         * @func\n         */\n        css = (function () {\n            var i, j, n, found, prefixIndex, __prefix, styleName, currentCheck, deprefixed, currentLen,\n                validCssNames = [],\n                prefixed = {},\n                len = 0,\n                valueModifiers = {\n                    '-webkit-transform': function (val) {\n                        return val;\n                    }\n                },\n                modifyFinalProp = function (prop, val) {\n                    if (valueModifiers[prop]) {\n                        val = valueModifiers[prop](val);\n                    }\n                    return val;\n                },\n                addPrefix = function (list, prefix) {\n                    if (!posit(list, __prefix)) {\n                        list.push(__prefix);\n                    }\n                };\n            for (i = 0; i < knownPrefixes[LENGTH]; i++) {\n                currentLen = knownPrefixes[i][LENGTH];\n                if (len < currentLen) {\n                    len = currentLen;\n                }\n            }\n            for (n in allStyles) {\n                found = 0;\n                currentCheck = '';\n                __prefix = '';\n                if (isNumber(+n)) {\n                    styleName = allStyles[n];\n                } else {\n                    styleName = unCamelCase(n);\n                }\n                deprefixed = styleName;\n                for (j = 0; j < len && styleName[j] && !found; j++) {\n                    currentCheck += styleName[j];\n                    prefixIndex = indexOf(knownPrefixes, currentCheck);\n                    if (prefixIndex !== -1) {\n                        __prefix = knownPrefixes[prefixIndex];\n                        deprefixed = styleName.split(__prefix).join('');\n                        found = 1;\n                    }\n                    prefixIndex = indexOf(knownPrefixes, '-' + currentCheck);\n                    if (prefixIndex !== -1) {\n                        __prefix = knownPrefixes[prefixIndex];\n                        deprefixed = styleName.split(currentCheck).join('');\n                        found = 1;\n                    }\n                }\n                deprefixed = camelCase(deprefixed);\n                validCssNames.push(deprefixed);\n                if (!prefixed[deprefixed]) {\n                    prefixed[deprefixed] = [];\n                }\n                addPrefix(prefixed[deprefixed], __prefix);\n            }\n            return function (el, key, value) {\n                var n, m, j, firstEl, lastKey, prefixes, unCameled, computed, _ret, retObj, finalProp, i = 0,\n                    ret = {},\n                    count = 0,\n                    nuCss = {};\n                if (!isObject(el)) {\n                    return;\n                }\n                if (isBoolean(key)) {\n                    key = el;\n                    retObj = 1;\n                }\n                firstEl = el[0];\n                intendedObject(key, value, function (key, value) {\n                    if (!isBlank(value)) {\n                        count++;\n                        prefixes = [''];\n                        if (prefixed[m]) {\n                            prefixes = prefixed[m].concat(prefixes);\n                        }\n                        for (j = 0; j < prefixes[LENGTH]; j++) {\n                            finalProp = camelCase(prefixes[j] + m);\n                            nuCss[finalProp] = modifyFinalProp(finalProp, value);\n                        }\n                    } else {\n                        ret[m] = value;\n                    }\n                });\n                if (retObj) {\n                    return nuCss;\n                }\n                if (isElement(el)) {\n                    el = [el];\n                }\n                if (!count) {\n                    if (isElement(firstEl)) {\n                        _ret = {};\n                        computed = getComputed(firstEl);\n                        count--;\n                        each(ret, function (val_, key, obj) {\n                            _ret[key] = convertStyleValue(key, computed[key]);\n                            count++;\n                            lastKey = key;\n                        });\n                        if (count + 1) {\n                            if (count) {\n                                return _ret;\n                            } else {\n                                return _ret[lastKey];\n                            }\n                        }\n                    }\n                } else {\n                    style(el, nuCss);\n                }\n            };\n        }()),\n        convertStyleValue = function (key, value_) {\n            var value = value_;\n            if (value === +value) {\n                if (timeBasedCss[key]) {\n                    value += 'ms';\n                }\n                if (!numberBasedCss[key]) {\n                    value += 'px';\n                }\n            }\n            return value;\n        },\n        style = function (els, key, value) {\n            var ensuredDom;\n            if (els[LENGTH]) {\n                ensuredDom = ensureDOM(function (el) {\n                    el[STYLE][key] = value;\n                });\n                intendedObject(key, value, function (key, value_) {\n                    var value = convertStyleValue(value_);\n                    duff(els, ensuredDom);\n                });\n            }\n        },\n        prefixer = function (obj) {\n            var rez = css(obj, BOOLEAN_TRUE);\n            return rez;\n        },\n        jsToCss = function (obj) {\n            var nuObj = {};\n            each(obj, function (key, val) {\n                var deCameled = unCamelCase(key),\n                    split = deCameled.split('-'),\n                    starter = split[0],\n                    idx = indexOf(knownPrefixes, '-' + starter + '-');\n                if (idx !== -1) {\n                    split[0] = '-' + starter;\n                }\n                nuObj[split.join('-')] = val;\n            });\n            return nuObj;\n        },\n        /**\n         * @private\n         * @func\n         */\n        box = function (el, ctx) {\n            var clientrect, computed, ret = {};\n            if (!isElement(el)) {\n                return ret;\n            }\n            computed = getComputed(el, ctx);\n            clientrect = clientRect(el, ctx);\n            return {\n                borderBottom: +computed.borderBottomWidth || 0,\n                borderRight: +computed.borderRightWidth || 0,\n                borderLeft: +computed.borderLeftWidth || 0,\n                borderTop: +computed.borderTopWidth || 0,\n                paddingBottom: +computed.paddingBottom || 0,\n                paddingRight: +computed.paddingRight || 0,\n                paddingLeft: +computed.paddingLeft || 0,\n                paddingTop: +computed.paddingTop || 0,\n                marginBottom: +computed.marginBottom || 0,\n                marginRight: +computed.marginRight || 0,\n                marginLeft: +computed.marginLeft || 0,\n                marginTop: +computed.marginTop || 0,\n                computedBottom: +computed[BOTTOM] || 0,\n                computedRight: +computed[RIGHT] || 0,\n                computedLeft: +computed[LEFT] || 0,\n                computedTop: +computed[TOP] || 0,\n                top: clientrect[TOP] || 0,\n                left: clientrect[LEFT] || 0,\n                right: clientrect[RIGHT] || 0,\n                bottom: clientrect[BOTTOM] || 0,\n                width: clientrect[WIDTH] || 0,\n                height: clientrect[HEIGHT] || 0\n            };\n        },\n        clientRect = function (item) {\n            var ret = {};\n            if (isElement(item)) {\n                ret = item.getBoundingClientRect();\n            }\n            return {\n                top: ret[TOP] || 0,\n                left: ret[LEFT] || 0,\n                right: ret[RIGHT] || 0,\n                bottom: ret[BOTTOM] || 0,\n                width: ret[WIDTH] || 0,\n                height: ret[HEIGHT] || 0\n            };\n        },\n        /**\n         * @private\n         * @func\n         */\n        unitRemoval = function (str, unit) {\n            return +(str.split(unit || 'px').join('').trim()) || 0;\n        },\n        /**\n         * @private\n         * @func\n         */\n        getStyleSize = function (el, attr, win) {\n            var val, elStyle, num = el;\n            if (isObject(el)) {\n                if (isElement(el)) {\n                    elStyle = getComputed(el, win);\n                } else {\n                    elStyle = el;\n                }\n                val = elStyle[attr];\n            } else {\n                val = el;\n            }\n            if (isString(val)) {\n                val = unitRemoval(val);\n            }\n            return val;\n        },\n        /**\n         * @private\n         * @func\n         */\n        filterExpressions = {\n            ':even': function (el, idx) {\n                return (idx % 2);\n            },\n            ':odd': function (el, idx) {\n                return ((idx + 1) % 2);\n            }\n        },\n        // always in pixels\n        numberToUnit = {\n            'in': function (val, el, win, styleAttr) {\n                return val / 96;\n            },\n            vh: function (val, el, win, styleAttr) {\n                return (val / win[INNER_HEIGHT]) * 100;\n            },\n            px: function (val, el, win, styleAttr) {\n                return val;\n            },\n            cm: function (val, el, win, styleAttr) {\n                return val / 37.79527559055118;\n            },\n            vw: function (val, el, win, styleAttr) {\n                return (val / win[INNER_WIDTH]) * 100;\n            },\n            em: function (val, el, win, styleAttr) {\n                return val / getStyleSize(el, 'fontSize', win);\n            },\n            mm: function (val, el, win, styleAttr) {\n                return val / 3.779527559055118;\n            },\n            vmin: function (val, el, win, styleAttr) {\n                var mult = Math.min(win[INNER_HEIGHT], win[INNER_WIDTH]);\n                return (val / mult) * 100;\n            },\n            rem: function (val, el, win, styleAttr) {\n                return val / getStyleSize(win[DOCUMENT][BODY][PARENT_NODE], 'fontSize', win);\n            },\n            pt: function (val, el, win, styleAttr) {\n                return val / 1.333333333333333;\n            },\n            vmax: function (val, el, win, styleAttr) {\n                var mult = Math.max(win[INNER_HEIGHT], win[INNER_WIDTH]);\n                return (val / mult) * 100;\n            },\n            '%': function (val, el, win, styleAttr) {\n                var parent = isElement(el) ? el[PARENT_NODE] : el,\n                    _val = getStyleSize(parent, styleAttr, win);\n                return (val / _val) * 100;\n            },\n            pc: function (val, el, win, styleAttr) {\n                return val / 16;\n            }\n        },\n        numToUnits = function (num, unit, el, winTop, styleAttr, returnNum) {\n            var number = num;\n            if (num) {\n                number = numberToUnit[unit](num, el, winTop, styleAttr);\n            }\n            number = (number || 0);\n            if (!returnNum) {\n                number += unit;\n            }\n            return number;\n        },\n        /**\n         * @private\n         * @func\n         */\n        unitToNumber = {\n            'in': function (val, el, win, styleAttr) {\n                return val * 96;\n            },\n            vh: function (val, el, win, styleAttr) {\n                return win[INNER_HEIGHT] * val / 100;\n            },\n            px: function (val, el, win, styleAttr) {\n                return val;\n            },\n            cm: function (val, el, win, styleAttr) {\n                return val * 37.79527559055118;\n            },\n            vw: function (val, el, win, styleAttr) {\n                return win[INNER_WIDTH] * val / 100;\n            },\n            em: function (val, el, win, styleAttr) {\n                return getStyleSize(el, 'fontSize') * val;\n            },\n            mm: function (val, el, win, styleAttr) {\n                return val * 3.779527559055118;\n            },\n            vmin: function (val, el, win, styleAttr) {\n                return ((Math.min(win[INNER_HEIGHT], win[INNER_WIDTH]) || 1) * val / 100);\n            },\n            rem: function (val, el, win, styleAttr) {\n                return getStyleSize(win[DOCUMENT][BODY][PARENT_NODE], 'fontSize') * val;\n            },\n            pt: function (val, el, win, styleAttr) {\n                return val * 1.333333333333333;\n            },\n            vmax: function (val, el, win, styleAttr) {\n                return ((Math.max(win[INNER_HEIGHT], win[INNER_WIDTH]) || 1) * val / 100);\n            },\n            '%': function (val, el, win, styleAttr) {\n                var parent = isElement(el) ? el[PARENT_NODE] : el,\n                    _val = getStyleSize(parent, styleAttr);\n                return (val * _val) / 100;\n            },\n            pc: function (val, el, win, styleAttr) {\n                return val * 16;\n            }\n        },\n        unitsToNum = function (str, el, winTop, styleAttr) {\n            var ret, number, unit = units(str);\n            if (!unit) {\n                return str;\n            }\n            number = +(str.split(unit).join('')) || 0;\n            if (unitToNumber[unit]) {\n                number = unitToNumber[unit](number, el, winTop, styleAttr) || 0;\n            }\n            return number;\n        },\n        /**\n         * @private\n         * @func\n         */\n        containsClass = function (el, className) {\n            var original = getClassName(el),\n                nuClasses = gapSplit(className),\n                nuClassesLen = nuClasses[LENGTH],\n                i = 0,\n                has = 0;\n            for (; i < nuClassesLen; i++) {\n                if (posit(original, nuClasses[i])) {\n                    has++;\n                }\n            }\n            return (has === nuClassesLen);\n        },\n        /**\n         * @private\n         * @func\n         */\n        tagIs = function (el, str) {\n            var tagName;\n            if (el && isObject(el)) {\n                tagName = el.tagName;\n                if (isString(tagName)) {\n                    return tagName.toLowerCase() === str.toLowerCase();\n                }\n            }\n        },\n        /**\n         * @private\n         * @func\n         */\n        isTrustedEvent = function (name) {\n            return (indexOf(trustedEvents, name) !== -1);\n        },\n        /**\n         * @private\n         * @func\n         */\n        createElement = function (str) {\n            return sizzleDoc.createElement(str);\n        },\n        makeEmptyFrame = function (str) {\n            var frame, div = createElement('div');\n            div.innerHTML = str;\n            frame = div.children[0];\n            return $(frame);\n        },\n        makeTree = function (str) {\n            var div = createElement('div');\n            div.innerHTML = str;\n            return $(div.children).remove().unwrap();\n        },\n        /**\n         * @private\n         * @func\n         */\n        matches = function (element, selector) {\n            var match, parent, temp, matchesSelector;\n            if (!selector || !element || element[NODE_TYPE] !== 1) {\n                return BOOLEAN_FALSE;\n            }\n            matchesSelector = element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector;\n            if (matchesSelector) {\n                return matchesSelector.call(element, selector);\n            }\n            // fall back to performing a selector:\n            parent = element[PARENT_NODE];\n            temp = !parent;\n            if (temp) {\n                parent = createElement('div');\n                parent.appendChild(element);\n            }\n            // temp && tempParent.removeChild(element);\n            return !!posit(Sizzle(selector, parent), element);\n        },\n        /**\n         * @private\n         * @func\n         */\n        eachProc = function (fn) {\n            return function () {\n                var args = toArray(arguments),\n                    domm = this;\n                args.unshift(domm);\n                domm.duff(function (el) {\n                    args[0] = el;\n                    fn.apply(domm, args);\n                });\n                return domm;\n            };\n        },\n        createDocumentFragment = function () {\n            return sizzleDoc.createDocumentFragment();\n        },\n        /**\n         * @private\n         * @func\n         */\n        createElements = function (tagName) {\n            return $(foldl(gapSplit(tagName), function (memo, name) {\n                memo.push(createElement(name));\n                return memo;\n            }, []));\n        },\n        fragment = function (el) {\n            var frag;\n            if (isFragment(el)) {\n                frag = el;\n            } else {\n                frag = createDocumentFragment();\n                $(el).duff(ensureDOM(function (el) {\n                    frag.appendChild(el);\n                }));\n            }\n            return frag;\n        },\n        // createElements = function (arr, tag, style, props, attrs) {\n        //     var frag = createDocumentFragment();\n        //     map(arr, function (str) {\n        //         var div = createElement(tag || 'div');\n        //         div.innerHTML = str;\n        //         each(style, function (key, val) {\n        //             div[STYLE][key] = val;\n        //         });\n        //         each(props, function (key, val) {\n        //             div[key] = val;\n        //         });\n        //         each(attrs, function (key, val) {\n        //             attributeInterface(div, key, val);\n        //         });\n        //         frag.appendChild(div);\n        //     });\n        //     return frag;\n        // },\n        /**\n         * @private\n         * @func\n         */\n        htmlTextManipulator = function (attr) {\n            return function (str) {\n                var dom = this,\n                    nuStr = '';\n                if (isString(str)) {\n                    return dom.duff(function (el) {\n                        el[attr] = str;\n                    });\n                } else {\n                    dom.duff(function (el) {\n                        nuStr += el[attr];\n                    });\n                    return nuStr;\n                }\n            };\n        },\n        horizontalTraverser = function (_idxChange) {\n            return attachPrevious(function (idxChange) {\n                var domm = this,\n                    collected = [],\n                    list = domm.unwrap();\n                idxChange = _idxChange || idxChange;\n                if (idxChange) {\n                    duff(list, function (idx_, el) {\n                        var parent = el[PARENT_NODE],\n                            idx = (indexOf(parent.children, el) + idxChange),\n                            item = parent.children[idx];\n                        if (item && !posit(list, item)) {\n                            add(collected, item);\n                        }\n                    });\n                } else {\n                    collected = list;\n                }\n                return collected;\n            });\n        },\n        domAttrManipulator = function (fn, getData) {\n            // cant wrap in each because need to return custom data\n            return function (key, value) {\n                var dataKeys = [],\n                    dom = this,\n                    ret = {},\n                    count = 0,\n                    cachedData = [],\n                    domList = dom.unwrap();\n                // moved to outside because iterating over objects is more\n                // time consuming than iterating over a straight list\n                intendedObject(key, value, function (__key, val) {\n                    var __keys = gapSplit(__key);\n                    dataKeys.push(__key);\n                    duff(domList, function (el, idx) {\n                        var data;\n                        if (getData) {\n                            data = cachedData[idx] = cachedData[idx] || elementData.get(el);\n                        }\n                        duff(__keys, function (_key) {\n                            var value = fn(el, _key, val, data, dom);\n                            if (value !== blank) {\n                                ret[_key] = value;\n                                count++;\n                            }\n                        });\n                    });\n                });\n                if (dataKeys[LENGTH] === 1) {\n                    if (count === 1) {\n                        ret = ret[dataKeys[0]];\n                    } else {\n                        if (!count) {\n                            ret = dom;\n                        }\n                    }\n                } else {\n                    ret = dom;\n                }\n                return ret;\n            };\n        },\n        attachPrevious = function (fn) {\n            return function () {\n                var prev = this;\n                // ensures it's still a dom object\n                var obj = $(fn.apply(this, arguments));\n                obj._previous = prev;\n                return obj;\n            };\n        },\n        // coordinates\n        covers = function (element, coords) {\n            var _clientRect = clientRect(element),\n                bottom = _clientRect[BOTTOM],\n                right = _clientRect[RIGHT],\n                left = _clientRect[LEFT],\n                tippytop = _clientRect[TOP],\n                x = coords.x,\n                y = coords.y,\n                ret = BOOLEAN_FALSE;\n            if (x > left && x < right && y > tippytop && y < bottom) {\n                ret = BOOLEAN_TRUE;\n            }\n            return ret;\n        },\n        center = function (clientRect) {\n            return {\n                x: clientRect[LEFT] + (clientRect[WIDTH] / 2),\n                y: clientRect[TOP] + (clientRect[HEIGHT] / 2)\n            };\n        },\n        distance = function (a, b) {\n            var xdiff = a.x - b.x,\n                ydiff = a.y - b.y;\n            return Math.sqrt((xdiff * xdiff) + (ydiff * ydiff));\n        },\n        closer = function (center, current, challenger) {\n            return distance(center, current) < distance(center, challenger);\n        },\n        createSelector = function (domm, args, fn) {\n            var fun, selector, name = args.shift();\n            if (isString(args[0]) || isBlank(args[0])) {\n                selector = args.shift();\n            }\n            if (isFunction(args[0])) {\n                fn = bind(fn, domm);\n                fun = args[0];\n                duff(gapSplit(name), function (nme) {\n                    var split = eventToNamespace(nme),\n                        captures = BOOLEAN_FALSE,\n                        namespaceSplit = nme.split('.'),\n                        nm = namespaceSplit.shift(),\n                        namespace = namespaceSplit.join('.');\n                    if (nm[0] === '_') {\n                        nm = nm.slice(1);\n                        captures = BOOLEAN_TRUE;\n                    }\n                    fn(nm, namespace, selector, fun, captures);\n                });\n            }\n        },\n        ensureOne = function (fn) {\n            return function () {\n                if (this[LENGTH]()) {\n                    fn.apply(this, arguments);\n                }\n                return this;\n            };\n        },\n        expandEventListenerArguments = function (fn) {\n            return ensureOne(function () {\n                var args, obj, selector, domm = this;\n                // if there's nothing selected, then do nothing\n                args = toArray(arguments);\n                obj = args.shift();\n                // intendedObject(obj, null, function () {});\n                if (isObject(obj)) {\n                    if (isString(args[0])) {\n                        selector = args.shift();\n                    }\n                    each(obj, function (key, handlers) {\n                        createSelector(domm, [key, selector, handlers].concat(args), fn);\n                    });\n                } else {\n                    args.unshift(obj);\n                    createSelector(domm, args, fn);\n                }\n            });\n        },\n        validateEvent = function (evnt, el) {\n            return !isString(evnt) ? evnt : {\n                type: evnt,\n                bubbles: BOOLEAN_FALSE,\n                eventPhase: 2,\n                cancelable: BOOLEAN_FALSE,\n                defaultPrevented: BOOLEAN_FALSE,\n                data: '',\n                isTrusted: BOOLEAN_FALSE,\n                timeStamp: now(),\n                target: el\n            };\n        },\n        isCapturing = function (evnt) {\n            var capturing = BOOLEAN_FALSE,\n                eventPhase = evnt.eventPhase;\n            if (eventPhase === 1) {\n                capturing = BOOLEAN_TRUE;\n            }\n            if (eventPhase === 2 && !evnt.bubbles && isElement(evnt.srcElement)) {\n                capturing = BOOLEAN_TRUE;\n            }\n            return capturing;\n        },\n        findMatch = function (el, target, selector) {\n            var parent, found = NULL;\n            if (selector && isString(selector)) {\n                parent = target;\n                while (parent && !found && isElement(parent) && parent !== el) {\n                    if (matches(parent, selector)) {\n                        found = parent;\n                    }\n                    parent = parent[PARENT_NODE];\n                }\n            }\n            return found;\n        },\n        getMainHandler = function (data, name, capturing) {\n            return data.handlers[capturing + ':' + name];\n        },\n        eventDispatcher = function (el, e, args, list) {\n            var $el = DOMM(el);\n            return find(list, function (obj) {\n                var selectorsMatch, ctx, originalTarget = e.currentTarget,\n                    mainHandler = obj.mainHandler;\n                if (mainHandler.currentEvent) {\n                    return BOOLEAN_TRUE;\n                }\n                mainHandler.currentEvent = obj;\n                if (obj && obj.persist && !obj.disabled) {\n                    if (obj.selector) {\n                        ctx = findMatch(el, evnt.target, obj.selector);\n                        if (ctx) {\n                            e.currentTarget = ctx;\n                        } else {\n                            mainHandler.currentEvent = NULL;\n                            return;\n                        }\n                    }\n                    obj.fn.apply(ctx || $el, args);\n                }\n                if (!obj.persist) {\n                    // puts it on the event queue\n                    removeEventQueue(obj);\n                }\n                e.currentTarget = originalTarget;\n                mainHandler.currentEvent = NULL;\n                return e.isImmediatePropagationStopped;\n            });\n        },\n        dispatchEvent = function (el, evnt_, capturing, data, args, selector) {\n            var e, gah, list, capturingStack, events, stack, currentEventStack, selectorIsString, mainHandler, eventType, removeStack, $el, matches = 1,\n                evnt = validateEvent(evnt_, el);\n            if (!evnt || !evnt.type) {\n                return;\n            }\n            capturing = !!capturing;\n            if (!_.isObject(data)) {\n                data = elementData.get(el);\n            }\n            events = data.events;\n            capturingStack = events[capturing];\n            if (!capturingStack) {\n                return;\n            }\n            eventType = evnt.type;\n            list = capturingStack[eventType];\n            mainHandler = getMainHandler(data, eventType, capturing);\n            if (!mainHandler) {\n                return;\n            }\n            removeStack = mainHandler[REMOVE_QUEUE];\n            e = new Event(evnt, el);\n            args = [e].concat(args || []);\n            wraptry(function () {\n                eventDispatcher(el, e, args, list);\n            }, function () {\n                console.trace(e);\n            });\n            duffRev(removeStack, removeEventQueue);\n            while (mainHandler[ADD_QUEUE][LENGTH]) {\n                addEventQueue(mainHandler[ADD_QUEUE][0]);\n                gah = mainHandler[ADD_QUEUE].shift();\n            }\n        },\n        matchesHandler = function (handler, obj) {\n            return !handler || obj.fn === handler;\n        },\n        _eventExpander = wrap({\n            ready: 'DOMContentLoaded',\n            deviceorientation: 'deviceorientation mozOrientation',\n            fullscreenalter: 'webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange',\n            hover: 'mouseenter mouseleave',\n            forcetouch: 'webkitmouseforcewillbegin webkitmouseforcedown webkitmouseforceup webkitmouseforcechanged'\n        }, function (val) {\n            return gapSplit(val);\n        }),\n        distilledEventName = foldl(_eventExpander, function (memo, arr, key) {\n            duff(arr, function (item) {\n                memo[item] = key;\n            });\n            return memo;\n        }, {}),\n        eventExpander = function (fn_) {\n            return function (nme) {\n                var fn = bind(fn_, this);\n                duff(gapSplit(_eventExpander[nme] || nme), function (name) {\n                    fn(name, nme);\n                });\n            };\n        },\n        addEventListener = expandEventListenerArguments(function (name, namespace, selector, callback, capture) {\n            var dom = this;\n            if (isFunction(callback)) {\n                return dom;\n            }\n            dom.duff(function (el) {\n                _addEventListener(el, name, namespace, selector, callback, capture);\n            });\n            return dom;\n        }),\n        eventToNamespace = function (evnt) {\n            if (!isString(evnt)) {\n                evnt = evnt.type;\n            }\n            evnt = evnt.split('.');\n            var evntName = evnt.shift();\n            return [evntName, evnt.sort().join('.')];\n        },\n        _addEventListener = function (el, types, namespace, selector, fn, capture) {\n            var handleObj, eventHandler, data = elementData.get(el),\n                handlers = data.handlers = data.handlers || {},\n                events = data.events = data.events || {},\n                capturehash = events[capture] = events[capture] || {};\n            duff(gapSplit(types), eventExpander(function (name, passedName) {\n                var attach, mainHandler, handlerKey = capture + ':' + name,\n                    namespaceCache = capturehash[name] = capturehash[name] || [];\n                mainHandler = handlers[handlerKey];\n                if (!mainHandler) {\n                    eventHandler = function (e) {\n                        return dispatchEvent(this, e, capture, data);\n                    };\n                    handlers[handlerKey] = mainHandler = {\n                        fn: eventHandler,\n                        __delegateCount: 0,\n                        addQueue: [],\n                        removeQueue: [],\n                        currentEvent: NULL,\n                        capturing: capture\n                    };\n                    el.addEventListener(name, eventHandler, capture);\n                }\n                attach = find(namespaceCache, function (obj) {\n                    // remove any duplicates\n                    if (fn === obj.fn && obj.namespace === namespace && selector === obj.selector) {\n                        return BOOLEAN_TRUE;\n                    }\n                });\n                if (attach) {\n                    return;\n                }\n                addEventQueue({\n                    fn: fn,\n                    persist: BOOLEAN_TRUE,\n                    disabled: BOOLEAN_FALSE,\n                    list: namespaceCache,\n                    namespace: namespace,\n                    mainHandler: mainHandler,\n                    selector: selector,\n                    name: name,\n                    passedName: passedName\n                });\n            }));\n        },\n        addEventQueue = function (obj) {\n            var mainHandler = obj.mainHandler,\n                selector = obj.selector;\n            if (!mainHandler.currentEvent) {\n                if (selector) {\n                    obj.list.splice(mainHandler[DELEGATE_COUNT]++, 0, obj);\n                } else {\n                    obj.list.push(obj);\n                }\n            } else {\n                mainHandler[ADD_QUEUE].push(obj);\n            }\n        },\n        removeEventQueue = function (obj, idx) {\n            var gah, mainHandler = obj.mainHandler,\n                list = obj.list,\n                selector = obj.selector;\n            if (!mainHandler.currentEvent) {\n                if (!obj.isDestroyed) {\n                    obj.isDestroyed = BOOLEAN_TRUE;\n                    idx = idx === blank ? list.indexOf(obj) : idx;\n                    if (idx + 1) {\n                        if (selector) {\n                            mainHandler[DELEGATE_COUNT]--;\n                        }\n                        gah = list.splice(idx, 1);\n                    }\n                    obj.list = NULL;\n                }\n            } else {\n                if (obj.persist) {\n                    mainHandler[REMOVE_QUEUE].push(obj);\n                }\n            }\n            obj.persist = BOOLEAN_FALSE;\n        },\n        ensureHandlers = function (fn) {\n            return function (name) {\n                // var args = toArray(arguments);\n                var args = ['', blank, []],\n                    origArgs = filter(arguments, negate(isBlank)),\n                    argLen = origArgs[LENGTH];\n                if (!isObject(name)) {\n                    if (argLen === 1) {\n                        args = [name, blank, [blank]];\n                    }\n                    if (argLen === 2) {\n                        args = [name, blank, arguments[1]];\n                    }\n                }\n                if (argLen === 3) {\n                    args = arguments;\n                }\n                return fn.apply(this, args);\n            };\n        },\n        removeEventListener = ensureHandlers(expandEventListenerArguments(function (name, namespace, selector, handler, capture) {\n            this.duff(function (el) {\n                _removeEventListener(el, name, namespace, selector, handler, capture);\n            });\n        })),\n        removeEvent = function (obj) {\n            var mainHandler = obj.mainHandler;\n            if (obj.selector) {\n                mainHandler[DELEGATE_COUNT] = Math.max(mainHandler[DELEGATE_COUNT] - 1, 0);\n            }\n            _.remove(obj.list, obj);\n        },\n        _removeEventListener = function (el, name, namespace, selector, handler, capture) {\n            var objs, vent, current, data = elementData.get(el),\n                // currentStack = data[currentEventStackString],\n                events = data.events,\n                removeFromList = function (list, name) {\n                    duffRev(list, function (obj) {\n                        if ((!name || name === obj.name) && (!handler || obj.fn === handler) && (!namespace || obj.namespace === namespace) && (!selector || obj.selector === selector)) {\n                            removeEventQueue(obj);\n                        }\n                    });\n                };\n            if (events) {\n                objs = events[capture];\n                if (name) {\n                    // scan a select list\n                    removeFromList(objs[name], name);\n                } else {\n                    // scan all of the lists\n                    each(objs, removeFromList);\n                }\n            }\n        },\n        /**\n         * @class DOMM\n         * @augments Model\n         * @augments Collection\n         */\n        fixHooks = {\n            // Includes some event props shared by KeyEvent and MouseEvent\n            props: gapSplit(\"data altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\"),\n            fixedHooks: {},\n            keyHooks: {\n                props: gapSplit(\"char charCode key keyCode\"),\n                filter: function (evnt, original) {\n                    var charCode;\n                    // Add which for key evnts\n                    if (isBlank(evnt.which)) {\n                        charCode = original.charCode;\n                        evnt.which = !isBlank(charCode) ? charCode : original.keyCode;\n                    }\n                    return evnt;\n                }\n            },\n            forceHooks: {\n                props: [],\n                filter: function (evnt, original) {\n                    evnt.value = (original.webkitForce / 3) || original;\n                    return evnt;\n                }\n            },\n            mouseHooks: {\n                props: gapSplit(\"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\"),\n                filter: function (evnt, original) {\n                    var eventDoc, doc, body,\n                        button = original.button;\n                    // Calculate pageX/Y if missing and clientX/Y available\n                    if (isBlank(evnt.pageX) && !isBlank(original.clientX)) {\n                        evntDoc = evnt.target.ownerDocument || sizzleDoc;\n                        doc = evntDoc.documentElement;\n                        body = evntDoc[BODY];\n                        evnt.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n                        evnt.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n                    }\n                    evnt.movementX = original.movementX || 0;\n                    evnt.movementY = original.movementY || 0;\n                    evnt.layerX = original.layerX || 0;\n                    evnt.layerY = original.layerY || 0;\n                    evnt.x = original.x || 0;\n                    evnt.y = original.y || 0;\n                    // Add which for click: 1 === left; 2 === middle; 3 === right\n                    // Note: button is not normalized, so don't use it\n                    if (!evnt.which && button !== blank) {\n                        evnt.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));\n                    }\n                    return evnt;\n                }\n            },\n            make: function (evnt) {\n                var doc, target, val, originalEvent = evnt.originalEvent,\n                    // Create a writable copy of the event object and normalize some properties\n                    i, prop, copy,\n                    type = originalEvent.type,\n                    fixHook = fixHooks.fixedHooks[type];\n                if (!fixHook) {\n                    fixHooks.fixedHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : rforceEvent.test(type) ? this.forceHooks : {};\n                }\n                copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;\n                i = copy[LENGTH];\n                while (i--) {\n                    prop = copy[i];\n                    val = originalEvent[prop];\n                    if (!isBlank(val)) {\n                        evnt[prop] = val;\n                    }\n                }\n                evnt.originalType = originalEvent.type;\n                // Support: Cordova 2.5 (WebKit) (#13255)\n                // All events should have a target; Cordova deviceready doesn't\n                // ie also does not have a target... so use current target\n                target = evnt.target || (evnt.view ? evnt.view.event.currentTarget : event.currentTarget);\n                if (!target) {\n                    target = evnt.target = sizzleDoc;\n                }\n                // Support: Safari 6.0+, Chrome<28\n                // Target should not be a text node (#504, #13143)\n                if (target[NODE_TYPE] === 3) {\n                    evnt.target = target[PARENT_NODE];\n                }\n                if (isFunction(fixHook.filter)) {\n                    fixHook.filter(evnt, originalEvent);\n                }\n                evnt.type = distilledEventName[originalEvent.type] || originalEvent.type;\n                evnt.data = originalEvent.data || '';\n                evnt.isImmediatePropagationStopped = evnt.isPropagationStopped = evnt.isDefaultPrevented = BOOLEAN_FALSE;\n                // special\n                if (evnt.type === 'fullscreenchange') {\n                    doc = evnt.target;\n                    if (isWindow(doc)) {\n                        doc = doc[DOCUMENT];\n                    } else {\n                        while (doc && !isDocument(doc) && doc[PARENT_NODE]) {\n                            doc = doc[PARENT_NODE];\n                        }\n                    }\n                    evnt.fullscreenDocument = doc;\n                    if (isDocument(doc)) {\n                        evnt.isFullScreen = (doc.fullScreen || doc.webkitFullscreenElement || doc.mozFullScreenElement || doc.fullscreenElement) ? BOOLEAN_TRUE : BOOLEAN_FALSE;\n                    }\n                }\n                return evnt;\n            }\n        },\n        Event = factories.Model.extend('Event', {\n            constructor: function (evnt, el) {\n                var e = this;\n                e.originalEvent = evnt;\n                fixHooks.make(e);\n                evnt.delegateTarget = el;\n                return e;\n            },\n            preventDefault: function () {\n                var e = this.originalEvent;\n                this.isDefaultPrevented = BOOLEAN_TRUE;\n                if (e && e.preventDefault) {\n                    e.preventDefault();\n                }\n            },\n            stopPropagation: function () {\n                var e = this.originalEvent;\n                this.isPropagationStopped = BOOLEAN_TRUE;\n                if (e && e.stopPropagation) {\n                    e.stopPropagation();\n                }\n            },\n            stopImmediatePropagation: function () {\n                var e = this.originalEvent;\n                this.isImmediatePropagationStopped = BOOLEAN_TRUE;\n                if (e && e.stopImmediatePropagation) {\n                    e.stopImmediatePropagation();\n                }\n                this.stopPropagation();\n            }\n        }, BOOLEAN_TRUE),\n        createDomFilter = function (filtr) {\n            var filter;\n            if (isFunction(filtr)) {\n                filter = filtr;\n            } else {\n                if (isObject(filtr)) {\n                    filter = objectMatches(filtr);\n                } else {\n                    if (isString(filtr)) {\n                        filter = filterExpressions[filtr];\n                        if (!filter) {\n                            filter = function (item) {\n                                return matches(item, filtr);\n                            };\n                        }\n                    } else {\n                        if (isNumber(filtr)) {\n                            filter = function (el, idx) {\n                                return idx === filtr;\n                            };\n                        } else {\n                            filter = function () {\n                                return BOOLEAN_TRUE;\n                            };\n                        }\n                    }\n                }\n            }\n            return filter;\n        },\n        domFilter = function (items, filtr) {\n            var filter = createDomFilter(filtr);\n            return _.filter(items, filter);\n        },\n        dimFinder = function (element, doc, win) {\n            return function (num) {\n                var ret, el = this[INDEX](num);\n                if (isElement(el)) {\n                    ret = clientRect(el)[element];\n                } else {\n                    if (isDocument(el) && el[BODY]) {\n                        ret = el[BODY][doc];\n                    } else {\n                        if (isWindow(el)) {\n                            ret = el[win];\n                        }\n                    }\n                }\n                return ret || 0;\n            };\n        },\n        dommFind = attachPrevious(function (str) {\n            var dom = this,\n                matchers = [],\n                passedString = isString(str);\n            duff(dom.unwrap(), function (el) {\n                if (passedString) {\n                    duff(Sizzle(str, el), function (el) {\n                        matchers.push(el);\n                    });\n                } else {\n                    matchers.push(el);\n                }\n            });\n            return matchers;\n        }),\n        canBeProcessed = function (item) {\n            return isElement(item) || isWindow(item) || isDocument(item) || isFragment(item);\n        },\n        append = function (el) {\n            var dom = this,\n                firstEl = dom.first();\n            if (firstEl) {\n                firstEl.appendChild(fragment(el));\n            }\n            return dom;\n        },\n        DOMM = factories.DOMM = factories.Collection.extend('DOMM', extend({\n            /**\n             * @func\n             * @name DOMM#constructor\n             * @param {String | Node | Function} str - string to query the dom with, or a function to run on document load, or an element to wrap in a DOMM instance\n             * @returns {DOMM} instance\n             */\n            constructor: function (str, ctx) {\n                var i, els, handler, elsLen, $doc, docEl, docData, dom = this;\n                dom.context = ctx || win[DOCUMENT];\n                if (isFunction(str)) {\n                    if (isDocument(ctx)) {\n                        $doc = $(ctx);\n                        docEl = $doc[INDEX]();\n                        docData = elementData.get(docEl);\n                        handler = bind(str, $doc);\n                        if (docData.isReady) {\n                            // make it async\n                            _.AF.once(function () {\n                                handler($, docData.DOMContentLoadedEvent);\n                            });\n                            els = dom.unwrap();\n                        } else {\n                            dom = $doc.on('DOMContentLoaded', function (e) {\n                                handler($, e);\n                            });\n                            els = dom.unwrap();\n                        }\n                    }\n                } else {\n                    if (isString(str)) {\n                        if (str[0] === '<') {\n                            els = makeTree(str);\n                        } else {\n                            els = Sizzle(str, ctx);\n                        }\n                    } else {\n                        els = str;\n                        if (!isArray(els) && canBeProcessed(els)) {\n                            els = [els];\n                        }\n                    }\n                }\n                Collection.constructor.call(dom, els);\n                return dom;\n            },\n            /**\n             * @func\n             * @name DOMM#isWin\n             * @description asks if the first or specified index of the object is a window type object\n             * @returns {Boolean}\n             */\n            isWindow: function (num) {\n                return isWindow(this[INDEX](num || 0) || {});\n            },\n            isElement: function (num) {\n                return isElement(this[INDEX](num || 0) || {});\n            },\n            /**\n             * @func\n             * @name DOMM#isDoc\n             * @description asks if the first or specified index of the object is a document type object\n             * @returns {Boolean}\n             */\n            isDocument: function (num) {\n                return isDocument(this[INDEX](num || 0) || {});\n            },\n            isFragment: function (num) {\n                return isFragment(this[INDEX](num || 0) || {});\n            },\n            fragment: function (el) {\n                return fragment(el || (this && this[ITEMS]));\n            },\n            /**\n             * @func\n             * @name DOMM#filter\n             * @param {String|Function|Object} filtr - filter variable that will filter by matching the object that is passed in, or by selector if it is a string, or simply with a custom function\n             * @returns {DOMM} new DOMM instance object\n             */\n            filter: attachPrevious(function (filter) {\n                return domFilter(this.unwrap(), filter);\n            }),\n            /**\n             * @func\n             * @name DOMM#find\n             * @param {String} str - string to use sizzle to find against\n             * @returns {DOMM} matching elements\n             */\n            find: dommFind,\n            $: dommFind,\n            /**\n             * @func\n             * @name DOMM#children\n             * @param {Number} [eq] - index of the children to gather. If none is provided, then all children will be added\n             * @returns {DOMM} all / matching children\n             */\n            children: attachPrevious(function (eq) {\n                var dom = this,\n                    items = dom.unwrap(),\n                    filter = createDomFilter(eq);\n                return foldl(items, function (memo, el) {\n                    return foldl(el.children || el.childNodes, function (memo, child, idx, children) {\n                        if (filter(child, idx, children)) {\n                            memo.push(child);\n                        }\n                        return memo;\n                    }, memo);\n                }, []);\n            }),\n            /**\n             * @func\n             * @name DOMM#offAll\n             * @returns {DOMM} instance\n             */\n            wipeEvents: function () {\n                return this.duff(function (el) {\n                    var data = elementData.get(el);\n                    each(data.handlers, function (key, fn, eH) {\n                        var wasCapt, split = key.split(':');\n                        eH[key] = blank;\n                        wasCapt = data.events[split[0]];\n                        if (wasCapt) {\n                            wasCapt[split[1]] = [];\n                        }\n                    });\n                    elementData.remove(el);\n                });\n            },\n            /**\n             * @name DOMM#off\n             * @param {String|Function} type - event type\n             * @param {Function} handler - specific event handler to be removed\n             * @returns {DOMM} instnace\n             */\n            on: addEventListener,\n            off: removeEventListener,\n            addEventListener: addEventListener,\n            removeEventListener: removeEventListener,\n            dispatchEvent: expandEventListenerArguments(eachProc(dispatchEvent)),\n            /**\n             * @func\n             * @name DOMM#once\n             * @param {String} space delimited list of event names to attach handlers to\n             * @param {Function} fn - handler to put on the event loop\n             * @returns {DOMM} instance\n             */\n            once: expandEventListenerArguments(eachProc(function (el, types, namespace, selector, fn, capture) {\n                var args = toArray(arguments);\n                args[4] = once(function () {\n                    _removeEventListener.apply(NULL, args);\n                    return fn.apply(this, arguments);\n                });\n                _addEventListener.apply(NULL, args);\n            })),\n            /**\n             * @func\n             * @name DOMM#css\n             * @param {...*} splat of objects and key value pairs that create a single object to be applied to the element\n             * @returns {DOMM} instance\n             */\n            css: ensureOne(function (key, value) {\n                var dom = this,\n                    ret = css(dom.unwrap(), key, value);\n                if (isBlank(ret)) {\n                    ret = dom;\n                }\n                return ret;\n            }),\n            style: ensureOne(function (key, value) {\n                style(this.unwrap(), key, value);\n                return this;\n            }),\n            /**\n             * @func\n             * @name DOMM#allDom\n             * @returns {Boolean} value indicating whether or not there were any non dom elements found in the collection\n             */\n            allElements: function () {\n                var count = 0,\n                    length = this[LENGTH](),\n                    result = length && find(this.unwrap(), negate(isElement));\n                return length && result === blank;\n            },\n            /**\n             * @func\n             * @name DOMM#height\n             * @returns {Number} height of the first object, adjusting for the different types of possible objects such as dom element, document or window\n             */\n            height: dimFinder(HEIGHT, 'scrollHeight', 'innerHeight'),\n            /**\n             * @func\n             * @name DOMM#width\n             * @returns {Number} width of the first object, adjusting for the different types of possible objects such as dom element, document or window\n             */\n            width: dimFinder(WIDTH, 'scrollWidth', 'innerWidth'),\n            /**\n             * @func\n             * @name DOMM#getStyle\n             * @retuns {Object} the get computed result or a blank object if first or defined index is not a dom element and therefore cannot have a style associated with it\n             */\n            getStyle: function (eq) {\n                var ret = {},\n                    first = this.get();\n                if (first && isElement(first)) {\n                    ret = getComputed(first, this.context);\n                }\n                return ret;\n            },\n            /**\n             * @func\n             * @name DOMM#data\n             * @param {...*} splat of objects and key value pairs that create a single object to be applied to the element\n             * @returns {Object|*} can return the value that is asked for by the initial function call\n             */\n            data: domAttrManipulator(function (el, _key, val, data, dom) {\n                var value, dataStr = 'data-',\n                    sliced = _key.slice(0, 5),\n                    key = _key;\n                if (dataStr !== sliced) {\n                    key = dataStr + _key;\n                }\n                key = unCamelCase(key);\n                value = attributeInterface(el, key, val);\n                if (value !== blank) {\n                    data.dataset[_key] = value;\n                }\n                return value;\n            }, BOOLEAN_TRUE),\n            /**\n             * @func\n             * @name DOMM#attr\n             * @param {...*} splat of objects and key value pairs that create a single object to be applied to the element\n             * @returns {DOMM|*} if multiple attributes were requested then a plain hash is returned, otherwise the DOMM instance is returned\n             */\n            attr: domAttrManipulator(function (el, _key, val, data, dom) {\n                return attributeInterface(el, unCamelCase(_key), val);\n            }),\n            prop: domAttrManipulator(function (el, key, val, data, dom) {\n                var value;\n                if (isBlank(val)) {\n                    value = el[key];\n                    if (isBlank(value)) {\n                        value = NULL;\n                    }\n                } else {\n                    if (isBlank(val)) {\n                        val = blank;\n                    }\n                    el[key] = val;\n                }\n                return value;\n            }),\n            /**\n             * @func\n             * @name DOMM#eq\n             * @param {Number|Array} [num=0] - index or list of indexes to create a new DOMM element with.\n             * @returns {DOMM} instance\n             */\n            eq: attachPrevious(function (num) {\n                return eq(this.unwrap(), num);\n            }),\n            /**\n             * @func\n             * @name DOMM#clientRect\n             * @param {Number} [num=0] - item who's bounding client rect will be assessed and extended\n             * @returns {Object} hash of dimensional properties (getBoundingClientRect)\n             */\n            clientRect: function (num) {\n                return clientRect(eq(this.unwrap(), num)[0]);\n            },\n            /**\n             * @func\n             * @name DOMM#each\n             * @param {Function} callback - iterator to apply to each item on the list\n             * @param {Boolean} elOnly - switches the first argument from a DOMM wrapped object to the Node itself\n             * @returns {DOMM} instance\n             */\n            each: function (callback) {\n                var domm = this;\n                if (domm[LENGTH]()) {\n                    callback = bind(callback, domm);\n                    duff(domm[ITEMS], function (item_, index, all) {\n                        var item = $([item_]);\n                        callback(item, index, all);\n                    });\n                }\n                return domm;\n            },\n            /**\n             * @func\n             * @name DOMM#addClass\n             * @param {String|Array} add - space delimited string that separates classes to be added through the change class function\n             * @returns {DOMM} instance\n             */\n            addClass: eachProc(function (el, add) {\n                changeClass(el, 0, add);\n            }),\n            /**\n             * @func\n             * @name DOMM#removeClass\n             * @param {String|Array} remove - space delimited string that separates classes to be removed through the change class function\n             * @returns {DOMM} instance\n             */\n            removeClass: eachProc(function (el, remove) {\n                changeClass(el, remove);\n            }),\n            /**\n             * @func\n             * @name DOMM#toggleClass\n             * @params {String|Array} list - space delimited string that separates classes to be removed and added through the change class function\n             * @returns {DOMM} instance\n             */\n            toggleClass: eachProc(function (el, list) {\n                var add = [],\n                    remove = [];\n                duff(gapSplit(list), function (item) {\n                    if (containsClass(el, item)) {\n                        remove.push(item);\n                    } else {\n                        add.push(item);\n                    }\n                });\n                changeClass(el, remove, add);\n            }),\n            /**\n             * @func\n             * @name DOMM#hasClass\n             * @param {String|Array} list - space delimited string that each element is checked againsts to ensure that it has the classs\n             * @returns {Boolean} do all of the elements in the collection have all of the classes listed\n             */\n            hasClass: function (clas) {\n                var dom = this,\n                    retVals = [],\n                    countLen = [],\n                    classes = gapSplit(clas);\n                dom.duff(function (el) {\n                    countLen.push(1);\n                    if (containsClass(el, clas)) {\n                        retVals.push(1);\n                    }\n                });\n                return (dom[LENGTH]() && countLen[LENGTH] === retVals[LENGTH]);\n            },\n            /**\n             * @func\n             * @name DOMM#changeClass\n             * @param {String|Array} [remove] - removes space delimited list or array of classes\n             * @param {String|Array} [add] - adds space delimited list or array of classes\n             * @returns {DOMM} instance\n             */\n            changeClass: eachProc(changeClass),\n            booleanClass: eachProc(function (el, add, remove) {\n                if (add) {\n                    add = remove;\n                    remove = [];\n                }\n                changeClass(el, remove, add);\n            }),\n            /**\n             * @func\n             * @name DOMM#box\n             * @param {Number} [num=0] - index to get the boxmodel of\n             */\n            box: function (num) {\n                return box(this[INDEX](num), this.context);\n            },\n            flow: function (num) {\n                return flow(this[index](num), this.context);\n            },\n            /**\n             * @func\n             * @name DOMM#end\n             * @returns {DOMM} object that started the traversal chain\n             */\n            end: function () {\n                var that = this;\n                while (that._previous) {\n                    that = that._previous;\n                }\n                return that;\n            },\n            /**\n             * @func\n             * @name DOMM#hide\n             * @description sets all elements to display\n             * @returns {DOMM} instance\n             */\n            hide: eachProc(ensureDOM(function (el) {\n                el[STYLE].display = 'none';\n            })),\n            /**\n             * @func\n             * @name DOMM#show\n             */\n            show: eachProc(ensureDOM(function (el) {\n                el[STYLE].display = 'block';\n            })),\n            /**\n             * @func\n             * @name DOMM#append\n             */\n            append: append,\n            /**\n             * @func\n             * @name DOMM#next\n             * @returns {DOMM} instance\n             */\n            next: horizontalTraverser(1),\n            /**\n             * @func\n             * @name DOMM#previous\n             * @returns {DOMM} instance\n             */\n            prev: horizontalTraverser(-1),\n            /**\n             * @func\n             * @name DOMM#skip\n             * @returns {DOMM} instance\n             */\n            skip: horizontalTraverser(0),\n            /**\n             * @func\n             * @name DOMM#insertAt\n             * @returns {DOMM} instance\n             */\n            insertAt: function (els, idx) {\n                var point, dom = this,\n                    frag = fragment(els),\n                    children = dom.children();\n                if (!idx && !isNumber(idx)) {\n                    point = {};\n                }\n                if (isNumber(idx)) {\n                    point = children.eq(idx);\n                }\n                if (isString(idx)) {\n                    point = dom.children().filter(idx);\n                }\n                if (isInstance(point, DOMM)) {\n                    point = point[INDEX](0);\n                }\n                if (!_.isElement(point)) {\n                    point = NULL;\n                }\n                dom.duff(function (el) {\n                    el.insertBefore(frag, point);\n                });\n                return dom;\n            },\n            /**\n             * @func\n             * @name DOMM#remove\n             * @returns {DOMM} instance\n             */\n            remove: eachProc(function (el) {\n                var parent = el[PARENT_NODE];\n                if (isObject(parent) && isFunction(parent.removeChild)) {\n                    parent.removeChild(el);\n                }\n            }),\n            /**\n             * @func\n             * @name DOMM#parent\n             * @param {Number} [count=1] - number of elements to go up in the parent chain\n             * @returns {DOMM} instance of collected, unique parents\n             */\n            parent: (function () {\n                var finder = function (collect, fn, original) {\n                        return function (el) {\n                            var rets, found, parent = el,\n                                next = original;\n                            while (parent && !found) {\n                                rets = fn(parent[PARENT_NODE] || parent[DEFAULT_VIEW], original, next);\n                                parent = rets[0];\n                                found = rets[1];\n                                next = rets[2];\n                            }\n                            if (parent) {\n                                collect.push(parent);\n                            }\n                        };\n                    },\n                    number = function (parent, original, next) {\n                        next -= 1;\n                        if (next < 0 || !isFinite(next) || isNaN(next)) {\n                            next = 0;\n                        }\n                        return [parent, !next, next];\n                    },\n                    string = function (parent, original, next) {\n                        return [parent, matches(parent, original)];\n                    },\n                    speshal = {\n                        document: function (parent, original, next) {\n                            return [parent, isDocument(parent)];\n                        },\n                        window: function (parent, original, next) {\n                            return [parent, isWindow(parent)];\n                        },\n                        iframe: function (parent, original, next) {\n                            var win, found = 1;\n                            if (isWindow(parent) && parent !== window[TOP]) {\n                                if (parent.location.protocol.indexOf('http') === -1) {\n                                    win = parent;\n                                    found = 1;\n                                    wraptry(function () {\n                                        parent = win.frameElement;\n                                        if (parent) {\n                                            found = 0;\n                                        }\n                                    }, function () {\n                                        found = 1;\n                                    });\n                                }\n                            }\n                            return [parent, (!found && parent)];\n                        }\n                    };\n                return attachPrevious(function (original) {\n                    var iterator, doDefault = 1,\n                        collect = Collection();\n                    if (isNumber(original)) {\n                        iterator = number;\n                    } else {\n                        if (isString(original)) {\n                            if (speshal[original]) {\n                                iterator = speshal[original];\n                            } else {\n                                iterator = string;\n                            }\n                        } else {\n                            if (original) {\n                                doDefault = 0;\n                            }\n                        }\n                    }\n                    if (doDefault) {\n                        if (!iterator) {\n                            iterator = number;\n                            original = 1;\n                        }\n                        this.duff(finder(collect, iterator, original));\n                    } else {\n                        this.duff(finder(collect, function (el) {\n                            return [el, original(el)];\n                        }));\n                    }\n                    return collect[ITEMS];\n                });\n            }()),\n            /**\n             * @func\n             * @name DOMM#has\n             * @param {Node|Array} els - list of elements to check the current instance against\n             * @returns {Boolean} whether or not the current domm element has all of the elements that were passed in\n             */\n            has: function (els) {\n                var has = 0,\n                    domm = this,\n                    list = domm[ITEMS];\n                if (_.isInstance(els, Collection)) {\n                    els = els.unwrap();\n                } else {\n                    if (isElement(els)) {\n                        els = [els];\n                    }\n                }\n                if (els[LENGTH]) {\n                    has = els[LENGTH];\n                }\n                find(els, function (el) {\n                    if (domm.posit(el)) {\n                        has--;\n                    }\n                });\n                return has === 0 && els && els[LENGTH];\n            },\n            /**\n             * @func\n             * @name DOMM#indexOf\n             * @param {Node|Array} el - element to check against the collection\n             * @returns {Number} index of the element\n             */\n            indexOf: function (el, lookAfter) {\n                if (isInstance(el, DOMM)) {\n                    el = el[INDEX]();\n                }\n                return indexOf(this[ITEMS], el, lookAfter);\n            },\n            /**\n             * @func\n             * @name DOMM#html\n             * @returns {DOMM} instance\n             */\n            html: htmlTextManipulator('innerHTML'),\n            /**\n             * @func\n             * @name DOMM#text\n             * @returns {DOMM} instance\n             */\n            text: htmlTextManipulator('innerText'),\n            /**\n             * @func\n             * @name DOMM#contentRect\n             * @returns {Object} dimensions of the content rectangle\n             */\n            contentRect: function (num) {\n                var box = this.box(num),\n                    pB = box.paddingBottom,\n                    pT = box.paddingTop,\n                    pR = box.paddingRight,\n                    pL = box.paddingLeft,\n                    bT = box.borderTop,\n                    bB = box.borderBottom,\n                    bR = box.borderRight,\n                    bL = box.borderLeft;\n                return {\n                    bottom: box[BOTTOM] - pB - bB,\n                    height: box[HEIGHT] - pT - bT - pB - bB,\n                    right: box[RIGHT] - pR - bR,\n                    width: box[WIDTH] - pL - bL - pR - bR,\n                    left: box[LEFT] + pL - bL,\n                    top: box[TOP] + pT - bT\n                };\n            },\n            /**\n             * @func\n             * @name DOMM#flowRect\n             * @returns {Object} dimensions of the flow rectangle: the amount of space the element should take up in the dom\n             */\n            flowRect: function () {\n                var box = this.box(0),\n                    mT = box.marginTop,\n                    mL = box.marginLeft,\n                    mB = box.marginBottom,\n                    mR = box.marginRight;\n                return {\n                    height: box[HEIGHT] + mT + mB,\n                    bottom: box[BOTTOM] + mB,\n                    width: box[WIDTH] + mR + mL,\n                    right: box[RIGHT] + mR,\n                    left: box[LEFT] + mL,\n                    top: box[TOP] + mT\n                };\n            },\n            /**\n             * @func\n             * @name DOMM#childOf\n             */\n            childOf: function (oParent_) {\n                var domm = this,\n                    _oParent = $(oParent_),\n                    children = domm.unwrap(),\n                    oParent = _oParent.unwrap();\n                return !!children[LENGTH] && !!oParent[LENGTH] && !find(oParent, function (_parent) {\n                    return find(children, function (child) {\n                        var parent = child,\n                            finding = BOOLEAN_TRUE;\n                        while (parent && finding) {\n                            if (_parent === parent) {\n                                finding = BOOLEAN_FALSE;\n                            }\n                            parent = parent[PARENT_NODE];\n                        }\n                        return finding;\n                    });\n                });\n            },\n            serialize: function () {\n                var domm = this,\n                    arr = [];\n                domm.each(function ($node) {\n                    var node = $node[INDEX](),\n                        children = $node.children().serialize(),\n                        obj = {\n                            tag: node.localName\n                        };\n                    if (children[LENGTH]) {\n                        obj.children = children;\n                    }\n                    if (node.innerText) {\n                        obj.innerText = node.innerText;\n                    }\n                    duff(node.attributes, function (attr) {\n                        obj[camelCase(attr.localName)] = attr.nodeValue;\n                    });\n                    arr.push(obj);\n                });\n                return arr;\n            },\n            stringify: function () {\n                return JSON.stringify(this.serialize());\n            }\n        }, _.wrap({\n            id: BOOLEAN_FALSE,\n            src: BOOLEAN_FALSE,\n            checked: BOOLEAN_FALSE,\n            disabled: BOOLEAN_FALSE,\n            tag: 'localName',\n            classes: 'className'\n        }, function (attr, api) {\n            if (!attr) {\n                attr = api;\n            }\n            return function (str) {\n                var item, setter = {};\n                if (isString(str)) {\n                    setter[attr] = str;\n                    return this.attr(setter);\n                }\n                item = this[INDEX](str);\n                if (item) {\n                    return item[attr];\n                }\n            };\n        }), wrap({\n            play: 'playing',\n            pause: 'paused'\n        }, triggerEventWrapper), wrap(gapSplit('blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu'), function (attr) {\n            return triggerEventWrapper(attr);\n        })), BOOLEAN_TRUE),\n        $ = _DOMM(sizzleDoc),\n        Sizzle = function (str, ctx) {\n            return (ctx || sizzleDoc).querySelectorAll(str);\n        };\n    _.exports({\n        covers: covers,\n        center: center,\n        closer: closer,\n        distance: distance,\n        css: css,\n        box: box,\n        fragment: fragment,\n        isElement: isElement,\n        isWindow: isWindow,\n        isDocument: isDocument,\n        isFragment: isFragment,\n        createElement: createElement,\n        createElements: createElements,\n        createDocumentFragment: createDocumentFragment,\n        Sizzle: Sizzle,\n        unitToNumber: unitToNumber,\n        numberToUnit: numberToUnit\n    });\n    app.addModuleArgs([$]);\n});","application.scope().module('View', function (module, app, _, factories, $) {\n    var blank, appVersion = app.version,\n        each = _.each,\n        duff = _.duff,\n        Box = factories.Box,\n        Collection = factories.Collection,\n        isArray = _.isArray,\n        isString = _.isString,\n        gapSplit = _.gapSplit,\n        bind = _.bind,\n        map = _.map,\n        has = _.has,\n        clone = _.clone,\n        result = _.result,\n        reduce = _.reduce,\n        protoProp = _.protoProp,\n        isFragment = _.isFragment,\n        isInstance = _.isInstance,\n        isFunction = _.isFunction,\n        isArrayLike = _.isArrayLike,\n        reverseParams = _.reverseParams,\n        intendedObject = _.intendedObject,\n        createDocumentFragment = _.createDocumentFragment,\n        INDEX = 'index',\n        LENGTH = 'length',\n        RENDER = 'render',\n        OPTIONS = 'options',\n        PARENT = 'parent',\n        CHILDREN = 'children',\n        PARENT_NODE = 'parentNode',\n        CONSTRUCTOR = 'constructor',\n        APPEND_CHILD_ELEMENTS = '_appendChildElements',\n        PROTOTYPE = 'prototype',\n        DISPATCH_EVENT = 'dispatchEvent',\n        REGION_MANAGER = 'regionManager',\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        templates = {},\n        compile = function (id, force) {\n            var matches, tag, template, attrs, templates_ = templates[appVersion] = templates[appVersion] || {},\n                templateFn = templates_[id];\n            if (templateFn && !force) {\n                return templateFn;\n            }\n            tag = $(id);\n            template = tag.html();\n            matches = template.match(/\\{\\{([\\w\\s\\d]*)\\}\\}/mgi);\n            attrs = map(matches || [], function (match) {\n                return {\n                    match: match,\n                    attr: match.split('{{').join('').split('}}').join('').trim()\n                };\n            });\n            // template = template.trim();\n            templateFn = templates_[id] = function (obj) {\n                var str = template,\n                    cloneResult = clone(obj);\n                duff(attrs, function (match) {\n                    if (!cloneResult[match.attr]) {\n                        cloneResult[match.attr] = '';\n                    }\n                    str = str.replace(match.match, cloneResult[match.attr]);\n                });\n                return str;\n            };\n            return templateFn;\n        },\n        makeDelegateEventKey = function (view, name) {\n            return name + '.delegateEvents' + view.cid;\n        },\n        makeDelegateEventKeys = function (view, key, namespace) {\n            if (namespace) {\n                namespace = '.' + namespace;\n            } else {\n                namespace = '';\n            }\n            var viewNamespace = 'delegateEvents' + view.cid;\n            return map(gapSplit(key), function (_key) {\n                var __key = _key.split('.');\n                if (__key[1] !== viewNamespace) {\n                    __key.splice(1, 0, viewNamespace);\n                    _key = __key.join('.');\n                }\n                return _key += namespace;\n            }).join(' ');\n        },\n        normalizeUIString = function (uiString, ui) {\n            return uiString.replace(/@ui\\.[a-zA-Z_$0-9]*/g, function (r) {\n                return ui[r.slice(4)];\n            });\n        },\n        // allows for the use of the @ui. syntax within\n        // a given key for triggers and events\n        // swaps the @ui with the associated selector.\n        // Returns a new, non-mutated, parsed events hash.\n        normalizeUIKeys = function (hash, ui) {\n            return reduce(hash, function (memo, val, key) {\n                var normalizedKey = Marionette.normalizeUIString(key, ui);\n                memo[normalizedKey] = val;\n                return memo;\n            }, {});\n        },\n        viewGetRegionPlacer = function (place) {\n            return function (key) {\n                var region, view = this,\n                    regionManager = view[place] = view[place] || RegionManager();\n                if (regionManager) {\n                    region = regionManager.get(key);\n                }\n                return region;\n            };\n        },\n        /**\n         * @class View\n         * @augments Model\n         * @augments Box\n         * @classDesc Objects that have one or more element associated with them, such as a template that needs constant updating from the data\n         */\n        // region views are useful if you're constructing different components\n        // from a separate place and just want it to be in the attach pipeline\n        // very useful for componentizing your ui\n        viewplucks = ['el', 'regionViews'],\n        pluckviews = function (from, to, props) {\n            duff(props, function (prop, idx) {\n                if (has(from, prop)) {\n                    to[prop] = from[prop];\n                }\n            });\n        },\n        View = factories.Box.extend('View', {\n            /**\n             * @func\n             * @name View # constructor\n             * @description constructor for new view object\n             * @param {Object | DOMM | Node} attributes - hash with non - circular data on it. Is set later with the Box constructor\n             * @param {Object} secondary - options such as defining the parent object, or the element if necessary\n             * @param {DOMM|Node} el - element or Node that is attached directly to the View object\n             * @returns {View} instance\n             */\n            tagName: 'div',\n            filter: BOOLEAN_TRUE,\n            getRegion: viewGetRegionPlacer(CHILDREN),\n            constructor: function (attributes, secondary) {\n                var model = this;\n                Box[CONSTRUCTOR].apply(model, arguments);\n                model._ensureElement();\n                model[RENDER]();\n                return model;\n            },\n            _ensureChildren: function () {\n                this[CHILDREN] = RegionManager();\n                this[CHILDREN][PARENT] = this;\n            },\n            $: function (selector) {\n                return this.el.find(selector);\n            },\n            template: function (ctx) {\n                return '';\n            },\n            _renderHTML: function () {\n                var view = this,\n                    innerHtml = result(view, 'template', view.toJSON());\n                view.el.html(innerHtml);\n            },\n            _appendChildElements: function () {\n                var view = this;\n                view[CHILDREN].eachCall(APPEND_CHILD_ELEMENTS);\n                return view;\n            },\n            _establishRegions: function () {\n                var regionsManager, view = this,\n                    regions = view._establishedRegions = view._establishedRegions || result(view, 'regions');\n                if (!view._establishedRegions) {\n                    return;\n                }\n                // add regions to the region manager\n                view[CHILDREN].establishRegions(regions);\n            },\n            render: function () {\n                var view = this;\n                view.isRendered = BOOLEAN_FALSE;\n                // prep the object with extra members (doc frags on regionviews,\n                // list of children to trigger events on)\n                // view._ensureBufferedViews();\n                // request extra data or something before rendering: dom is still completely intact\n                view[DISPATCH_EVENT]('before:render');\n                // unbinds and rebinds element only if it changes\n                view.setElement(view.el);\n                // update new element's attributes\n                view._setElAttributes();\n                // renders the html\n                view._renderHTML();\n                // gathers the ui elements\n                view._bindUIElements();\n                // ties regions back to newly formed parent template\n                view._establishRegions();\n                // console.log(view.parent.parent);\n                // tie the children of the region the the region's el\n                view[CHILDREN].eachCall('render');\n                // mark the view as rendered\n                view.isRendered = BOOLEAN_TRUE;\n                // dispatch the render event\n                view[DISPATCH_EVENT](RENDER);\n                return view;\n            },\n            setElement: function (element) {\n                var view = this,\n                    previousElement = view.el;\n                // detaches events with this view's namespace\n                // view._unDelegateEvents();\n                view._setElement(element);\n                if (previousElement !== view.el) {\n                    view._unDelegateEvents(previousElement);\n                    view._delegateEvents();\n                }\n                // attaches events with this view's namespace\n                return view;\n            },\n            // Creates the `this.el` and `this.$el` references for this view using the\n            // given `el`. `el` can be a CSS selector or an HTML string, a jQuery\n            // context or an element. Subclasses can override this to utilize an\n            // alternative DOM manipulation API and are only required to set the\n            // `this.el` property.\n            _setElement: function (el) {\n                this.el = $(el);\n            },\n            _createElement: function (tag) {\n                return $('<' + tag + '>');\n            },\n            // Ensure that the View has a DOM element to render into.\n            // If `this.el` is a string, pass it through `$()`, take the first\n            // matching element, and re-assign it to `el`. Otherwise, create\n            // an element from the `id`, `className` and `tagName` properties.\n            _ensureElement: function () {\n                var el, view = this,\n                    _elementSelector = view._elementSelector || result(view, 'el');\n                if (_elementSelector) {\n                    view._elementSelector = _elementSelector;\n                }\n                if (!isInstance(_elementSelector, factories.DOMM)) {\n                    if (isString(_elementSelector)) {\n                        // sets external element\n                        el = _elementSelector;\n                    } else {\n                        // defauts back to wrapping the element\n                        // creates internal element\n                        el = view._createElement(result(view, 'tagName'));\n                        // subclassed to expand the attributes that can be used\n                    }\n                    view.setElement(el);\n                }\n            },\n            _setElAttributes: function () {\n                var view = this;\n                var attrs = result(view, 'elementAttributes') || {};\n                if (view.className) {\n                    attrs['class'] = result(view, 'className');\n                }\n                view._setAttributes(attrs);\n            },\n            // Set attributes from a hash on this view's element.  Exposed for\n            // subclasses using an alternative DOM manipulation API.\n            _setAttributes: function (attributes) {\n                this.el.attr(attributes);\n            },\n            // pairs. Callbacks will be bound to the view, with `this` set properly.\n            // Uses event delegation for efficiency.\n            // Omitting the selector binds the event to `this.el`.\n            _delegateEvents: function (el, bindings_) {\n                var key, method, match,\n                    view = this,\n                    _elementEventBindings = view._elementEventBindings || view.elementEvents,\n                    bindings = bindings_ || _elementEventBindings,\n                    __events = {};\n                if (_elementEventBindings) {\n                    view._elementEventBindings = _elementEventBindings;\n                }\n                if (el) {\n                    each(bindings, function (key, methods_) {\n                        // assumes is array\n                        var methods = gapSplit(methods_);\n                        if (isFunction(methods_)) {\n                            methods = [methods_];\n                        }\n                        __events[makeDelegateEventKeys(view, key)] = map(methods, function (method, idx) {\n                            return bind(view[method] || method, view);\n                        });\n                    });\n                    el.on(__events);\n                }\n                return view;\n            },\n            _unDelegateEvents: function (el, bindings_) {\n                var key, method, match,\n                    view = this,\n                    _elementEventBindings = view._elementEventBindings || view.elementEvents,\n                    bindings = bindings_ || _elementEventBindings,\n                    __events = {};\n                if (_elementEventBindings) {\n                    view._elementEventBindings = _elementEventBindings;\n                }\n                if (!el) {\n                    return view;\n                }\n                each(bindings, function (key, methods_) {\n                    var method = bind(isString(methods_) ? view[methods_] : methods_, view);\n                    __events[makeDelegateEventKeys(view, key)] = method;\n                });\n                el.on(__events);\n                return view;\n            },\n            parentView: function () {\n                var found, view = this,\n                    parent = view[PARENT];\n                while (found && parent && !isInstance(parent, View)) {\n                    parent = parent[PARENT];\n                    if (isInstance(parent, View)) {\n                        found = parent;\n                    }\n                }\n                return found;\n            },\n            _bindUIElements: function () {\n                var view = this,\n                    _uiBindings = view._uiBindings || result(view, 'ui');\n                view.ui = view.ui || {};\n                if (_uiBindings) {\n                    return view;\n                }\n                // save it to skip the result call later\n                view._uiBindings = _uiBindings;\n                view.ui = map(_uiBindings, function (key, selector) {\n                    return view.$(selector);\n                });\n                return view;\n            },\n            _unBindUIElements: function () {\n                var view = this;\n                view.ui = view._uiBindings;\n            },\n            remove: function () {\n                var el, view = this;\n                Box[CONSTRUCTOR][PROTOTYPE].remove.apply(view, arguments);\n                // if you were not told to select something in\n                // _ensureElements then remove the view from the dom\n                view.detach();\n                return view;\n            },\n            _detachElement: function () {\n                var view = this,\n                    el = view.el && view.el[INDEX](0);\n                if (el && el[PARENT_NODE]) {\n                    el[PARENT_NODE].removeChild(el);\n                }\n            },\n            _removeViewElement: function (el, frag) {\n                var parent = this;\n                if (frag) {\n                    frag.appendChild(el);\n                } else {\n                    if (el[PARENT_NODE]) {\n                        el[PARENT_NODE].removeChild(el);\n                    }\n                }\n            },\n            detach: function () {\n                var view = this;\n                if (view.isDetaching) {\n                    return;\n                }\n                view.isDetaching = BOOLEAN_TRUE;\n                view[DISPATCH_EVENT]('before:detach');\n                view.isDetached = BOOLEAN_TRUE;\n                view._detachElement();\n            },\n            destroy: function (opts) {\n                var view = this;\n                view.isRendered = BOOLEAN_FALSE;\n                view.detach();\n                // remove all events\n                // should internally call remove\n                Box[CONSTRUCTOR][PROTOTYPE].destroy.call(view);\n                return view;\n            },\n            rendered: function () {\n                return this.isRendered;\n            },\n            destroyed: function () {\n                return this.isDestroyed;\n            }\n        }, BOOLEAN_TRUE),\n        Region = factories.View.extend('Region', {\n            Model: View,\n            _ensureElement: _.noop,\n            add: function (models_) {\n                var ret, _bufferedViews, view = this;\n                view._ensureBufferedViews();\n                ret = Box[CONSTRUCTOR][PROTOTYPE].add.call(view, models_);\n                return ret;\n            },\n            _add: function (view) {\n                var parent = this;\n                Box[CONSTRUCTOR][PROTOTYPE]._add.call(parent, view);\n                // ensure the element buffer\n                // append to the view list buffer\n                // attached buffered element here so we don't have to loop through the list later\n                view._setElement(view.el);\n                parent._addBufferedView(view);\n            },\n            _ensureChildren: function () {\n                this[CHILDREN] = this[CHILDREN] || Collection();\n            },\n            _ensureBufferedViews: function () {\n                var bufferedViews = isArray(this._bufferedViews) ? 1 : this._resetBufferedViews();\n                var _bufferedEls = isFragment(this._bufferedEls) ? 1 : this._resetBufferedEls();\n            },\n            _addBufferedView: function (view) {\n                var parent = this;\n                parent._bufferedEls.appendChild(view.el[INDEX](0));\n                parent._bufferedViews.push(view);\n            },\n            _resetBuffered: function () {\n                this._resetBufferedEls();\n                this._resetBufferedViews();\n            },\n            _resetBufferedViews: function () {\n                this._bufferedViews = [];\n            },\n            _resetBufferedEls: function () {\n                this._bufferedEls = createDocumentFragment();\n            },\n            _setElement: function () {\n                var region = this,\n                    selector = region.selector,\n                    parent = region[PARENT];\n                if (parent !== app) {\n                    region.el = parent.$(selector);\n                } else {\n                    region.el = $($(selector)[INDEX](0));\n                }\n            },\n            render: function () {\n                var region = this;\n                region.isRendered = BOOLEAN_FALSE;\n                // doc frags on regionviews, list of children to trigger events on\n                region._ensureBufferedViews();\n                // request extra data or something before rendering: dom is still completely intact\n                region[DISPATCH_EVENT]('before:render');\n                // unbinds and rebinds element only if it changes\n                region._setElement();\n                // update new element's attributes\n                region._setElAttributes();\n                // puts children back inside parent\n                region._attachBufferedViews();\n                // attach region element\n                // appends child elements\n                region[APPEND_CHILD_ELEMENTS]();\n                // mark the view as rendered\n                region.isRendered = BOOLEAN_TRUE;\n                // reset buffered objects\n                region._resetBuffered();\n                // dispatch the render event\n                region[DISPATCH_EVENT]('render');\n                return region;\n            },\n            _appendChildElements: function () {\n                var region = this,\n                    buffered = region._bufferedEls,\n                    el = region.el[INDEX](0);\n                if (buffered && el) {\n                    el.appendChild(buffered);\n                }\n            },\n            _getElementFromParent: function (selector) {\n                var $selected, region = this,\n                    parent = region[PARENT];\n                if (parent !== app) {\n                    $selected = $(parent.$(selector)[INDEX](0));\n                } else {\n                    $selected = $($(selector)[INDEX](0));\n                }\n                region.el = $selected;\n            },\n            _attachBufferedViews: function () {\n                var region = this,\n                    parentView = region.parentView();\n                region[CHILDREN].duff(function (child) {\n                    if (result(child, 'filter')) {\n                        child[RENDER]();\n                        region._addBufferedView(child);\n                    }\n                });\n            }\n        }, BOOLEAN_TRUE),\n        RegionManager = factories.Collection.extend('RegionManager', {\n            createRegion: function (where, region_) {\n                var key, regionManager = this,\n                    parent = regionManager[PARENT],\n                    // assume that it is a region\n                    region = region_;\n                if (isInstance(region, Region)) {\n                    return region;\n                }\n                region = Region({}, {\n                    id: where,\n                    selector: isString(region) ? region : '',\n                    parent: parent\n                });\n                key = REGION_MANAGER;\n                if (parent !== app) {\n                    key = CHILDREN;\n                    parent.add(region);\n                }\n                parent._addToHash(region, key);\n                return region;\n            },\n            removeRegion: function (region_) {\n                var regionManager = this;\n                var region = isString(region_) ? regionManager.get(region_) : region_;\n                regionManager.remove(region);\n                regionManager.unregister(region.id, region);\n            },\n            establishRegions: function (key, value) {\n                var regionManager = this,\n                    parentView = regionManager[PARENT];\n                intendedObject(key, value, function (key, value) {\n                    var region = regionManager.get(key);\n                    if (!region) {\n                        region = regionManager.createRegion(key, value);\n                    }\n                    region._getElementFromParent();\n                });\n                return regionManager;\n            }\n        }, BOOLEAN_TRUE);\n    _.exports({\n        compile: compile\n    });\n    app.extend({\n        _addToHash: Box[CONSTRUCTOR][PROTOTYPE]._addToHash,\n        getRegion: viewGetRegionPlacer(REGION_MANAGER),\n        addRegion: function (id, selector) {\n            var app = this;\n            // ensure region manager\n            var blank = app.getRegion();\n            var regionManager = app[REGION_MANAGER];\n            regionManager[PARENT] = app;\n            regionManager.establishRegions(id, selector);\n            return app;\n        }\n    });\n});","application.scope().module('Buster', function (module, app, _, factories, $) {\n    var blank, isReceiving = 0,\n        get = _.get,\n        duff = _.duff,\n        collection = factories.Collection,\n        gapSplit = _.gapSplit,\n        associator = _.associator,\n        unitsToNum = _.unitsToNum,\n        roundFloat = _.roundFloat,\n        isFunction = _.isFunction,\n        extend = _.extend,\n        console = _.console,\n        reference = _.reference,\n        now = _.now,\n        parse = _.parse,\n        foldl = _.foldl,\n        stringify = _.stringify,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        infin = 32767,\n        nInfin = -infin - 1,\n        ATTRIBUTES = 'attributes',\n        COMPONENT = 'component',\n        COMPONENTS = COMPONENT + 's',\n        RESPONSE_OPTIONS = 'responseOptions',\n        PARENT = 'parent',\n        LENGTH = 'length',\n        HEIGHT = 'height',\n        WIDTH = 'width',\n        BOTTOM = 'bottom',\n        RIGHT = 'right',\n        LEFT = 'left',\n        TOP = 'top',\n        DISPATCH_EVENT = 'dispatchEvent',\n        MARGIN_BOTTOM = 'marginBottom',\n        MARGIN_RIGHT = 'marginRight',\n        MIN_HEIGHT = 'minHeight',\n        MAX_HEIGHT = 'maxHeight',\n        MIN_WIDTH = 'minWidth',\n        MAX_WIDTH = 'minWidth',\n        BEFORE_RESPONDED = 'before:responded',\n        QUEUED_MESSAGE_INDEX = 'queuedMessageIndex',\n        pI = _.pI,\n        _setupInit = function (e) {\n            var i, currentCheck, src, parentEl, frameWin, frameEl, allFrames, tippyTop, spFacts, spOFacts, shouldRespond, sameSide, topDoc, wrapper, buster = this,\n                frame = e.frame,\n                data = e.data(),\n                packet = data.packet,\n                responder = e.responder,\n                attrs = get(buster),\n                parts = buster.parts;\n            if (app.topAccess) {\n                tippyTop = window[TOP];\n                topDoc = tippyTop.document;\n                wrapper = topDoc.body;\n            }\n            if (!frame) {\n                if (!data.toInner) {\n                    /**\n                     * when the buster has to go through an unfriendly iframe, it has to find the iframe it belonged to from the top document\n                     * @private\n                     * @arg {string} url that is the iframe. also, secondarily checks the window objects in the while loop\n                     */\n                    buster.el = (function (specFrame) {\n                        var frame, frameWin, src, currentCheck, i,\n                            frames = topDoc.getElementsByTagName('iframe'),\n                            srcEl = e.srcElement;\n                        if (specFrame) {\n                            for (i in frames) {\n                                frame = frames[i];\n                                frameWin = frame.contentWindow;\n                                src = frame.src;\n                                if (src === specFrame) {\n                                    currentCheck = srcEl;\n                                    while (currentCheck !== tippyTop) {\n                                        if (frameWin === currentCheck) {\n                                            return frame;\n                                        }\n                                        currentCheck = currentCheck[PARENT];\n                                    }\n                                }\n                            }\n                        }\n                        return 0;\n                    }(attrs.srcOrigin));\n                }\n                if (data.toInner) {\n                    buster.el = document.body;\n                }\n                if (buster.el) {\n                    buster.el = $(buster.el);\n                    buster.set({\n                        sameSide: 0,\n                        id: data.from,\n                        referrer: reference(parts.doc)\n                    });\n                    extend(parts, {\n                        srcElement: e.source,\n                        top: tippyTop || {},\n                        doc: topDoc || {},\n                        wrapper: wrapper || {}\n                    });\n                    shouldRespond = 1;\n                    attrs.isConnected = 1;\n                }\n            }\n            if (frame) {\n                buster.el = frame;\n                buster.responder = e.responder;\n                shouldRespond = 1;\n                buster.set({\n                    sameSide: 1,\n                    referrer: packet.referrer\n                });\n                extend(buster.parts, {\n                    srcElement: e.srcElement,\n                    wrapper: wrapper,\n                    top: tippyTop,\n                    doc: topDoc\n                });\n            }\n            if (shouldRespond) {\n                parentEl = buster.el[PARENT]();\n                buster.respond(data, {\n                    parent: {\n                        height: parentEl[HEIGHT](),\n                        width: parentEl[WIDTH](),\n                        style: {\n                            height: parentEl.index(0).style[HEIGHT],\n                            width: parentEl.index(0).style[WIDTH]\n                        }\n                    }\n                });\n            }\n        },\n        /**\n         * single handler for all busters under same window makes it easy to remove from window when the time comes to unload\n         * @private\n         * @arg {event} event object passed in by browser\n         */\n        receive = function (evt) {\n            var buster, bustersCache, data = parse(evt.data),\n                postTo = data.postTo;\n            if (data && postTo && !app.isDestroying) {\n                bustersCache = associator.get(postTo);\n                if (bustersCache) {\n                    buster = bustersCache.buster;\n                    if (buster && buster.run) {\n                        buster.run(data, evt);\n                    }\n                }\n            }\n        },\n        /**\n         * single function to stringify and post message an object to the other side\n         * @private\n         * @arg {object} object to be stringified and sent to the receive function,\n         * either through a post message, or through a setTimeout\n         * @arg {buster}\n         */\n        postMessage = function (base, buster) {\n            var busterAttrs = buster[ATTRIBUTES],\n                sameSide = busterAttrs.sameSide,\n                parts = buster.parts,\n                message = stringify(base),\n                timestamp = now(),\n                doReceive = function () {\n                    receive({\n                        data: message,\n                        frame: buster.el,\n                        responder: receive,\n                        srcElement: window,\n                        timestamp: timestamp\n                    });\n                };\n            if (!sameSide) {\n                if (busterAttrs.referrer) {\n                    parts.sendWin.postMessage(message, busterAttrs.referrer);\n                } else {\n                    console.trace('missing referrer', buster);\n                }\n            }\n            if (sameSide) {\n                doReceive();\n            }\n            return timestamp;\n        },\n        /**\n         * object for 4 different setup cases. probably belongs elsewhere\n         * @private\n         * @arg {buster}\n         */\n        setups = {\n            /**\n             * @private\n             */\n            toInner: function (buster) {\n                var attrs = buster[ATTRIBUTES],\n                    parts = buster.parts;\n                parts.sendWin = buster[PARENT].el.index(0).contentWindow;\n                attrs.referrer = attrs.referrer || reference(parts.doc);\n                attrs.sameSide = !buster[PARENT][PARENT].get('unfriendlyCreative');\n            },\n            /**\n             * @private\n             */\n            fromInner: function (buster) {\n                var attrs = buster[ATTRIBUTES],\n                    parts = buster.parts;\n                parts.sendWin = parts.receiveWin[PARENT];\n                attrs.referrer = attrs.referrer || reference(parts.doc);\n            },\n            notInner: {\n                /**\n                 * @private\n                 */\n                noAccess: function (buster) {\n                    var url, attrs = buster[ATTRIBUTES],\n                        parts = buster.parts,\n                        doc = parts.doc,\n                        iframe = doc.createElement('iframe'),\n                        allMods = _.clone(app.allModules);\n                    allMods.push('initPublisherConfig');\n                    if (!attrs.busterLocation) {\n                        return;\n                    }\n                    iframe.style.display = 'none';\n                    url = attrs.referrer + attrs.busterLocation;\n                    iframe.src = _.stringifyQuery({\n                        url: attrs.referrer + attrs.busterLocation,\n                        query: {\n                            origin: doc.location.href,\n                            sessionId: attrs.sessionId,\n                            src: app.BASEURL + buster.get('scriptUrl') + app.addVersionNumber(allMods).join()\n                        }\n                    });\n                    parts.wrapper.appendChild(iframe);\n                    parts.sendWin = iframe.contentWindow;\n                    buster.el = $(iframe);\n                    promise.Ajax(url).failure(function () {\n                        var time = 2000;\n                        if (_.isMobile) {\n                            time = 10000;\n                        }\n                        setTimeout(function () {\n                            // handle no buster file here\n                            var ret, ad = buster[PARENT],\n                                adAttrs = ad[ATTRIBUTES],\n                                banner = ad.children.index(1),\n                                panel = ad.children.index(2);\n                            if (!ad.busterLoaded) {\n                                if (!banner) {\n                                    banner = panel;\n                                }\n                                ret = panel.destroy && panel.destroy();\n                                buster.unSendAll();\n                                buster.on('message:queued', buster.unSendAll);\n                            }\n                        }, time);\n                    });\n                },\n                /**\n                 * @private\n                 */\n                topAccess: function (buster) {\n                    var commands, newParent = buster.el.index(0),\n                        attrs = buster[ATTRIBUTES];\n                    // if preventselfinit is true, then that means that\n                    // this is being triggered by the buster file\n                    if (!attrs.preventSelfInit) {\n                        if (attrs.publisherConfig) {\n                            // // does need some special functions\n                            _.Ajax('http:' + app.SERVERURL + app.SCRIPTPATH + attrs.publisherConfig).success(function (responseText) {\n                                new Function.constructor('return ' + responseText)();\n                                buster.begin();\n                            });\n                        } else {\n                            // doesn't need any special functions\n                            buster.addCommand(factories.publisherConfig());\n                            buster.begin();\n                        }\n                    } else {\n                        buster.addCommand(factories.publisherConfig());\n                    }\n                }\n            }\n        },\n        containerSize = function (components) {\n            return components.foldr(function (memo, idx, com) {\n                var preventScrollCounter = 0,\n                    hPushCount = 0,\n                    vPushCount = 0,\n                    calced = com.calculatedSize,\n                    verticalPush = com.pushVertical,\n                    horizontalPush = com.pushHorizontal;\n                if (verticalPush !== '') {\n                    vPushCount++;\n                }\n                if (horizontalPush !== '') {\n                    hPushCount++;\n                }\n                if (com.isShowing && com.container === 'ad') {\n                    if (com.preventScroll) {\n                        preventScrollCounter = 1;\n                    }\n                    memo = {\n                        top: Math.min(memo[TOP], calced[TOP]),\n                        left: Math.min(memo[LEFT], calced[LEFT]),\n                        right: Math.max(memo[RIGHT], (calced[LEFT] + calced[WIDTH])),\n                        bottom: Math.max(memo[BOTTOM], (calced[TOP] + calced[HEIGHT])),\n                        zIndex: Math.max(memo.zIndex, (+com.zIndex || 0)),\n                        marginRight: Math.max(memo[MARGIN_RIGHT], horizontalPush || 0),\n                        marginBottom: Math.max(memo[MARGIN_BOTTOM], verticalPush || 0),\n                        vPushCount: vPushCount + memo.vPushCount,\n                        hPushCount: hPushCount + memo.hPushCount,\n                        transitionDuration: Math.max(memo.transitionDuration, com.duration),\n                        preventScrollCount: memo.preventScrollCount + preventScrollCounter\n                    };\n                }\n                return memo;\n            }, {\n                top: infin,\n                left: infin,\n                right: nInfin,\n                bottom: nInfin,\n                marginBottom: 0,\n                marginRight: 0,\n                zIndex: 0,\n                vPushCount: 0,\n                hPushCount: 0,\n                transitionDuration: 0,\n                preventScrollCount: 0\n            });\n        },\n        /**\n         * @class Buster\n         * @augments Model\n         * @augments Box\n         * @augments View\n         * @classDesc constructor for buster objects, which have the ability to talk across windows\n         */\n        Message = factories.Container.extend('Message', {\n            initialize: function () {\n                var message = this;\n                message.deferredHandlers = [];\n                message.respondHandlers = [];\n            },\n            packet: function (data) {\n                var ret = this;\n                if (arguments[0]) {\n                    this.set('packet', data || {});\n                } else {\n                    ret = parse(stringify(this.get('packet')));\n                }\n                return ret;\n            },\n            defaults: function () {\n                return {\n                    command: 'null',\n                    packet: {}\n                };\n            },\n            deferred: function (fn) {\n                this.on('deferred', fn);\n                return this;\n            },\n            respond: function (fn) {\n                var message = this,\n                    buster = message[PARENT];\n                if (isFunction(fn)) {\n                    message.respondHandlers.push(bind(fn, message));\n                }\n                if (message[RESPONSE_OPTIONS]) {\n                    while (message.respondHandlers[0]) {\n                        handler = message.respondHandlers.shift();\n                        handler(message[RESPONSE_OPTIONS]);\n                    }\n                }\n                return message;\n            }\n        }),\n        Buster = factories.Buster = factories.Box.extend('Buster', {\n            Model: Message,\n            events: {\n                unload: 'destroy',\n                'change:isConnected': function () {\n                    this.set(QUEUED_MESSAGE_INDEX, 1);\n                },\n                'change:isConnected child:added': 'flush'\n            },\n            parentEvents: {\n                destroy: 'destroy'\n            },\n            /**\n             * @func\n             * @name Buster#destroy\n             */\n            currentPoint: function () {\n                var currentPoint = this.get('currentPoint');\n                return currentPoint ? {\n                    source: currentPoint.source,\n                    srcElement: currentPoint.srcElement,\n                    originTimestamp: currentPoint.timestamp,\n                    frame: currentPoint.frame,\n                    responder: currentPoint.responder\n                } : {};\n            },\n            destroy: function () {\n                var buster = this,\n                    attrs = buster[ATTRIBUTES];\n                buster.set('isConnected', BOOLEAN_FALSE);\n                clearTimeout(attrs.__lastMouseMovingTimeout__);\n                _.AF.remove(attrs.elQueryId);\n                _.AF.remove(attrs.componentTransitionAFID);\n                buster.parts = {};\n                associator.remove(buster.id);\n                factories.Box.constructor.prototype.destroy.apply(this, arguments);\n                return buster;\n            },\n            tellMouseMovement: function () {\n                if (this.get('mouseMoveDataObject')) {\n                    this.respond(this.get('mouseMoveDataObject'));\n                }\n            },\n            /**\n             * @func\n             * @name Buster#defaults\n             */\n            defaults: function () {\n                return {\n                    currentState: 'collapse',\n                    connectedUnder: [],\n                    isConnected: 0,\n                    sameSide: 0,\n                    queuedMessageIndex: 0,\n                    sent: []\n                };\n            },\n            // belongs on the outside\n            _stateCss: function (set0) {\n                var busterAttrs = this[ATTRIBUTES],\n                    _sizing = busterAttrs._sizing,\n                    margin = {\n                        transitionProperty: 'all'\n                    };\n                if (_sizing) {\n                    if (_sizing.vPushCount) {\n                        margin[MARGIN_BOTTOM] = busterAttrs.pushVerticalVal;\n                        margin.transitionDuration = _sizing.transitionDuration;\n                    } else {\n                        if (set0) {\n                            margin[MARGIN_BOTTOM] = 0;\n                        } else {\n                            margin[MARGIN_BOTTOM] = 'auto';\n                        }\n                    }\n                    if (_sizing.hPushCount) {\n                        margin[MARGIN_RIGHT] = busterAttrs.pushHorizontalVal;\n                        margin.transitionDuration = _sizing.transitionDuration;\n                    } else {\n                        if (set0) {\n                            margin[MARGIN_RIGHT] = 0;\n                        } else {\n                            margin[MARGIN_RIGHT] = 'auto';\n                        }\n                    }\n                }\n                return margin;\n            },\n            /**\n             * initial setup for all busters\n             * @func\n             * @name Buster#initialize\n             */\n            initialize: function (opts, options) {\n                var receiveWin, registered, buster = this,\n                    attrs = buster[ATTRIBUTES];\n                buster[COMPONENTS] = collection();\n                buster.showing = collection();\n                buster.on(BEFORE_RESPONDED, attrs.every);\n                buster.addCommand({\n                    initialize: _setupInit,\n                    begin: this.begin,\n                    update: function (e) {\n                        this.respond(e.data());\n                    },\n                    unload: function () {\n                        this.destroy();\n                    },\n                    // belongs on the outside\n                    updateAttributes: function (e) {\n                        var buster = this,\n                            data = e.data(),\n                            packet = data.packet;\n                        buster.set(packet.update);\n                        duff(packet[COMPONENTS], function (com) {\n                            var component = buster[COMPONENT](com.registeredAs);\n                            if (!component) {\n                                buster[COMPONENTS].add(com);\n                            } else {\n                                extend(component, com);\n                            }\n                        });\n                        buster[COMPONENTS].each(function (com) {\n                            if (_.posit(packet.showing, com.registeredAs)) {\n                                com.isShowing = BOOLEAN_TRUE;\n                            } else {\n                                com.isShowing = BOOLEAN_FALSE;\n                            }\n                        });\n                        if (packet.shouldRespond) {\n                            buster.respond();\n                        }\n                    }\n                });\n                buster.allListeners = collection();\n                attrs.frame = null;\n                buster.el = $(buster.parts.frame);\n                registered = associator.get(attrs.id);\n                registered.buster = buster;\n                registered.postListener = receive;\n                receiveWin = $(buster.parts.receiveWin);\n                receiveWin.on('message', receive);\n                buster.allListeners.push({\n                    els: receiveWin,\n                    fn: receive,\n                    name: 'message'\n                });\n                if (attrs.type === 'buster') {\n                    if (!attrs.sameSide) {\n                        setups.notInner.noAccess(buster);\n                    } else {\n                        setups.notInner.topAccess(buster);\n                    }\n                }\n                // always assume the need to bust for these two\n                if (attrs.type !== 'buster') {\n                    if (attrs.toInner) {\n                        setups.toInner(buster);\n                    }\n                    if (attrs.fromInner) {\n                        setups.fromInner(buster);\n                    }\n                }\n                return buster;\n            },\n            component: function (registeredAs) {\n                return this[COMPONENTS].find(function (com, idx) {\n                    return com.registeredAs === registeredAs || idx === registeredAs;\n                });\n            },\n            // this belongs on the outside\n            /**\n             * quick get parser to figure out if the wrapper, the frame element, it's parent, the document, or an other item is being selected by a post message\n             * @arg {string} target selector\n             * @returns {DOMM} with targets\n             * @func\n             * @name Buster#getTargets\n             */\n            getTargets: function (target) {\n                var buster = this,\n                    attrs = buster[ATTRIBUTES],\n                    parts = buster.parts,\n                    top = parts[TOP],\n                    targets = [],\n                    wrapper = parts.wrapper;\n                if (!target) {\n                    targets = [top];\n                }\n                if (target === 'wrapper') {\n                    targets = [wrapper];\n                }\n                if (target === 'self') {\n                    targets = buster.el;\n                }\n                if (target === 'document') {\n                    targets = [parts.doc];\n                }\n                if (target === PARENT) {\n                    targets = buster.el[PARENT]();\n                }\n                if (!targets[LENGTH]) {\n                    targets = parts.doc.querySelectorAll(target);\n                }\n                return $(targets);\n            },\n            /**\n             * tries to flush the cache. only works if the isConnected attribute is set to true. If it is, then the post message pipeline begins\n             * @returns {buster} returns this;\n             * @func\n             * @name Buster#flush\n             */\n            flush: function () {\n                var n, item, gah, childrenLen, queuedMsg, nuData, i = 0,\n                    buster = this,\n                    currentIdx = buster.get(QUEUED_MESSAGE_INDEX),\n                    connected = buster.get('isConnected'),\n                    initedFrom = buster.get('initedFromPartner'),\n                    flushing = buster.get('flushing');\n                if (!initedFrom || connected && ((connected || !currentIdx) && !flushing)) {\n                    buster.set('flushing', BOOLEAN_TRUE);\n                    childrenLen = buster.children[LENGTH]();\n                    queuedMsg = buster.children.index(currentIdx);\n                    while (queuedMsg && currentIdx < childrenLen) {\n                        queuedMsg.set({\n                            runCount: 0\n                        });\n                        postMessage(queuedMsg, buster);\n                        if (currentIdx) {\n                            currentIdx = (buster.get(QUEUED_MESSAGE_INDEX) + 1) || 0;\n                            buster.set(QUEUED_MESSAGE_INDEX, currentIdx);\n                            queuedMsg = buster.children.index(currentIdx);\n                        } else {\n                            childrenLen = BOOLEAN_FALSE;\n                        }\n                    }\n                    buster.set({\n                        flushing: BOOLEAN_FALSE\n                    });\n                    if (buster.get('isConnected')) {\n                        if (buster.children[LENGTH]() > buster.get(QUEUED_MESSAGE_INDEX)) {\n                            buster.flush();\n                        }\n                    }\n                }\n                return buster;\n            },\n            /**\n             * basic send message function, adds to queue, then calls flush\n             * @arg {string} can be string or object. if object, must have command property as string\n             * @arg {object} base object to be sent\n             * @returns {buster}\n             * @func\n             * @name Buster#send\n             */\n            send: function (command, packet, extra) {\n                var message, buster = this,\n                    defaultObj = buster.defaultMessage();\n                message = buster.add(extend({\n                    command: command,\n                    packet: packet\n                }, defaultObj, extra));\n                return buster.children.index(defaultObj.index);\n            },\n            /**\n             * shorthand for creating a function that gets called after the buster's partner has responded\n             * @func\n             * @name Buster#sync\n             */\n            sync: function (fn) {\n                return this.send('update').respond(fn);\n            },\n            /**\n             * if a buster is found on the receive function, by the data's postTo property, then the run method is called\n             * @arg {object} the parsed data object\n             * @arg {event} the event object that wrapped the stringified data object\n             * @returns {buster}\n             * @func\n             * @name Buster#run\n             */\n            run: function (data, currentPoint_) {\n                var packet, format, retVal, responded, onResponse, originalMessage, responseType, methodName, buster = this,\n                    attrs = buster[ATTRIBUTES],\n                    currentPoint = attrs.currentPoint = currentPoint_,\n                    event = currentPoint,\n                    messages = attrs.sent,\n                    runCount = data.runCount,\n                    children = buster.children,\n                    eventname = 'respond',\n                    args = _.toArray(arguments);\n                if (runCount) {\n                    originalMessage = children.index(data.index);\n                    if (originalMessage) {\n                        // found the message that i originally sent you\n                        // packet = originalMessage.packet;\n                        // allow the buster to set some things up\n                        buster[DISPATCH_EVENT](BEFORE_RESPONDED);\n                        if (runCount === 1) {\n                            // stash it for later\n                            originalMessage[RESPONSE_OPTIONS] = data;\n                        } else {\n                            eventname = 'deferred';\n                        }\n                        originalMessage[DISPATCH_EVENT](eventname);\n                    }\n                } else {\n                    buster[DISPATCH_EVENT]('receive:' + data.command);\n                    buster[DISPATCH_EVENT]('receive');\n                }\n                return buster;\n            },\n            /**\n             * skip the queue, and simply send a message\n             * @arg {object} message object to be sent\n             * @arg {object} optional object that is the original object. Usually only applicable when passed in through the send function, so that the response event can have all of the correct information\n             * @returns {buster}\n             * @func\n             * @name Buster#sendMessage\n             */\n            // sendMessage: function (message) {\n            //     var buster = this;\n            //     // set again to make sure that it has all the right info\n            //     // message.set(buster.defaultMessage());\n            //     postMessage(_.fullClone(message), buster);\n            //     return buster;\n            // },\n            /**\n             * creates a default message based on the attributes of the buster\n             * @returns {object} blank / default message object\n             * @func\n             * @name Buster#defaultMessage\n             */\n            defaultMessage: function () {\n                var attrs = this[ATTRIBUTES];\n                return {\n                    from: attrs.id,\n                    postTo: attrs.postTo,\n                    sameSide: attrs.sameSide,\n                    fromInner: attrs.fromInner,\n                    toInner: attrs.toInner,\n                    // runCount: 0,\n                    index: this.children[LENGTH](),\n                    preventResponse: BOOLEAN_FALSE\n                };\n            },\n            /**\n             * @func\n             * @name Buster#shouldUpdate\n             */\n            shouldUpdate: function (args) {\n                var ret, buster = this,\n                    attrs = buster[ATTRIBUTES],\n                    lastUpdate = attrs.lastRespondUpdate,\n                    lastFrameRect = attrs.lastFrameRect,\n                    top = buster.parts[TOP] || {},\n                    width = top.innerWidth,\n                    height = top.innerHeight,\n                    nowish = now();\n                if (lastUpdate > nowish - 1000 && _.isObject(lastFrameRect)) {\n                    ret = !(lastFrameRect[BOTTOM] < -height * 0.5 || lastFrameRect.top > height * 1.5 || lastFrameRect[RIGHT] < -width * 0.5 || lastFrameRect[LEFT] > width * 1.5);\n                } else {\n                    ret = 1;\n                }\n                clearTimeout(attrs.lastUpdateThrottledId);\n                if (!ret) {\n                    attrs.lastUpdateThrottledId = setTimeout(function () {\n                        buster.respond.apply(buster, args);\n                    }, -(nowish - lastUpdate - 1000));\n                }\n                return !buster.startThrottle || ret;\n            },\n            /**\n             * respond trigger.\n             * @arg {object} original data object (same pointer) that was sent over\n             * @arg {object} extend object, that will be applied to a base object, that is created by the responseExtend attribute set on the buster object\n             * @returns {buster}\n             * @func\n             * @name Buster#respond\n             */\n            respond: function (data, extendObj) {\n                var lastRespondUpdate, message, buster = this,\n                    attrs = buster[ATTRIBUTES],\n                    sameSide = attrs.sameSide,\n                    base = {};\n                if (!extendObj || !_.isObject(extendObj)) {\n                    extendObj = {};\n                }\n                if (buster.el && (!data.canThrottle || buster.shouldUpdate(arguments))) {\n                    // on the inner functions, we don't want to allow this\n                    // module to be present, so the inner does not influence the outer\n                    if (attrs.responseExtend) {\n                        base = attrs.responseExtend(buster, data);\n                    }\n                    ++data.runCount;\n                    base = {\n                        from: data.postTo,\n                        postTo: data.from,\n                        index: data.index,\n                        isResponse: 1,\n                        isDeferred: data.isDeferred,\n                        runCount: data.runCount,\n                        command: data.command,\n                        packet: extend(base, extendObj)\n                    };\n                    // used for throttling\n                    attrs.lastRespondUpdate = postMessage(base, buster);\n                    buster[DISPATCH_EVENT]('respond:' + data.command);\n                    if (data.isDeferred) {\n                        buster[DISPATCH_EVENT]('deferred:' + data.command);\n                    }\n                    data.isDeferred = 1;\n                }\n                return buster;\n            },\n            /**\n             * @returns {object} client rect duplicate of element\n             * @func\n             * @name Buster#getFrameRect\n             */\n            getFrameRect: function () {\n                var clientRect = this[ATTRIBUTES].lastFrameRect = this.el.clientRect();\n                return clientRect;\n            },\n            /**\n             * @returns {object} client rect duplicate of parent element\n             * @func\n             * @name Buster#getParentRect\n             */\n            getParentRect: function () {\n                var parentRect = this[ATTRIBUTES].lastParentRect = this.el[PARENT]().clientRect();\n                return parentRect;\n            },\n            updateTopData: function () {\n                var buster = this,\n                    attrs = get(buster),\n                    parts = buster.parts,\n                    topWin = parts.top || {},\n                    location = topWin.location || {\n                        hash: '',\n                        pathname: '',\n                        protocol: '',\n                        search: ''\n                    },\n                    topData = attrs.topData = {\n                        location: {\n                            hash: location.hash.slice(1),\n                            host: location.host,\n                            href: location.href,\n                            origin: location.origin,\n                            pathname: location.pathname.slice(1),\n                            port: location.port,\n                            protocol: location.protocol.slice(0, location.protocol[LENGTH] - 1),\n                            search: location.search.slice(1)\n                        },\n                        innerHeight: topWin.innerHeight || 0,\n                        outerHeight: topWin.outerHeight || 0,\n                        innerWidth: topWin.innerWidth || 0,\n                        outerWidth: topWin.outerWidth || 0,\n                        scrollX: topWin.scrollX || 0,\n                        scrollY: topWin.scrollY || 0\n                    };\n                return topData;\n            },\n            /**\n             * gets the wrapper info, such as scroll height, id, and the classname\n             * @returns {object} key value pairs of all of the data that defines the wrapper\n             * @func\n             * @name Buster#wrapperInfo\n             */\n            wrapperInfo: function () {\n                var info, buster = this,\n                    parts = buster.parts,\n                    el = parts.wrapper || {},\n                    doc = parts.doc || {\n                        body: {}\n                    },\n                    root = doc.body.parentNode,\n                    getBoundingClientRect = {},\n                    attrs = get(buster);\n                if (el.tagName) {\n                    getBoundingClientRect = $(el).clientRect();\n                }\n                info = attrs.wrapperInfo = {\n                    readyState: (doc.readyState === 'complete'),\n                    scrollHeight: el.scrollHeight,\n                    scrollWidth: el.scrollWidth,\n                    scrollLeft: el.scrollLeft,\n                    scrollTop: el.scrollTop,\n                    className: el.className,\n                    pageTitle: doc.title,\n                    id: el.id,\n                    height: pI(getBoundingClientRect.height),\n                    bottom: pI(getBoundingClientRect.bottom),\n                    width: pI(getBoundingClientRect.width),\n                    right: pI(getBoundingClientRect.right),\n                    left: pI(getBoundingClientRect.left),\n                    top: pI(getBoundingClientRect[TOP])\n                };\n                return info;\n            },\n            /**\n             * @returns {object} position in document as calculated by the buster attributes\n             * @func\n             * @name Buster#positionInDocument\n             */\n            positionInDocument: function () {\n                var attrs = this[ATTRIBUTES],\n                    wrapperInfo = attrs.wrapperInfo,\n                    contentRect = attrs.lastParentRect,\n                    pos = attrs.lastPosInDoc = {\n                        top: pI(contentRect[TOP] - wrapperInfo[TOP]),\n                        bottom: pI(wrapperInfo[HEIGHT] - contentRect[TOP] - wrapperInfo.scrollTop - contentRect[HEIGHT]),\n                        left: pI(contentRect[LEFT] - wrapperInfo[LEFT]),\n                        right: pI(wrapperInfo[WIDTH] - contentRect[RIGHT] - wrapperInfo.scrollLeft - wrapperInfo[LEFT])\n                    };\n                return pos;\n            },\n            calculateSizes: function () {\n                var buster = this,\n                    attrs = get(buster),\n                    parentStyle = attrs.lastParentStyle = buster.el[PARENT]().getStyle(),\n                    comSizes = attrs[COMPONENTS] = buster[COMPONENTS].map(function (idx, com) {\n                        return buster.calculateSize(com);\n                    });\n                return comSizes;\n            },\n            showComponents: function (showList) {\n                var buster = this;\n                duff(gapSplit(showList), function (id) {\n                    var com = buster[COMPONENT](id);\n                    if (com) {\n                        com.isShowing = BOOLEAN_TRUE;\n                    }\n                });\n            },\n            hideComponents: function (hideList) {\n                var buster = this;\n                duff(gapSplit(hideList), function (id) {\n                    var com = buster[COMPONENT](id);\n                    if (com) {\n                        com.isShowing = BOOLEAN_FALSE;\n                    }\n                });\n            },\n            calculateContainerSize: function (components) {\n                var buster = this,\n                    attrs = get(buster),\n                    parentRect = attrs.lastParentRect,\n                    sizing = containerSize(components || buster[COMPONENTS]);\n                attrs._sizing = sizing;\n                attrs.containerSize = {\n                    top: sizing[TOP],\n                    left: sizing[LEFT],\n                    width: sizing[RIGHT] - sizing[LEFT],\n                    height: sizing[BOTTOM] - sizing[TOP]\n                };\n                attrs.pushVerticalVal = Math.min(Math.max(sizing[BOTTOM] - parentRect[BOTTOM], 0), sizing[MARGIN_BOTTOM]);\n                attrs.pushHorizontalVal = Math.min(Math.max(sizing[RIGHT] - parentRect[RIGHT], 0), sizing[MARGIN_RIGHT]);\n                sizing = attrs.containerCss = {\n                    top: sizing[TOP] - parentRect[TOP],\n                    left: sizing[LEFT] - parentRect[LEFT],\n                    width: sizing[RIGHT] - sizing[LEFT],\n                    height: sizing[BOTTOM] - sizing[TOP],\n                    zIndex: sizing.zIndex || 'inherit'\n                };\n                return sizing;\n            },\n            calculateSize: function (component) {\n                var buster = this,\n                    attrs = get(buster),\n                    expansion = factories.expansion[component.dimensionType || 'match'],\n                    parentRect = attrs.lastParentRect,\n                    parentStyle = attrs.lastParentStyle,\n                    result = (expansion || factories.expansion.match).call(buster, component, parentRect, parentStyle, buster.parts[TOP]),\n                    // these are always relative to the viewport\n                    calcSize = component.calculatedSize = _.floor({\n                        top: result[TOP],\n                        left: result[LEFT],\n                        width: result[WIDTH],\n                        height: result[HEIGHT]\n                    }, 2);\n                return calcSize;\n            },\n            /**\n             * constantly posts until it gets a response\n             * @arg {object} message to go to the opposite buster pair\n             * @arg {number} optionally pass a number to change the setInterval time\n             * @returns {number} interval id that corresponds to the setInterval call id\n             * @func\n             * @name Buster#shout\n             */\n            shout: function (command, obj, extra, timer) {\n                var intervalId, buster = this,\n                    message = buster.send(command, obj, extra);\n                intervalId = _.AF.time(timer || 100, function () {\n                    postMessage(obj, buster);\n                });\n                return intervalId;\n            },\n            /**\n             * starts a relationship between two busters. simplifies the initialization process.\n             * @returns {number} just for responding to the original message in case there's a handler\n             * @func\n             * @name Buster#begin\n             */\n            begin: function () {\n                var buster = this,\n                    attrs = buster[ATTRIBUTES],\n                    message = buster.send('initialize', {\n                        referrer: attrs.publisher\n                    });\n                message.respond(function (e) {\n                    var data = e.data(),\n                        packet = data.packet;\n                    buster.set('isConnected', BOOLEAN_TRUE);\n                });\n            }\n        }, BOOLEAN_TRUE);\n    if (app.topAccess) {\n        $(window[TOP]).on('message', receive);\n    }\n    _.exports({\n        containerSize: containerSize\n    });\n});"],"sourceRoot":"/source/"}