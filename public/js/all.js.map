{"version":3,"sources":["beforeSetup.js","setup.js","scopeStart.js","constants.js","utils.js","shims.js","Strings.js","Directives.js","Collection.js","Messenger.js","Events.js","Linguistics.js","Box.js","Module.js","Looper.js","Promise.js","Ajax.js","Associator.js","DOMM.js","View.js","Buster.js","scopeEnd.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACj8EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACt7BA","file":"all.js","sourcesContent":["this.Application = function (global, WHERE, version, fn) {\n    'use strict';\n    var UNDEFINED, topmostDoc, MAKE_SCRIPT = 'makeScript',\n        LENGTH = 'length',\n        PARENT = 'parent',\n        PROTOTYPE = 'prototype',\n        TOUCH_TOP = 'touchTop',\n        TOP_ACCESS = 'topAccess',\n        global_ = this || global || window,\n        doc = global_.document,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        NULL = null,\n        typeConstructor = function (str) {\n            return function (thing) {\n                return typeof thing === str;\n            };\n        },\n        now = function () {\n            return +(new Date());\n        },\n        isString = typeConstructor('string'),\n        isFunction = typeConstructor('function'),\n        executionTime = now(),\n        makeParody = function (parent, fn) {\n            return function () {\n                return fn.apply(parent, arguments);\n            };\n        },\n        wraptry = function (fn, try_, finally_) {\n            try {\n                return fn();\n            } catch (e) {\n                console.log(e);\n                return try_ && try_(e);\n            } finally {\n                return finally_ && finally_();\n            }\n        };\n\n    function Application(name, parent) {\n        this.version = name;\n        this.scoped = BOOLEAN_TRUE;\n        this.global = BOOLEAN_FALSE;\n        this.loadedUnder = [];\n        return this;\n    }\n    Application[PROTOTYPE].wraptry = wraptry;\n    Application[PROTOTYPE].extend = function (obj) {\n        var n, app = this;\n        for (n in obj) {\n            if (obj.hasOwnProperty(n)) {\n                app[n] = obj[n];\n            }\n        }\n        return app;\n    };\n    Application[PROTOTYPE].parody = function (list) {\n        var app = this,\n            i = 0,\n            extendor = {},\n            parent = app.parent;\n        for (; i < list[LENGTH]; i++) {\n            extendor[list[i]] = makeParody(parent, parent[list[i]]);\n        }\n        app.extend(extendor);\n        return app;\n    };\n    Application[PROTOTYPE].scope = function (name, fn_) {\n        var app = this,\n            fn = name && (isFunction(name) ? name : (isFunction(fn_) ? fn_ : NULL));\n        if (fn) {\n            app[PARENT].scope(app.version, fn);\n        }\n        return app;\n    };\n    // Application[PROTOTYPE].loadedAgainst = function (win) {};\n    // Application[PROTOTYPE].lastLoaded = function () {};\n    Application[PROTOTYPE][TOUCH_TOP] = function () {\n        // allows the top part of this script to be swapped out against different globaldows_\n        return this[PARENT][TOUCH_TOP](global_);\n    };\n    Application[PROTOTYPE][TOP_ACCESS] = function () {\n        this[TOUCH_TOP]();\n        return this[PARENT][TOP_ACCESS];\n    };\n    var app, application = global_[WHERE] = global_[WHERE] || {\n        versions: {},\n        executionTime: executionTime,\n        versionOrder: [],\n        global: BOOLEAN_TRUE,\n        scoped: BOOLEAN_FALSE,\n        wraptry: wraptry,\n        registerVersion: function (name) {\n            var application = this,\n                cachedOrCreated = application.versions[name],\n                newApp = application.versions[name] = cachedOrCreated || new Application(name, application);\n            newApp[PARENT] = application;\n            application.upsetDefaultVersion(name);\n            if (!cachedOrCreated) {\n                application.versionOrder.push(name);\n            }\n            return newApp;\n        },\n        upsetDefaultVersion: function (version) {\n            var application = this;\n            if (application.defaultVersion) {\n                // keyword version only works the first time then it's set for the lifespan\n                if (+application.defaultVersion === +application.defaultVersion) {\n                    // keyword version overwrites default (dev / hotfix)\n                    if (+version !== +version) {\n                        application.defaultVersion = version;\n                    }\n                }\n            } else {\n                application.defaultVersion = version;\n            }\n        },\n        unRegisterVersion: function (name) {\n            var application = this,\n                saved = application.versions[name],\n                orderIdx = application.versionOrder.indexOf(name);\n            if (orderIdx !== -1) {\n                application.versionOrder.splice(orderIdx, 1);\n            }\n            saved[PARENT] = UNDEFINED;\n            application.versions[name] = UNDEFINED;\n            return saved;\n        },\n        scope: function (name_, fn_) {\n            var scopedApp, app = this,\n                hash = app.versions,\n                name = fn_ ? name_ : app.defaultVersion,\n                fn = fn_ ? fn_ : name_;\n            if (isString(name_)) {\n                app.currentVersion = name_;\n            }\n            app.registerVersion(name);\n            scopedApp = hash[name];\n            return isFunction(fn) ? this.wraptry(function () {\n                fn.call(app, scopedApp);\n            }) || scopedApp : scopedApp;\n        },\n        map: function (arra, fn, ctx) {\n            var i = 0,\n                len = arra[LENGTH],\n                arr = [];\n            while (len > i) {\n                arr[i] = fn.call(ctx, arra[i], i, arra);\n                i++;\n            }\n            return arr;\n        },\n        registerScopedMethod: function (name, expects_) {\n            var application = this,\n                expects = expects_ || 3,\n                method = application[name] = application[name] || function () {\n                    var version, i = 1,\n                        args = arguments,\n                        args_ = args,\n                        argLen = args[LENGTH];\n                    // expects is equivalent to what it would be if the version was passed in\n                    if (argLen < expects) {\n                        version = application.defaultVersion;\n                    } else {\n                        args_ = [];\n                        version = args[1];\n                        for (; i < args[LENGTH]; i++) {\n                            args_.push(args[i]);\n                        }\n                    }\n                    application.map(application.versionOrder, function (version) {\n                        application.applyTo(version, name, args_);\n                    });\n                };\n            return application;\n        },\n        get: function (version) {\n            return this.versions[version];\n        },\n        applyTo: function (which, method, args) {\n            var application = this,\n                app = application.get(which);\n            return app && app[method] && app[method].apply(app, args);\n        },\n        getCurrentScript: function (d) {\n            var allScripts = (d || doc).scripts,\n                currentScript = d.currentScript,\n                lastScript = allScripts[allScripts[LENGTH] - 1];\n            return currentScript || lastScript;\n        },\n        loadScript: function (url, callback, docu_) {\n            var scriptTag, application = this,\n                // allow top doc to be overwritten\n                docu = docu_ || topmostDoc || doc;\n            scriptTag = application[MAKE_SCRIPT](url, callback);\n            docu.head.appendChild(scriptTag);\n            return application;\n        },\n        makeScript: function (src, onload, docu_, preventappend) {\n            var docu = docu_ || topmostDoc || doc,\n                script = docu.createElement('script'),\n                type = script.type = 'text/javascript';\n            if (!src) {\n                return script;\n            }\n            if (onload) {\n                script.onload = onload;\n            }\n            // src applied last for ie\n            script.src = src;\n            return script;\n        },\n        touchTop: function (global_) {\n            // assume you have top access\n            var href, topAccess = 1,\n                application = this;\n            if (application[TOP_ACCESS] === UNDEFINED) {\n                application.wraptry(function () {\n                    href = global_.top.location.href;\n                    // safari bug WHERE unfriendly frame returns undefined\n                    if (href) {\n                        topAccess = BOOLEAN_TRUE;\n                        application = global_.top[WHERE] || application;\n                    }\n                }, function () {\n                    topAccess = BOOLEAN_FALSE;\n                });\n                if (global_ === global_.top) {\n                    topAccess = BOOLEAN_TRUE;\n                }\n                if (topAccess) {\n                    topmostDoc = global_.top.document;\n                    global_.top[WHERE] = application;\n                }\n                application[TOP_ACCESS] = topAccess;\n            }\n            global_[WHERE] = application;\n            return application;\n        }\n    };\n    app = application.get(version);\n    if (app) {\n        // there is already an app with this same version that originated from this window\n        return app;\n    }\n    app = application.registerVersion(version, global_);\n    fn.call(global_, application, app);\n    return app;\n};","Application(this, 'application', 'dev', function (innerGlobalApp, scopedApp) {\n    // custom setup code for this version\n    var global = this;\n    // global app is the object that will be shared with all other iframes\n    var globalApplication = innerGlobalApp.touchTop(global);\n    // log it out for you to see\n    // console.log(globalApplication);\n    global.app = scopedApp;\n});","application.scope('dev', function (app) {\n        'use strict';","var UNDEFINED, win = window,\n    doc = win.document,\n    EMPTY_STRING = '',\n    HYPHEN = '-',\n    PERIOD = '.',\n    SLASH = '/',\n    PIXELS = 'px',\n    TO_STRING = 'toString',\n    TO_JSON = 'toJSON',\n    VALUE_OF = 'valueOf',\n    PROTOTYPE = 'prototype',\n    CONSTRUCTOR = 'constructor',\n    ID = 'id',\n    NAME = 'name',\n    TYPE = 'type',\n    CURRENT = 'current',\n    CHILD = 'child',\n    CHILDREN = CHILD + 'ren',\n    COLON = ':',\n    BEFORE = 'before',\n    CHANGE = 'change',\n    TARGET = 'target',\n    BEFORE_COLON = BEFORE + COLON,\n    CHANGE_COLON = CHANGE + COLON,\n    RESET = 'reset',\n    ATTRIBUTES = 'attributes',\n    DATA = 'data',\n    PARENT = 'parent',\n    DESTROY = 'destroy',\n    LENGTH = 'length',\n    OBJECT = 'object',\n    STRING = 'string',\n    BOOLEAN = 'boolean',\n    FUNCTION = 'function',\n    INDEX_OF = 'indexOf',\n    WINDOW = 'window',\n    DOCUMENT = 'document',\n    WRITE = 'write',\n    STACK = 'stack',\n    // DATA = 'attributes',\n    COMPONENTS = 'components',\n    CLASS = 'class',\n    TOP = 'top',\n    LEFT = 'left',\n    RIGHT = 'right',\n    BOTTOM = 'bottom',\n    WIDTH = 'width',\n    HEIGHT = 'height',\n    INDEX = 'index',\n    INNER_HEIGHT = 'innerHeight',\n    INNER_WIDTH = 'innerWidth',\n    DISPATCH_EVENT = 'dispatchEvent',\n    HTTP = 'http',\n    HTTPS = HTTP + 's',\n    TO_ARRAY = 'toArray',\n    CONSTRUCTOR_KEY = '__' + CONSTRUCTOR + '__',\n    LOCATION = 'location',\n    EXTEND = 'extend',\n    STYLE = 'style',\n    BODY = 'body',\n    BOOLEAN_TRUE = !0,\n    BOOLEAN_FALSE = !1,\n    INFINITY = Infinity,\n    NEGATIVE_INFINITY = -INFINITY,\n    BIG_INTEGER = 32767,\n    NEGATIVE_BIG_INTEGER = BIG_INTEGER - 1,\n    TWO_TO_THE_31 = 2147483647,\n    NULL = null;","var factories = {},\n    object = Object,\n    fn = Function,\n    array = Array,\n    string = String,\n    number = Number,\n    BRACKET_OBJECT_SPACE = '[object ',\n    stringProto = string[PROTOTYPE],\n    objectProto = object[PROTOTYPE],\n    arrayProto = array[PROTOTYPE],\n    funcProto = fn[PROTOTYPE],\n    nativeKeys = object.keys,\n    hasEnumBug = !{\n        toString: NULL\n    }.propertyIsEnumerable(TO_STRING),\n    MAX_VALUE = number.MAX_VALUE,\n    MIN_VALUE = number.MIN_VALUE,\n    MAX_SAFE_INTEGER = number.MAX_SAFE_INTEGER,\n    MIN_SAFE_INTEGER = number.MIN_SAFE_INTEGER,\n    MAX_ARRAY_LENGTH = 4294967295,\n    noop = function () {},\n    /**\n     * @func\n     */\n    slice = function (obj, one, two) {\n        return stringProto.slice.call(obj, one, two);\n    },\n    listSlice = function (obj, one, two) {\n        return arrayProto.slice.call(obj, one, two);\n    },\n    /**\n     * @func\n     */\n    split = function (obj, str) {\n        return stringProto.split.call(obj, str);\n    },\n    /**\n     * @func\n     */\n    join = function (obj, str) {\n        return arrayProto.join.call(obj, str);\n    },\n    /**\n     * @func\n     */\n    pop = function (obj) {\n        return arrayProto.pop.call(obj);\n    },\n    /**\n     * @func\n     */\n    push = function (obj, list) {\n        return arrayProto.push.apply(obj, list);\n    },\n    /**\n     * @func\n     */\n    shift = function (o) {\n        return arrayProto.shift.call(o);\n    },\n    /**\n     * @func\n     */\n    indexOfNaN = function (array, fromIndex, toIndex, fromRight) {\n        if (!array) {\n            return -1;\n        }\n        var other, limit = toIndex || array[LENGTH],\n            index = fromIndex + (fromRight ? 0 : -1),\n            incrementor = fromRight ? -1 : 1;\n        while ((index += incrementor) < limit) {\n            other = array[index];\n            if (other !== other) {\n                return index;\n            }\n        }\n        return -1;\n    },\n    indexOf = function (array, value, fromIndex, toIndex, fromRight) {\n        var index, limit, incrementor;\n        if (!array) {\n            return -1;\n        }\n        if (value !== value) {\n            return indexOfNaN(array, fromIndex, toIndex, fromRight);\n        }\n        index = (fromIndex || 0) - 1;\n        limit = toIndex || array[LENGTH];\n        incrementor = fromRight ? -1 : 1;\n        while ((index += incrementor) < limit) {\n            if (array[index] === value) {\n                return index;\n            }\n        }\n        return -1;\n    },\n    binaryIndexOf = function (list, item, minIndex_, maxIndex_) {\n        var guess, min = minIndex_ || 0,\n            max = maxIndex_ || list[LENGTH] - 1,\n            bitwise = (max <= TWO_TO_THE_31) ? BOOLEAN_TRUE : BOOLEAN_FALSE;\n        if (bitwise) {\n            while (min <= max) {\n                guess = (min + max) >> 1;\n                if (list[guess] === item) {\n                    return guess;\n                } else {\n                    if (list[guess] < item) {\n                        min = guess + 1;\n                    } else {\n                        max = guess - 1;\n                    }\n                }\n            }\n        } else {\n            while (min <= max) {\n                guess = (min + max) / 2 | 0;\n                if (list[guess] === item) {\n                    return guess;\n                } else {\n                    if (list[guess] < item) {\n                        min = guess + 1;\n                    } else {\n                        max = guess - 1;\n                    }\n                }\n            }\n        }\n        return -1;\n    },\n    smartIndexOf = function (array, item, _from, _to, _rtl) {\n        return (array && array[LENGTH] > 100 ? binaryIndexOf : indexOf)(array, item, _from, _to, _rtl);\n    },\n    /**\n     * @func\n     */\n    splice = function () {\n        var ctx = shift(arguments);\n        return arrayProto.splice.apply(ctx, arguments);\n    },\n    reverse = function (arr) {\n        return arrayProto.reverse.call(arr);\n    },\n    /**\n     * @func\n     */\n    toString = function (obj) {\n        return obj == NULL ? EMPTY_STRING : obj + EMPTY_STRING;\n    },\n    stringify = function (obj) {\n        return (isObject(obj) ? JSON.stringify(obj) : isFunction(obj) ? obj.toString() : obj) + EMPTY_STRING;\n    },\n    /**\n     * @func\n     */\n    sort = function (obj, fn_) {\n        var fn = fn_ || function (a, b) {\n            return a > b;\n        };\n        // normalize sort function handling for safari\n        return arrayProto.sort.call(obj, function () {\n            var result = fn.apply(this, arguments),\n                numericResult = +result;\n            if (isNaN(numericResult)) {\n                numericResult = 0;\n            }\n            if (numericResult > 1) {\n                numericResult = 1;\n            }\n            if (result === BOOLEAN_FALSE || numericResult < -1) {\n                numericResult = -1;\n            }\n            return numericResult;\n        });\n    },\n    /**\n     * @func\n     */\n    has = function (obj, prop) {\n        var val = !1;\n        if (obj && isFunction(obj.hasOwnProperty)) {\n            val = obj.hasOwnProperty(prop);\n        }\n        return val;\n    },\n    /**\n     * @func\n     */\n    previousConstructor = function (instance) {\n        return instance && instance[CONSTRUCTOR_KEY] && instance[CONSTRUCTOR_KEY][CONSTRUCTOR] || instance[CONSTRUCTOR];\n    },\n    nativeIsInstance = function (instance, constructor) {\n        var result = BOOLEAN_FALSE;\n        if (isFunction(constructor)) {\n            result = instance instanceof constructor;\n        }\n        return result;\n    },\n    isInstance = function (instance, constructor_) {\n        var constructor = constructor_;\n        while (has(constructor, CONSTRUCTOR)) {\n            constructor = constructor[CONSTRUCTOR];\n        }\n        return nativeIsInstance(instance, constructor);\n    },\n    /**\n     * @func\n     */\n    splitGen = function (delimiter) {\n        return function (list) {\n            if (isString(list)) {\n                list = split(list, delimiter);\n            }\n            return list;\n        };\n    },\n    /**\n     * @func\n     */\n    joinGen = function (delimiter) {\n        return function (arr) {\n            return join(arr, delimiter);\n        };\n    },\n    /**\n     * @func\n     */\n    gapJoin = joinGen(' '),\n    /**\n     * @func\n     */\n    gapSplit = splitGen(' '),\n    /**\n     * @func\n     */\n    isWrap = function (type, fn) {\n        if (!fn) {\n            fn = function () {\n                return 1;\n            };\n        }\n        return function (thing) {\n            var ret = 0;\n            if (typeof thing === type && fn(thing)) {\n                ret = 1;\n            }\n            return !!ret;\n        };\n    },\n    /**\n     * @func\n     */\n    isFunction = isWrap(FUNCTION),\n    /**\n     * @func\n     */\n    isBoolean = isWrap(BOOLEAN),\n    /**\n     * @func\n     */\n    isString = isWrap(STRING),\n    /**\n     * @func\n     */\n    isNull = function (thing) {\n        return thing === NULL;\n    },\n    isUndefined = function (thing) {\n        return thing === UNDEFINED;\n    },\n    isBlank = function (thing) {\n        return isUndefined(thing) || isNull(thing);\n    },\n    /**\n     * @func\n     */\n    isNaN = function (thing) {\n        return thing !== thing;\n    },\n    negate = function (fn) {\n        return function () {\n            return !fn.apply(this, arguments);\n        };\n    },\n    isNumber = isWrap('number', negate(isNaN)),\n    isFinite_ = win.isFinite,\n    isFinite = function (thing) {\n        return isNumber(thing) && isFinite_(thing);\n    },\n    /**\n     * @func\n     */\n    isObject = isWrap(OBJECT, function (thing) {\n        return !!thing;\n    }),\n    /**\n     * @func\n     */\n    isArray = Array.isArray,\n    /**\n     * @func\n     */\n    isEmpty = function (obj) {\n        return !keys(obj)[LENGTH];\n    },\n    nonEnumerableProps = gapSplit('valueOf isPrototypeOf ' + TO_STRING + ' propertyIsEnumerable hasOwnProperty toLocaleString'),\n    /**\n     * @func\n     */\n    invert = function (obj) {\n        var i = 0,\n            result = {},\n            objKeys = keys(obj),\n            length = objKeys[LENGTH];\n        for (; i < length; i++) {\n            result[obj[objKeys[i]]] = objKeys[i];\n        }\n        return result;\n    },\n    /**\n     * @func\n     */\n    collectNonEnumProps = function (obj, keys) {\n        var nonEnumIdx = nonEnumerableProps[LENGTH];\n        var constructor = obj[CONSTRUCTOR];\n        var proto = (isFunction(constructor) && constructor[PROTOTYPE]) || ObjProto;\n        // Constructor is a special case.\n        var prop = CONSTRUCTOR;\n        if (has(obj, prop) && !contains(keys, prop)) keys.push(prop);\n        while (nonEnumIdx--) {\n            prop = nonEnumerableProps[nonEnumIdx];\n            if (prop in obj && obj[prop] !== proto[prop] && !contains(keys, prop)) {\n                keys.push(prop);\n            }\n        }\n    },\n    /**\n     * @func\n     */\n    // stringify = toString,\n    // stringify = function (obj) {\n    //     return (isObject(obj) ? JSON.stringify(obj) : isFunction(obj) ? obj.toString() : obj) + EMPTY_STRING;\n    // },\n    /**\n     * @func\n     */\n    uniqueId = (function () {\n        var cache = {},\n            global = 0;\n        return function (prefix, isInt) {\n            var val;\n            if (!prefix) {\n                prefix = EMPTY_STRING;\n            }\n            prefix += EMPTY_STRING;\n            val = cache[prefix];\n            if (!val) {\n                val = cache[prefix] = 0;\n            }\n            cache[prefix]++;\n            if (!isInt) {\n                val = prefix + val;\n            }\n            return val;\n        };\n    }()),\n    now = function () {\n        return +(new Date());\n    },\n    /**\n     * @func\n     */\n    extend = function () {\n        var deep = BOOLEAN_FALSE,\n            args = arguments,\n            length = args[LENGTH],\n            index = 1,\n            first = 0,\n            base = args[0];\n        if (base === BOOLEAN_TRUE) {\n            deep = BOOLEAN_TRUE;\n            base = args[1];\n            index = 2;\n        }\n        base = base || {};\n        for (; index < length; index++) {\n            merge(base, args[index], deep);\n        }\n        return base;\n    },\n    merge = function (obj1, obj2, deep) {\n        var key, val, i = 0,\n            keys = allKeys(obj2),\n            l = keys[LENGTH];\n        for (; i < l; i++) {\n            key = keys[i];\n            // ignore undefined\n            if (obj2[key] !== UNDEFINED) {\n                val = obj2[key];\n                if (deep) {\n                    if (isObject(obj2[key])) {\n                        if (!isObject(obj1[key])) {\n                            obj1[key] = returnDismorphicBase(obj2[key]);\n                        }\n                        merge(obj1[key], obj2[key], deep);\n                    } else {\n                        obj1[key] = val;\n                    }\n                } else {\n                    obj1[key] = val;\n                }\n            }\n        }\n        return obj1;\n    },\n    /**\n     * @func\n     */\n    // Helper for collection methods to determine whether a collection\n    // should be iterated as an array or as an object\n    // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n    // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n    MAX_ARRAY_INDEX = Math.pow(2, 53) - 1,\n    /**\n     * @func\n     */\n    isArrayLike = function (collection) {\n        var length = !!collection && collection[LENGTH];\n        return isArray(collection) || (isNumber(length) && !isString(collection) && length >= 0 && length <= MAX_ARRAY_INDEX && !isFunction(collection));\n    },\n    eachProxy = function (fn) {\n        return function (obj_, iteratee_, context_, direction_) {\n            var ret, obj = obj_,\n                list = obj,\n                iteratee = iteratee_,\n                iterator = iteratee,\n                context = context_,\n                direction = direction_;\n            if (!obj) {\n                return obj;\n            }\n            if (!isArrayLike(obj)) {\n                list = keys(obj);\n                if (context) {\n                    iteratee = bind(iterator, context);\n                }\n                context = NULL;\n                iterator = function (key, idx, list) {\n                    // gives you the key, use that to get the value\n                    return iteratee(obj[key], key, obj);\n                };\n            }\n            return fn(list, iterator, context, direction);\n        };\n    },\n    /**\n     * @func\n     */\n    createPredicateIndexFinder = function (dir) {\n        return eachProxy(function (array, predicate, context, index_) {\n            var length = array[LENGTH],\n                callback = bind(predicate, context),\n                index = index_ || (dir > 0 ? 0 : length - 1);\n            for (; index >= 0 && index < length; index += dir) {\n                if (callback(array[index], index, array)) {\n                    return index;\n                }\n            }\n            return -1;\n        });\n    },\n    /**\n     * @func\n     */\n    // Returns the first index on an array-like that passes a predicate test\n    findIndex = createPredicateIndexFinder(1),\n    /**\n     * @func\n     */\n    findLastIndex = createPredicateIndexFinder(-1),\n    /**\n     * @func\n     */\n    validKey = function (key) {\n        // -1 for arrays\n        // any other data type ensures string\n        return key !== -1 && key === key && key !== UNDEFINED && key !== NULL && key !== BOOLEAN_FALSE && key !== BOOLEAN_TRUE;\n    },\n    finder = function (findHelper) {\n        return function (obj, predicate, context, startpoint) {\n            var key = findHelper(obj, predicate, context, startpoint);\n            if (validKey(key)) {\n                return obj[key];\n            }\n        };\n    },\n    find = finder(findIndex),\n    findLast = finder(findLastIndex),\n    bind = function (fn_, ctx) {\n        var fn = fn_;\n        if (ctx) {\n            fn = fn_.bind(ctx);\n        }\n        return fn;\n    },\n    duff = function (values, runner_, context, direction) {\n        var runner, iterations, val, i, leftover, deltaFn;\n        if (!values) {\n            return;\n        }\n        i = 0;\n        val = values[LENGTH];\n        leftover = val % 8;\n        iterations = parseInt(val / 8, 10);\n        if (direction < 0) {\n            i = val - 1;\n        }\n        direction = direction || 1;\n        runner = bind(runner_, context);\n        if (leftover > 0) {\n            do {\n                runner(values[i], i, values);\n                i += direction;\n            } while (--leftover > 0);\n        }\n        if (iterations) {\n            do {\n                runner(values[i], i, values);\n                i += direction;\n                runner(values[i], i, values);\n                i += direction;\n                runner(values[i], i, values);\n                i += direction;\n                runner(values[i], i, values);\n                i += direction;\n                runner(values[i], i, values);\n                i += direction;\n                runner(values[i], i, values);\n                i += direction;\n                runner(values[i], i, values);\n                i += direction;\n                runner(values[i], i, values);\n                i += direction;\n            } while (--iterations > 0);\n        }\n        return values;\n    },\n    each = eachProxy(duff),\n    tackRight = function (fn) {\n        return function (list, iterator, context) {\n            return fn(list, iterator, arguments[LENGTH] < 3 ? NULL : context, -1);\n        };\n    },\n    duffRight = tackRight(duff),\n    eachRight = tackRight(each),\n    /**\n     * @func\n     */\n    toBoolean = function (thing) {\n        var ret, thingMod = thing + EMPTY_STRING;\n        thingMod = thingMod.trim();\n        if (thingMod === BOOLEAN_FALSE + EMPTY_STRING) {\n            ret = BOOLEAN_FALSE;\n        }\n        if (thingMod === BOOLEAN_TRUE + EMPTY_STRING) {\n            ret = BOOLEAN_TRUE;\n        }\n        if (ret === UNDEFINED) {\n            ret = thing;\n        }\n        return ret;\n    },\n    /**\n     * @func\n     */\n    parseDecimal = function (num) {\n        return parseFloat(num) || 0;\n    },\n    pI = function (num) {\n        return parseInt(num, 10) || 0;\n    },\n    allKeys = function (obj) {\n        var key, keys = [];\n        for (key in obj) {\n            keys.push(key);\n        }\n        // Ahem, IE < 9.\n        if (hasEnumBug) {\n            collectNonEnumProps(obj, keys);\n        }\n        return keys;\n    },\n    keys = function (obj) {\n        var key, keys = [];\n        if (!obj || (!isObject(obj) && !isFunction(obj))) {\n            return keys;\n        }\n        if (nativeKeys) {\n            return nativeKeys(obj);\n        }\n        for (key in obj) {\n            if (has(obj, key)) {\n                keys.push(key);\n            }\n        }\n        // Ahem, IE < 9.\n        if (hasEnumBug) {\n            collectNonEnumProps(obj, keys);\n        }\n        return keys;\n    },\n    /**\n     * @func\n     */\n    constructorExtend = function (name, protoProps, attach) {\n        var nameString, child, passedParent, hasConstructor, constructor, parent = this,\n            nameIsStr = isString(name);\n        if (!nameIsStr) {\n            protoProps = name;\n        }\n        hasConstructor = has(protoProps, CONSTRUCTOR);\n        if (protoProps && hasConstructor) {\n            child = protoProps[CONSTRUCTOR];\n        }\n        if (nameIsStr) {\n            passedParent = parent;\n            if (child) {\n                passedParent = child;\n            }\n            child = new Function[CONSTRUCTOR]('var parent=arguments[0];return function ' + name + '(){return parent.apply(this,arguments);}')(passedParent);\n            // factories[name] = child;\n        } else {\n            child = function () {\n                return parent.apply(this, arguments);\n            };\n        }\n        // extend(child, parent);\n        child[EXTEND] = constructorExtend;\n        var Surrogate = function () {\n            this[CONSTRUCTOR] = child;\n        };\n        Surrogate[PROTOTYPE] = parent[PROTOTYPE];\n        child[PROTOTYPE] = new Surrogate;\n        // don't call the function if nothing exists\n        if (protoProps) {\n            extend(child[PROTOTYPE], protoProps);\n        }\n        constructor = child;\n        child = constructorWrapper(constructor);\n        child.__super__ = parent;\n        constructor[PROTOTYPE][CONSTRUCTOR_KEY] = child;\n        if (nameIsStr && attach) {\n            factories[name] = child;\n        }\n        return child;\n    },\n    constructorWrapper = function (Constructor) {\n        var __ = function (one, two, three, four, five, six) {\n            if (isInstance(one, Constructor)) {\n                return one;\n            }\n            return new Constructor(one, two, three, four, five, six);\n        };\n        __.isInstance = Constructor.isInstance = function (instance) {\n            return isInstance(instance, Constructor);\n        };\n        __[CONSTRUCTOR] = Constructor;\n        __[EXTEND] = Constructor[EXTEND] = function () {\n            return constructorExtend.apply(Constructor, arguments);\n        };\n        return __;\n    },\n    /**\n     * @func\n     */\n    once = function (fn) {\n        var doIt;\n        return function () {\n            if (!doIt) {\n                doIt = 1;\n                return fn.apply(this, arguments);\n            }\n        };\n    },\n    /**\n     * @func\n     */\n    // Internal recursive comparison function for `isEqual`.\n    eq = function (a, b, aStack, bStack) {\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n        if (a === b) {\n            return a !== 0 || 1 / a === 1 / b;\n        }\n        // A strict comparison is necessary because `NULL == undefined`.\n        if (a === NULL || a === UNDEFINED || b === UNDEFINED || b === NULL) {\n            return a === b;\n        }\n        // Unwrap any wrapped objects.\n        // if (a instanceof _) a = a._wrapped;\n        // if (b instanceof _) b = b._wrapped;\n        // Compare `[[Class]]` names.\n        var className = toString.call(a);\n        if (className !== toString.call(b)) return BOOLEAN_FALSE;\n        switch (className) {\n            // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n        case BRACKET_OBJECT_SPACE + 'RegExp]':\n            // RegExps are coerced to strings for comparison (Note: EMPTY_STRING + /a/i === '/a/i')\n        case BRACKET_OBJECT_SPACE + 'String]':\n            // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n            // equivalent to `new String(\"5\")`.\n            return EMPTY_STRING + a === EMPTY_STRING + b;\n        case BRACKET_OBJECT_SPACE + 'Number]':\n            // `NaN`s are equivalent, but non-reflexive.\n            // Object(NaN) is equivalent to NaN\n            if (+a !== +a) return +b !== +b;\n            // An `egal` comparison is performed for other numeric values.\n            return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n        case BRACKET_OBJECT_SPACE + 'Date]':\n        case BRACKET_OBJECT_SPACE + 'Boolean]':\n            // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n            // millisecond representations. Note that invalid dates with millisecond representations\n            // of `NaN` are not equivalent.\n            return +a === +b;\n        }\n        var areArrays = className === BRACKET_OBJECT_SPACE + 'Array]';\n        if (!areArrays) {\n            if (typeof a != OBJECT || typeof b != OBJECT) return BOOLEAN_FALSE;\n            // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n            // from different frames are.\n            var aCtor = a[CONSTRUCTOR],\n                bCtor = b[CONSTRUCTOR];\n            if (aCtor !== bCtor && !(isFunction(aCtor) && nativeIsInstance(aCtor, aCtor) && isFunction(bCtor) && nativeIsInstance(bCtor, bCtor)) && (CONSTRUCTOR in a && CONSTRUCTOR in b)) {\n                return BOOLEAN_FALSE;\n            }\n        }\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n        // Initializing stack of traversed objects.\n        // It's done here since we only need them for objects and arrays comparison.\n        // aStack = aStack || [];\n        // bStack = bStack || [];\n        var length = aStack[LENGTH];\n        while (length--) {\n            // Linear search. Performance is inversely proportional to the number of\n            // unique nested structures.\n            if (aStack[length] === a) {\n                return bStack[length] === b;\n            }\n        }\n        // Add the first object to the stack of traversed objects.\n        aStack.push(a);\n        bStack.push(b);\n        // Recursively compare objects and arrays.\n        if (areArrays) {\n            // Compare array lengths to determine if a deep comparison is necessary.\n            length = a[LENGTH];\n            if (length !== b[LENGTH]) {\n                return BOOLEAN_FALSE;\n            }\n            // Deep compare the contents, ignoring non-numeric properties.\n            while (length--) {\n                if (!eq(a[length], b[length], aStack, bStack)) {\n                    return BOOLEAN_FALSE;\n                }\n            }\n        } else {\n            // Deep compare objects.\n            var objKeys = keys(a),\n                key;\n            length = objKeys[LENGTH];\n            // Ensure that both objects contain the same number of properties before comparing deep equality.\n            if (keys(b)[LENGTH] !== length) return BOOLEAN_FALSE;\n            while (length--) {\n                // Deep compare each member\n                key = objKeys[length];\n                if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return BOOLEAN_FALSE;\n            }\n        }\n        // Remove the first object from the stack of traversed objects.\n        aStack.pop();\n        bStack.pop();\n        return BOOLEAN_TRUE;\n    },\n    /**\n     * @func\n     */\n    // Perform a deep comparison to check if two objects are equal.\n    isEqual = function (a, b) {\n        return eq(a, b, [], []);\n    },\n    /**\n     * @func\n     */\n    // very shallow clone\n    clone = function (obj) {\n        return map(obj, function (value, key) {\n            return value;\n        });\n    },\n    fullClone = function (obj) {\n        return parse(stringify(obj));\n    },\n    /**\n     * @func\n     */\n    wrap = function (obj, fn, noExecute) {\n        var newObj = {},\n            _isArray = isArray(obj),\n            wasfunction = isFunction(fn);\n        each(obj, function (value, key) {\n            if (_isArray) {\n                if (!wasfunction || noExecute) {\n                    newObj[value] = fn;\n                } else {\n                    newObj[value] = fn(value);\n                }\n            } else {\n                newObj[key] = fn(obj[key], key);\n            }\n        });\n        return newObj;\n    },\n    /**\n     * @func\n     */\n    unshift = function (thing, items) {\n        return thing.unshift.apply(thing, items);\n    },\n    /**\n     * @func\n     */\n    exports = function (obj) {\n        return extend(_, obj);\n    },\n    /**\n     * @func\n     */\n    Image = win.Image,\n    fetch = function (url, callback) {\n        var img = new Image();\n        url = stringifyQuery(url);\n        if (callback) {\n            img.onload = function () {\n                _.unshift(arguments, url);\n                callback.apply(this, arguments);\n            };\n        }\n        img.src = url;\n        return img;\n    },\n    parse = function (val_) {\n        var val = val_;\n        if (isString(val)) {\n            val = val.trim();\n            if (val[0] === '{' || val[0] === '[') {\n                wraptry(function () {\n                    val = JSON.parse(val);\n                }, console.error);\n            } else {\n                // parses the number out if it's a number\n                val = +val === val ? +val : val;\n            }\n        }\n        return val;\n    },\n    debounce = function (func, wait, immediate) {\n        var timeout;\n        return function () {\n            var context = this,\n                args = arguments,\n                callNow = immediate && !timeout,\n                later = function () {\n                    timeout = NULL;\n                    if (!immediate) {\n                        func.apply(context, args);\n                    }\n                };\n            clearTimeout(timeout);\n            timeout = setTimeout(later, wait);\n            if (callNow) {\n                func.apply(context, args);\n            }\n            return timeout;\n        };\n    },\n    returnDismorphicBase = function (obj) {\n        return isArrayLike(obj) ? [] : {};\n    },\n    map = function (objs, iteratee, context) {\n        var collection = returnDismorphicBase(objs),\n            bound = bind(iteratee, context);\n        return !objs ? collection : each(objs, function (item, index) {\n            collection[index] = bound(item, index, objs);\n        }) && collection;\n    },\n    arrayLikeToArray = function (arrayLike) {\n        return Array.apply(null, arrayLike);\n    },\n    objectToArray = function (obj) {\n        return !obj ? [] : foldl(obj, function (memo, item) {\n            memo.push(item);\n            return memo;\n        }, []);\n    },\n    toArray = function (obj, delimiter) {\n        return isArrayLike(obj) ? isArray(obj) ? obj : arrayLikeToArray(obj) : (isString(obj) ? obj.split(isString(delimiter) ? delimiter : EMPTY_STRING) : objectToArray(obj));\n    },\n    flattenArray = function (list, deep_) {\n        var deep = !!deep_;\n        return foldl(list, function (memo, item_) {\n            var item;\n            if (isArrayLike(item_)) {\n                item = deep ? flattenArray.call(NULL, item_, deep) : item_;\n                return memo.concat(item);\n            } else {\n                memo.push(item_);\n                return memo;\n            }\n        }, []);\n    },\n    flatten = function (list, deep) {\n        return flattenArray(isArrayLike(list) ? list : objectToArray(list), deep);\n    },\n    baseClamp = function (number, lower, upper) {\n        if (number === number) {\n            if (upper !== UNDEFINED) {\n                number = number <= upper ? number : upper;\n            }\n            if (lower !== UNDEFINED) {\n                number = number >= lower ? number : lower;\n            }\n        }\n        return number;\n    },\n    safeInteger = function (number_) {\n        return baseClamp(number_, MIN_SAFE_VALUE, MAX_SAFE_VALUE);\n    },\n    isValidInteger = function (number) {\n        return number < MAX_VALUE && number > MIN_VALUE;\n    },\n    clampInteger = function (number) {\n        return baseClamp(number, MIN_VALUE, MAX_VALUE);\n    },\n    floatToInteger = function (value) {\n        var remainder = value % 1;\n        return value === value ? (remainder ? value - remainder : value) : 0;\n    },\n    toInteger = function (number, notSafe) {\n        var converted;\n        return floatToInteger((converted = +number) == number ? (notSafe ? converted : safeInteger(converted)) : 0);\n    },\n    isLength = function (number) {\n        return isNumber(number) && isValidInteger(number);\n    },\n    toLength = function (number) {\n        return number ? clampInteger(toInteger(number, BOOLEAN_TRUE), 0, MAX_ARRAY_LENGTH) : 0;\n    },\n    /**\n     * @func\n     */\n    throttle = function (fn, threshold, scope) {\n        var last,\n            deferTimer;\n        if (!threshold) {\n            threshold = 250;\n        }\n        return function () {\n            var context = scope || this,\n                _now = now(),\n                args = arguments;\n            if (last && _now < last + threshold) {\n                // hold on to it\n                clearTimeout(deferTimer);\n                deferTimer = setTimeout(function () {\n                    last = _now;\n                    fn.apply(context, args);\n                }, threshold);\n            } else {\n                last = _now;\n                fn.apply(context, args);\n            }\n        };\n    },\n    /**\n     * @func\n     */\n    stringifyQuery = function (obj) {\n        var val, n, base = obj.url,\n            query = [];\n        if (isObject(obj)) {\n            for (n in obj.query) {\n                val = obj.query[n];\n                if (val !== UNDEFINED) {\n                    val = encodeURIComponent(stringify(val));\n                    query.push(n + '=' + val);\n                }\n            }\n            if (query[LENGTH]) {\n                base += '?';\n            }\n            base += query.join('&');\n            if (obj.hash) {\n                obj.hash = _.stringify(obj.hash);\n                base += ('#' + obj.hash);\n            }\n        } else {\n            base = obj;\n        }\n        return base;\n    },\n    protoProperty = function (instance, key, farDown) {\n        var val, proto, constructor = previousConstructor(instance);\n        farDown = farDown || 1;\n        do {\n            proto = constructor[PROTOTYPE];\n            val = proto[key];\n            constructor = previousConstructor(proto);\n        } while (--farDown > 0 && constructor && isFinite(farDown));\n        return val;\n    },\n    uuid = function () {\n        var UNDEFINED, cryptoCheck = 'crypto' in win && 'getRandomValues' in crypto,\n            sid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n                var rnd, r, v;\n                if (cryptoCheck) {\n                    rnd = win.crypto.getRandomValues(new Uint32Array(1));\n                    if (rnd === UNDEFINED) {\n                        cryptoCheck = BOOLEAN_FALSE;\n                    }\n                }\n                if (!cryptoCheck) {\n                    rnd = [Math.floor(Math.random() * 10000000000)];\n                }\n                rnd = rnd[0];\n                r = rnd % 16;\n                v = (c === 'x') ? r : (r & 0x3 | 0x8);\n                return v.toString(16);\n            });\n        return cryptoCheck ? sid : 'SF' + sid;\n    },\n    intendedObject = function (key, value, fn_, ctx) {\n        var fn = ctx ? bind(fn_, ctx) : fn_,\n            obj = isObject(key) ? key : BOOLEAN_FALSE;\n        if (obj) {\n            each(obj, reverseParams(fn));\n        } else {\n            fn(key, value);\n        }\n    },\n    reverseParams = function (iteratorFn) {\n        return function (value, key, third) {\n            iteratorFn(key, value, third);\n        };\n    },\n    /**\n     * @func\n     */\n    reference = function (str) {\n        var match;\n        if (!isString(str)) {\n            str = str.referrer;\n        }\n        match = str.match(/^https?:\\/\\/.*?\\//);\n        if (match) {\n            match = match[0];\n        }\n        return match || EMPTY_STRING;\n    },\n    /**\n     * @func\n     */\n    roundFloat = function (val, power, base) {\n        var mult;\n        if (!isNumber(power)) {\n            power = 1;\n        }\n        mult = Math.pow(base || 10, power);\n        return (parseInt((mult * val), 10) / mult);\n    },\n    result = function (obj, str, arg, knows) {\n        return isObject(obj) ? (knows || isFunction(obj[str]) ? obj[str](arg) : obj[str]) : obj;\n    },\n    maths = Math,\n    mathArray = function (method) {\n        return function (args) {\n            return maths[method].apply(maths, args);\n        };\n    },\n    ensureFunction = function (fn) {\n        return function (_fn) {\n            _fn = _fn || noop;\n            return fn.call(this, _fn);\n        };\n    },\n    matchesOneToOne = function (key, value) {\n        this[key] = value;\n    },\n    wipeKey = function (key) {\n        this[key] = UNDEFINED;\n    },\n    /**\n     * @func\n     */\n    // Create a reducing function iterating left or right.\n    createReduce = function (dir) {\n        // Optimized iterator function as using arguments[LENGTH]\n        // in the main function will deoptimize the, see #1991.\n        var iterator = function (obj, iteratee, memo, keys, index, length) {\n            var currentKey;\n            for (; index >= 0 && index < length; index += dir) {\n                currentKey = keys ? keys[index] : index;\n                memo = iteratee(memo, obj[currentKey], currentKey, obj);\n            }\n            return memo;\n        };\n        return function (obj, iteratee, memo, context) {\n            // iteratee = optimizeCb(iteratee, context, 4);\n            var actualKeys = !isArrayLike(obj) && keys(obj),\n                length = (actualKeys || obj)[LENGTH],\n                index = dir > 0 ? 0 : length - 1;\n            // Determine the initial value if none is provided.\n            if (arguments[LENGTH] < 3) {\n                memo = obj[actualKeys ? actualKeys[index] : index];\n                index += dir;\n            }\n            return iterator(obj, iteratee, memo, actualKeys, index, length);\n        };\n    },\n    // **Reduce** builds up a single result from a list of values, aka `inject`,\n    // or `foldl`.\n    /**\n     * @func\n     */\n    foldl = createReduce(1),\n    // The right-associative version of reduce, also known as `foldr`.\n    /**\n     * @func\n     */\n    foldr = createReduce(-1),\n    _console = win.console || {},\n    _log = _console.log || noop,\n    // use same name so that we can ensure browser compatability\n    console = extend(wrap(gapSplit('trace log dir error'), function (key) {\n        var method = _console[key] || _log;\n        return function () {\n            return method.apply(_console, arguments);\n        };\n    }), {\n        exception: function (options) {\n            throw new Error(options && options.message || options);\n        },\n        validate: function (boolean_, options) {\n            if (boolean_) {\n                exception(options);\n            }\n        }\n    }),\n    exception = console.exception,\n    wraptry = function (trythis, errthat, finalfunction) {\n        try {\n            return trythis();\n        } catch (e) {\n            return errthat && errthat(e);\n        } finally {\n            return finalfunction && finalfunction();\n        }\n    },\n    toggle = function (current, which) {\n        if (which === UNDEFINED) {\n            return !current;\n        } else {\n            return !!which;\n        }\n    },\n    returns = function (thing) {\n        return function () {\n            return thing;\n        };\n    },\n    flow = function (bool, list_) {\n        var list = bool === BOOLEAN_TRUE ? list_ : arguments,\n            length = list[LENGTH];\n        return function () {\n            var start = 1,\n                args = arguments,\n                arg = list[0].apply(this, args);\n            while (start < length) {\n                arg = list[start].call(this, arg);\n                ++start;\n            }\n            return arg;\n        };\n    },\n    _ = app._ = {\n        months: gapSplit('january feburary march april may june july august september october november december'),\n        weekdays: gapSplit('sunday monday tuesday wednesday thursday friday saturday'),\n        constructorWrapper: constructorWrapper,\n        stringifyQuery: stringifyQuery,\n        intendedObject: intendedObject,\n        ensureFunction: ensureFunction,\n        parseDecimal: parseDecimal,\n        flatten: flatten,\n        reference: reference,\n        isArrayLike: isArrayLike,\n        isInstance: isInstance,\n        hasEnumBug: hasEnumBug,\n        roundFloat: roundFloat,\n        factories: factories,\n        listSlice: listSlice,\n        fullClone: fullClone,\n        toBoolean: toBoolean,\n        stringify: stringify,\n        splitGen: splitGen,\n        gapSplit: gapSplit,\n        uniqueId: uniqueId,\n        wraptry: wraptry,\n        toString: toString,\n        throttle: throttle,\n        debounce: debounce,\n        protoProperty: protoProperty,\n        protoProp: protoProperty,\n        reverse: reverse,\n        binaryIndexOf: binaryIndexOf,\n        indexOfNaN: indexOfNaN,\n        toInteger: toInteger,\n        indexOf: indexOf,\n        joinGen: joinGen,\n        toArray: toArray,\n        isEqual: isEqual,\n        unshift: unshift,\n        gapJoin: gapJoin,\n        isArray: isArray,\n        isEmpty: isEmpty,\n        splice: splice,\n        returns: returns,\n        isBoolean: isBoolean,\n        invert: invert,\n        extend: extend,\n        noop: noop,\n        toggle: toggle,\n        reduce: foldl,\n        foldl: foldl,\n        foldr: foldr,\n        now: now,\n        map: map,\n        result: result,\n        isUndefined: isUndefined,\n        isFunction: isFunction,\n        isObject: isObject,\n        isNumber: isNumber,\n        isFinite: isFinite,\n        isString: isString,\n        isBlank: isBlank,\n        isNull: isNull,\n        isNaN: isNaN,\n        eachProxy: eachProxy,\n        exports: exports,\n        allKeys: allKeys,\n        slice: slice,\n        parse: parse,\n        shift: shift,\n        merge: merge,\n        fetch: fetch,\n        split: split,\n        clone: clone,\n        bind: bind,\n        duff: duff,\n        duffRight: duffRight,\n        eachRight: eachRight,\n        sort: sort,\n        join: join,\n        wrap: wrap,\n        uuid: uuid,\n        keys: keys,\n        once: once,\n        each: each,\n        push: push,\n        flow: flow,\n        pop: pop,\n        has: has,\n        negate: negate,\n        pI: pI,\n        createPredicateIndexFinder: createPredicateIndexFinder,\n        findIndex: findIndex,\n        findLastIndex: findLastIndex,\n        validKey: validKey,\n        finder: finder,\n        find: find,\n        findLast: findLast,\n        console: console,\n        min: mathArray('min'),\n        max: mathArray('max'),\n        arrayLikeToArray: arrayLikeToArray,\n        objectToArray: objectToArray,\n        math: wrap(gapSplit('E LN2 LN10 LOG2E LOG10E PI SQRT1_2 SQRT2 abs acos acosh asin asinh atan atan2 atanh cbrt ceil clz32 cos cosh exp expm1 floor fround hypot imul log log1p log2 log10 pow random round sign sin sinh sqrt tan tanh trunc'), function (key) {\n            return Math[key];\n        })\n    };\n/**\n * @class Model\n */\nfunction Model(attributes, options) {\n    return this;\n}\nModel[PROTOTYPE] = {};\nfactories.Model = constructorWrapper(Model);","application.scope(function (app) {\n    app.shims = function (win) {\n        var fn = function () {\n            var win = this,\n                lengthString = 'length';\n            win.performance = win.performance || {};\n            win.performance.now = (function () {\n                var performance = win.performance;\n                return performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {\n                    return new Date().getTime();\n                };\n            })();\n\n            function f(n) {\n                return n < 10 ? \"0\" + n : n;\n            }\n\n            function quote(string) {\n                escapable.lastIndex = 0;\n                return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n                    var c = meta[a];\n                    return typeof c === \"string\" ? c : \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n                }) + '\"' : '\"' + string + '\"';\n            }\n\n            function str(key, holder) {\n                var i, k, v, length, mind = gap,\n                    partial, value = holder[key];\n                if (value && typeof value === \"object\" && typeof value.toJSON === \"function\") {\n                    value = value.toJSON(key);\n                }\n                if (typeof rep === \"function\") {\n                    value = rep.call(holder, key, value);\n                }\n                switch (typeof value) {\n                case \"string\":\n                    return quote(value);\n                case \"number\":\n                    return isFinite(value) ? String(value) : \"null\";\n                case \"boolean\":\n                case \"null\":\n                    return String(value);\n                case \"object\":\n                    if (!value) {\n                        return \"null\";\n                    }\n                    gap += indent;\n                    partial = [];\n                    if (Object.prototype.toString.apply(value) === \"[object Array]\") {\n                        length = value[lengthString];\n                        for (i = 0; i < length; i += 1) {\n                            partial[i] = str(i, value) || \"null\";\n                        }\n                        v = partial[lengthString] === 0 ? \"[]\" : gap ? \"[\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"]\" : \"[\" + partial.join(\",\") + \"]\";\n                        gap = mind;\n                        return v;\n                    }\n                    if (rep && typeof rep === \"object\") {\n                        length = rep[lengthString];\n                        for (i = 0; i < length; i += 1) {\n                            if (typeof rep[i] === \"string\") {\n                                k = rep[i];\n                                v = str(k, value);\n                                if (v) {\n                                    partial.push(quote(k) + (gap ? \": \" : \":\") + v);\n                                }\n                            }\n                        }\n                    } else {\n                        for (k in value) {\n                            if (Object.prototype.hasOwnProperty.call(value, k)) {\n                                v = str(k, value);\n                                if (v) {\n                                    partial.push(quote(k) + (gap ? \": \" : \":\") + v);\n                                }\n                            }\n                        }\n                    }\n                    v = partial[lengthString] === 0 ? \"{}\" : gap ? \"{\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"}\" : \"{\" + partial.join(\",\") + \"}\";\n                    gap = mind;\n                    return v;\n                }\n            }\n            if (!JSON) {\n                if (typeof Date.prototype.toJSON !== \"function\") {\n                    Date.prototype.toJSON = function (key) {\n                        return isFinite(this.valueOf()) ? this.getUTCFullYear() + \"-\" + f(this.getUTCMonth() + 1) + \"-\" + f(this.getUTCDate()) + \"T\" + f(this.getUTCHours()) + \":\" + f(this.getUTCMinutes()) + \":\" + f(this.getUTCSeconds()) + \"Z\" : null;\n                    };\n                    String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function (key) {\n                        return this.valueOf();\n                    };\n                }\n                var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n                    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n                    gap, indent, meta = {\n                        \"\\b\": \"\\\\b\",\n                        \"\\t\": \"\\\\t\",\n                        \"\\n\": \"\\\\n\",\n                        \"\\f\": \"\\\\f\",\n                        \"\\r\": \"\\\\r\",\n                        '\"': '\\\\\"',\n                        \"\\\\\": \"\\\\\\\\\"\n                    },\n                    rep;\n                if (typeof JSON.stringify !== \"function\") {\n                    JSON.stringify = function (value, replacer, space) {\n                        var i;\n                        gap = \"\";\n                        indent = \"\";\n                        if (typeof space === \"number\") {\n                            for (i = 0; i < space; i += 1) {\n                                indent += \" \";\n                            }\n                        } else {\n                            if (typeof space === \"string\") {\n                                indent = space;\n                            }\n                        }\n                        rep = replacer;\n                        if (replacer && typeof replacer !== \"function\" && (typeof replacer !== \"object\" || typeof replacer[lengthString] !== \"number\")) {\n                            throw new Error(\"JSON.stringify\");\n                        }\n                        return str(\"\", {\n                            \"\": value\n                        });\n                    };\n                }\n                if (typeof JSON.parse !== \"function\") {\n                    JSON.parse = function (text, reviver) {\n                        var j;\n\n                        function walk(holder, key) {\n                            var k, v, value = holder[key];\n                            if (value && typeof value === \"object\") {\n                                for (k in value) {\n                                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                                        v = walk(value, k);\n                                        if (v !== undefined) {\n                                            value[k] = v;\n                                        } else {\n                                            delete value[k];\n                                        }\n                                    }\n                                }\n                            }\n                            return reviver.call(holder, key, value);\n                        }\n                        text = String(text);\n                        cx.lastIndex = 0;\n                        if (cx.test(text)) {\n                            text = text.replace(cx, function (a) {\n                                return \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n                            });\n                        }\n                        if (/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, \"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, \"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g, \"\"))) {\n                            j = Function.prototype.constructor(\"(\" + text + \")\");\n                            return typeof reviver === \"function\" ? walk({\n                                \"\": j\n                            }, \"\") : j;\n                        }\n                        throw new SyntaxError(\"JSON.parse\");\n                    };\n                }\n            }\n            if (!Function.prototype.bind) {\n                Function.prototype.bind = function (oThis) {\n                    if (typeof this !== 'function') {\n                        // closest thing possible to the ECMAScript 5\n                        // internal IsCallable function\n                        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n                    }\n                    var aArgs = Array.prototype.slice.call(arguments, 1),\n                        fToBind = this,\n                        FNOP = function () {},\n                        fBound = function () {\n                            return fToBind.apply(this instanceof FNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n                        };\n                    if (this.prototype) {\n                        // native functions don't have a prototype\n                        FNOP.prototype = this.prototype;\n                    }\n                    fBound.prototype = new FNOP();\n                    return fBound;\n                };\n            }\n            win.matchMedia = win.matchMedia || function () {\n                // \"use strict\";\n                // For browsers that support matchMedium api such as IE 9 and webkit\n                var styleMedia = (win.styleMedia || win.media);\n                // For those that don't support matchMedium\n                if (!styleMedia) {\n                    var style = document.createElement('style'),\n                        script = document.getElementsByTagName('script')[0],\n                        info = null;\n                    style.type = 'text/css';\n                    style.id = 'matchmediajs-test';\n                    script.parentNode.insertBefore(style, script);\n                    // 'style.currentStyle' is used by IE <= 8 and 'win.getComputedStyle' for all other browsers\n                    info = ('getComputedStyle' in win) && win.getComputedStyle(style, null) || style.currentStyle;\n                    styleMedia = {\n                        matchMedium: function (media) {\n                            var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\n                            // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n                            if (style.styleSheet) {\n                                style.styleSheet.cssText = text;\n                            } else {\n                                style.textContent = text;\n                            }\n                            // Test if media query is true or false\n                            return info.width === '1px';\n                        }\n                    };\n                }\n                return function (media) {\n                    media = media || 'all';\n                    return {\n                        matches: styleMedia.matchMedium(media),\n                        media: media\n                    };\n                };\n            }();\n        };\n        fn.call(win);\n    };\n    app.shims(win);\n});","// application.scope(function (app) {\nvar cacheable = function (fn) {\n        var cache = {};\n        return function (input) {\n            if (!has(cache, input)) {\n                cache[input] = fn(input);\n            }\n            return cache[input];\n        };\n    },\n    categoricallyCacheable = function (fn, baseCategory) {\n        var cache = {};\n        return function (string, category) {\n            var cacher;\n            category = category || baseCategory;\n            cacher = cache[category] = cache[category] || cacheable(fn(category));\n            return cacher(string);\n        };\n    },\n    string = _.extend(wrap(gapSplit('toLowerCase toUpperCase trim'), function (method) {\n        return cacheable(function (item) {\n            return item[method]();\n        });\n    }), wrap(gapSplit('match search'), function (method) {\n        return categoricallyCacheable(function (input) {\n            return function (item) {\n                return item[method](input);\n            };\n        });\n    })),\n    wrapAll = function (fn) {\n        return function () {\n            var args = toArray(arguments),\n                ctx = this;\n            return map(args[0], function (thing) {\n                args[0] = thing;\n                return fn.apply(ctx, args);\n            });\n        };\n    },\n    deprefix = function (str, prefix, unUpcase) {\n        var nuStr = str.slice(prefix[LENGTH]),\n            first = nuStr[0];\n        if (unUpcase) {\n            first = nuStr[0].toLowerCase();\n        }\n        nuStr = first + nuStr.slice(1);\n        return nuStr;\n    },\n    deprefixAll = wrapAll(deprefix),\n    prefix = function (str, prefix, camelcase, splitter) {\n        var myStr = prefix + str;\n        if (camelcase !== UNDEFINED) {\n            myStr = prefix + (splitter || HYPHEN) + str;\n            if (camelcase) {\n                myStr = camelCase(myStr, splitter);\n            } else {\n                myStr = unCamelCase(myStr, splitter);\n            }\n        }\n        return myStr;\n    },\n    prefixAll = wrapAll(prefix),\n    parseObject = (function () {\n        var cache = {};\n        return function (string) {\n            var found = cache[string];\n            if (!found) {\n                cache[string] = found = new Function.constructor('return ' + string);\n            }\n            return found();\n        };\n    }()),\n    /**\n     * @func\n     */\n    camelCase = categoricallyCacheable(function (splitter) {\n        return function (str) {\n            var i, s, val;\n            if (isString(str)) {\n                if (str[0] === splitter) {\n                    str = slice(str, 1);\n                }\n                s = split(str, splitter);\n                for (i = s[LENGTH] - 1; i >= 1; i--) {\n                    if (s[i]) {\n                        s[i] = upCase(s[i]);\n                    }\n                }\n                val = join(s, EMPTY_STRING);\n            }\n            return val;\n        };\n    }, HYPHEN),\n    /**\n     * @func\n     */\n    upCase = cacheable(function (s) {\n        return s[0].toUpperCase() + slice(s, 1);\n    }),\n    /**\n     * @func\n     */\n    unCamelCase = categoricallyCacheable(function (splitter) {\n        return function (str) {\n            return str.replace(/([a-z])([A-Z])/g, '$1' + splitter + '$2').replace(/[A-Z]/g, function (s) {\n                return s.toLowerCase();\n            });\n        };\n    }, HYPHEN),\n    snakeCase = function (string) {\n        return unCamelCase(string, '_');\n    },\n    /**\n     * @func\n     */\n    customUnits = categoricallyCacheable(function (unitList_) {\n        var lengthHash = {},\n            hash = {},\n            lengths = [],\n            unitList = gapSplit(unitList_),\n            sortedUnitList = unitList.sort(function (a, b) {\n                var aLength = a[LENGTH],\n                    bLength = b[LENGTH],\n                    value = _.max([-1, _.min([1, aLength - bLength])]);\n                hash[a] = hash[b] = BOOLEAN_TRUE;\n                if (!lengthHash[aLength]) {\n                    lengthHash[aLength] = BOOLEAN_TRUE;\n                    lengths.push(aLength);\n                }\n                if (!lengthHash[bLength]) {\n                    lengthHash[bLength] = BOOLEAN_TRUE;\n                    lengths.push(bLength);\n                }\n                return -1 * (value === 0 ? (a > b ? -1 : 1) : value);\n            });\n        lengths.sort(function (a, b) {\n            return -1 * _.max([-1, _.min([1, a - b])]);\n        });\n        return function (str_) {\n            var ch, unitStr, unit,\n                i = 0,\n                str = (str_ + EMPTY_STRING).trim(),\n                length = str[LENGTH];\n            while (lengths[i]) {\n                if (lengths[i] < length) {\n                    unit = str.substr(length - lengths[i], length);\n                    if (hash[unit]) {\n                        return unit;\n                    }\n                }\n                i++;\n            }\n            return BOOLEAN_FALSE;\n        };\n    }),\n    baseUnitList = gapSplit('px em rem ex in cm % vh vw pc pt mm vmax vmin'),\n    units = function (str) {\n        return customUnits(str, baseUnitList);\n    },\n    isHttp = cacheable(function (str) {\n        var ret = !1;\n        if ((str.indexOf(HTTP) === 0 && str.split('//')[LENGTH] >= 2) || str.indexOf('//') === 0) {\n            ret = !0;\n        }\n        return ret;\n    }),\n    parseHash = cacheable(function (url) {\n        var hash = EMPTY_STRING,\n            hashIdx = smartIndexOf(url, '#') + 1;\n        if (hashIdx) {\n            hash = url.slice(hashIdx - 1);\n        }\n        return hash;\n    }),\n    itemIs = function (list, item, index) {\n        return list[index || 0] === item;\n    },\n    startsWith = itemIs,\n    parseURL = function (url) {\n        var firstSlash, hostSplit, originNoProtocol, search = EMPTY_STRING,\n            hash = EMPTY_STRING,\n            host = EMPTY_STRING,\n            pathname = EMPTY_STRING,\n            protocol = EMPTY_STRING,\n            port = EMPTY_STRING,\n            hostname = EMPTY_STRING,\n            origin = url,\n            searchIdx = indexOf(url, '?') + 1,\n            searchObject = {},\n            protocols = [HTTP, HTTPS, 'file', 'about'],\n            protocolLength = protocols[LENGTH],\n            doubleSlash = SLASH + SLASH;\n        if (searchIdx) {\n            search = url.slice(searchIdx - 1);\n            origin = origin.split(search).join(EMPTY_STRING);\n            hash = parseHash(search);\n            search = search.split(hash).join(EMPTY_STRING);\n            searchObject = app.parseSearch(search);\n        } else {\n            hash = parseHash(url);\n            origin = origin.split(hash).join(EMPTY_STRING);\n        }\n        if (url[0] === SLASH && url[1] === SLASH) {\n            protocol = win.location.protocol;\n            url = protocol + url;\n            origin = protocol + origin;\n        } else {\n            while (protocolLength-- && !protocol) {\n                if (url.slice(0, protocols[protocolLength][LENGTH]) === protocols[protocolLength]) {\n                    protocol = protocols[protocolLength];\n                }\n            }\n            if (!protocol) {\n                protocol = HTTP;\n            }\n            protocol += COLON;\n            if (origin.slice(0, protocol[LENGTH]) + doubleSlash !== protocol + doubleSlash) {\n                url = protocol + doubleSlash + url;\n                origin = protocol + doubleSlash + origin;\n            }\n        }\n        originNoProtocol = origin.split(protocol + doubleSlash).join(EMPTY_STRING);\n        firstSlash = indexOf(originNoProtocol, SLASH) + 1;\n        pathname = originNoProtocol.slice(firstSlash - 1);\n        host = originNoProtocol.slice(0, firstSlash - 1);\n        origin = origin.split(pathname).join(EMPTY_STRING);\n        hostSplit = host.split(COLON);\n        hostname = hostSplit.shift();\n        port = hostSplit.join(COLON);\n        return {\n            port: port,\n            hostname: hostname,\n            pathname: pathname,\n            search: search,\n            host: host,\n            hash: hash,\n            href: url,\n            protocol: protocol,\n            origin: origin,\n            searchObject: searchObject\n        };\n    },\n    SIXTY = 60,\n    SEVEN = 7,\n    THIRTY = 30,\n    TWENTY_FOUR = 24,\n    ONE_THOUSAND = 1000,\n    THREE_HUNDRED_SIXTY_FIVE = 365,\n    ONE_THOUSAND_SIXTY = ONE_THOUSAND * SIXTY,\n    THREE_HUNDRED_SIXTY_THOUSAND = ONE_THOUSAND_SIXTY * SIXTY,\n    EIGHTY_SIX_MILLION_FOUR_HUNDRED_THOUSAND = THREE_HUNDRED_SIXTY_THOUSAND * TWENTY_FOUR,\n    SIX_HUNDRED_FOUR_MILLION_EIGHT_HUNDRED_THOUSAND = THREE_HUNDRED_SIXTY_THOUSAND * SEVEN,\n    TWO_BILLION_FIVE_HUNDRED_NINETY_TWO_MILLION = THREE_HUNDRED_SIXTY_THOUSAND * THIRTY,\n    THIRTY_ONE_BILLION_FIVE_HUNDRED_THIRTY_SIX_MILLION = THREE_HUNDRED_SIXTY_THOUSAND * THREE_HUNDRED_SIXTY_FIVE,\n    NUMBERS_LENGTH = {\n        ms: 1,\n        secs: ONE_THOUSAND,\n        s: ONE_THOUSAND,\n        mins: ONE_THOUSAND_SIXTY,\n        hrs: THREE_HUNDRED_SIXTY_THOUSAND,\n        days: EIGHTY_SIX_MILLION_FOUR_HUNDRED_THOUSAND,\n        wks: SIX_HUNDRED_FOUR_MILLION_EIGHT_HUNDRED_THOUSAND,\n        mnths: TWO_BILLION_FIVE_HUNDRED_NINETY_TWO_MILLION,\n        yrs: THIRTY_ONE_BILLION_FIVE_HUNDRED_THIRTY_SIX_MILLION\n    },\n    timeUnits = [],\n    timeUnitToNumber = foldl(NUMBERS_LENGTH, function (memo, number, unit) {\n        timeUnits.push(unit);\n        memo[unit] = function (input) {\n            return input * number;\n        };\n        return memo;\n    }, {}),\n    time = cacheable(function (number_) {\n        var number = number_ + EMPTY_STRING,\n            time = 0;\n        if (isString(number)) {\n            number = number.split(',');\n        }\n        duff(number, function (num_) {\n            var num = num_,\n                unit = customUnits(num, timeUnits),\n                number = +(num.split(unit || EMPTY_STRING).join(EMPTY_STRING)),\n                handler = timeUnitToNumber[unit];\n            // there's a handler for this unit, adn it's not NaN\n            if (number === number) {\n                if (handler) {\n                    number = handler(number);\n                }\n                time += number;\n            }\n        });\n        return time;\n    });\n_.exports({\n    // constants\n    customUnits: customUnits,\n    // cache makers\n    cacheable: cacheable,\n    categoricallyCacheable: categoricallyCacheable,\n    // cacheable\n    deprefix: deprefix,\n    deprefixAll: deprefixAll,\n    prefix: prefix,\n    prefixAll: prefixAll,\n    upCase: upCase,\n    unCamelCase: unCamelCase,\n    spinalCase: unCamelCase,\n    camelCase: camelCase,\n    snakeCase: snakeCase,\n    string: string,\n    units: units,\n    baseUnitList: baseUnitList,\n    isHttp: isHttp,\n    parseHash: parseHash,\n    parseURL: parseURL,\n    parseObject: parseObject,\n    time: time,\n    startsWith: startsWith,\n    itemIs: itemIs\n});","application.scope(function (app) {\n    var _ = app._,\n        factories = _.factories,\n        hash = '_directivesHash',\n        returnsNull = returns(NULL);\n    factories.Model.extend('Directive', {\n        directive: function (name) {\n            var that = this,\n                directives = that[hash] = that[hash] || {};\n            return (directives[name] = directives[name] || directiveMod('creation', that, name));\n        },\n        destroy: function () {\n            return this.directivesDestruction();\n        },\n        directivesDestruction: function () {\n            var that = this;\n            return (that[hash] || that) && each(that[hash], function (name) {\n                directiveMod('destruction', that, name);\n            }) && that;\n        },\n        checkDirective: function (key) {\n            var hashed = this[hash];\n            return (!!hashed && hashed[key] != NULL) && hashed[key];\n        }\n    }, BOOLEAN_TRUE);\n    var directives = {\n        creation: {},\n        destruction: {}\n    };\n    app.defineDirective = function (name, creation, destruction_) {\n        var err = (!isString(name) && exception({\n            message: 'directives must be registered with a string for a name'\n        })) || (!isFunction(creation)) && exception({\n            message: 'directives must be registered with both create and destroy functions'\n        });\n        var destruction = isFunction(destruction_) ? destruction_ : returnsNull;\n        directives.creation[name] = directives.creation[name] || creation;\n        directives.destruction[name] = directives.destruction[name] || destruction;\n    };\n    app.extendDirective = function (oldName, newName, handler_, destruction_) {\n        var destruction = destruction_ || returnsThird;\n        var handler = handler_ || returnsThird;\n        return app.defineDirective(newName, function (instance, name, third) {\n            var directive = directives.creation[oldName](instance, name, third);\n            return handler(instance, name, directive);\n        }, function (instance, name, third) {\n            var directive = directives.destruction[oldName](instance, name, third);\n            return destruction(instance, name, directive);\n        });\n    };\n    var returnsThird = function (one, two, three) {\n        return three;\n    };\n    var directiveMod = function (key, instance, name) {\n        return (instance['directive:' + key + ':' + name] || directives[key][name] || noop)(instance, name);\n    };\n    var parody = function (directive, method) {\n        return function (one, two, three) {\n            return this.directive(directive)[method](one, two, three);\n        };\n    };\n    var iterate = function (directive, method) {\n        return function (list) {\n            var dir = this.directive(directive);\n            duff(list, dir[method], dir);\n            return this;\n        };\n    };\n    var parodyCheck = function (directive, method) {\n        return function (one, two, three) {\n            var directiveInstance = this.checkDirective(directive);\n            return directiveInstance && directiveInstance[method](one, two, three);\n        };\n    };\n    _.exports({\n        directives: {\n            parody: parody,\n            parodyCheck: parodyCheck,\n            iterate: iterate\n        }\n    });\n});","application.scope(function (app) {\n    var ITEMS = '_items',\n        BY_ID = '_byId',\n        ID = 'id',\n        eachCall = function (array, method, arg) {\n            return duff(array, function (item) {\n                result(item, method, arg);\n            });\n        },\n        eachCallRight = function (array, method, arg) {\n            return duff(array, function (item) {\n                result(item, method, arg);\n            }, NULL, -1);\n        },\n        eachCallWith = function (array, method, args_) {\n            var args = args_ || [];\n            return duff(array, function (item) {\n                item[method].apply(item, args);\n            });\n        },\n        /**\n         * @func\n         */\n        remove = function (list, item, lookAfter, lookBefore, fromRight) {\n            var index = posit(list, item, lookAfter, lookBefore, fromRight);\n            if (index) {\n                removeAt(list, index - 1);\n            }\n            return !!index;\n        },\n        removeAt = function (list, index) {\n            return splice(list, index, 1)[0];\n        },\n        add = function (list, item, lookAfter, lookBefore, fromRight) {\n            var val = 0,\n                index = posit(list, item, lookAfter, lookBefore, fromRight);\n            if (!index) {\n                val = list.push(item);\n            }\n            return !!val;\n        },\n        addAt = function (list, item, index) {\n            var len = list[LENGTH],\n                lastIdx = len || 0;\n            splice(list, index || 0, 0, item);\n            return len !== list[LENGTH];\n        },\n        eq = function (list, num, caller_) {\n            var n, thisNum, caller = caller_ || noop,\n                items = [],\n                numb = num || 0,\n                isNumberResult = isNumber(numb),\n                isArrayLikeResult = isArrayLike(numb);\n            if (numb < 0) {\n                isNumberResult = !1;\n            }\n            if (!list[LENGTH]) {\n                return items;\n            }\n            if (isNumberResult) {\n                items = [list[numb]];\n                caller(items[0]);\n            } else {\n                if (isArrayLikeResult) {\n                    duff(numb, function (num) {\n                        var item = list[num];\n                        items.push(item);\n                        caller(item);\n                    });\n                } else {\n                    items = [list[0]];\n                    caller(items[0]);\n                }\n            }\n            return items;\n        },\n        range = function (start, stop, step, inclusive) {\n            var length, range, idx;\n            if (stop == NULL) {\n                stop = start || 0;\n                start = 0;\n            }\n            if (!isFinite(start) || !isNumber(start)) {\n                start = 0;\n            }\n            step = +step || 1;\n            length = Math.max(Math.ceil((stop - start) / step), 0) + (+inclusive || 0);\n            range = [];\n            idx = 0;\n            while (idx < length) {\n                range[idx] = start;\n                idx++;\n                start += step;\n            }\n            return range;\n        },\n        count = function (list, runner_, ctx_, start, end) {\n            var runner, obj, idx, ctx = ctx_ || this;\n            if (start < end && isNumber(start) && isNumber(end) && isFinite(start) && isFinite(end)) {\n                end = Math.abs(end);\n                idx = start;\n                runner = bind(runner_, ctx);\n                while (idx < end) {\n                    obj = NULL;\n                    if (has(list, idx)) {\n                        obj = list[idx];\n                    }\n                    runner(obj, idx, list);\n                    idx++;\n                }\n            }\n            return list;\n        },\n        countTo = function (list, runner, ctx, num) {\n            return count(list, runner, ctx, 0, num);\n        },\n        countFrom = function (list, runner, ctx, num) {\n            return count(list, runner, ctx, num, list[LENGTH]);\n        },\n        // array, startIndex, endIndex\n        between = function (fn) {\n            return function (list, startIdx_, endIdx_) {\n                var ret = [],\n                    startIdx = startIdx_ || 0,\n                    endIdx = endIdx_ || list[LENGTH],\n                    findResult = find(list, function (item, idx, list) {\n                        fn(ret, item, idx, list);\n                    }, NULL, endIdx);\n                return ret;\n            };\n        },\n        /**\n         * @func\n         */\n        closest = function (array, searchElement, minIndex_, maxIndex_) {\n            var currentIndex, currentElement, found,\n                minIndex = minIndex_ || 0,\n                maxIndex = maxIndex_ || array[LENGTH] - 1;\n            while (minIndex <= maxIndex) {\n                currentIndex = (minIndex + maxIndex) / 2 | 0;\n                currentElement = array[currentIndex];\n                // calls valueOf\n                if (currentElement < searchElement) {\n                    minIndex = currentIndex + 1;\n                } else if (currentElement > searchElement) {\n                    maxIndex = currentIndex - 1;\n                } else {\n                    return currentIndex;\n                }\n            }\n            found = ~~maxIndex;\n            return found;\n        },\n        // closest = function (list, target) {\n        //     var match, path, diff, possible, i = 0,\n        //         previousAbs = Infinity,\n        //         // trying to avoid running through 20 matchs\n        //         // when i'm already at the exact one\n        //         valuesLen = list[LENGTH];\n        //     if (valuesLen === 1) {\n        //         match = list[0];\n        //     }\n        //     if (indexOf(list, target) !== -1) {\n        //         match = target;\n        //     }\n        //     if (!match) {\n        //         // try doing this later with no sorting\n        //         for (i = valuesLen - 1;\n        //             (i >= 0 && !match); i--) {\n        //             path = list[i];\n        //             diff = Math.abs(target - path);\n        //             if (diff < previousAbs) {\n        //                 possible = path;\n        //                 previousAbs = diff;\n        //             }\n        //         }\n        //         match = possible;\n        //     }\n        //     if (!match) {\n        //         match = target;\n        //     }\n        //     return match;\n        // },\n        /**\n         * @func\n         */\n        posit = function (list, item, lookAfter, lookBefore, fromRight) {\n            return indexOf(list, item, lookAfter, lookBefore, fromRight) + 1;\n        },\n        /**\n         * @func\n         */\n        concat = function () {\n            return foldl(arguments, function (memo, arg) {\n                duff(arg, function (item) {\n                    memo.push(item);\n                });\n                return memo;\n            }, []);\n        },\n        /**\n         * @func\n         */\n        concatUnique = function () {\n            return foldl(arguments, function (memo, argument) {\n                duff(argument, function (item) {\n                    if (binaryIndexOf(memo, item) === -1) {\n                        memo.push(item);\n                    }\n                });\n                return memo;\n            }, []);\n        },\n        cycle = function (arr, num_) {\n            var num, piece, len = arr[LENGTH];\n            if (isNumber(len)) {\n                num = num_ % len;\n                piece = arr.splice(num);\n                arr.unshift.apply(arr, piece);\n            }\n            return arr;\n        },\n        internalMambo = function (fn) {\n            return function (arr) {\n                arr.reverse();\n                fn.apply(this, arguments);\n                arr.reverse();\n                return arr;\n            };\n        },\n        // Returns whether an object has a given set of `key:value` pairs.\n        isMatch = function (object, attrs) {\n            var key, i = 0,\n                keysResult = keys(attrs),\n                obj = Object(object);\n            return !find(keysResult, function (val) {\n                if (attrs[val] !== obj[val] || !(val in obj)) {\n                    return BOOLEAN_TRUE;\n                }\n            });\n        },\n        // Returns a predicate for checking whether an object has a given set of\n        // `key:value` pairs.\n        matches = function (obj1) {\n            return function (obj2) {\n                return isMatch(obj2, obj1);\n            };\n        },\n        uncycle = internalMambo(cycle),\n        externalMambo = internalMambo(function (list, fn) {\n            return fn.apply(this, arguments);\n        }),\n        pluck = function (arr, key) {\n            return map(arr, function (item) {\n                return result(item, key);\n            });\n        },\n        // Convenience version of a common use case of `filter`: selecting only objects\n        // containing specific `key:value` pairs.\n        where = function (obj, attrs) {\n            return filter(obj, matches(attrs));\n        },\n        // Convenience version of a common use case of `find`: getting the first object\n        // containing specific `key:value` pairs.\n        findWhere = function (obj, attrs) {\n            return find(obj, matches(attrs));\n        },\n        // Convenience version of a common use case of `find`: getting the first object\n        // containing specific `key:value` pairs.\n        findLastWhere = function (obj, attrs) {\n            return findLast(obj, matches(attrs));\n        },\n        whereNot = function (obj, attrs) {\n            return filter(obj, negate(matches(attrs)));\n        },\n        splat = function (fn, spliceat) {\n            spliceat = spliceat || 0;\n            return function () {\n                var ctx = this,\n                    arr = toArray(arguments),\n                    args = splice(arr, spliceat);\n                duff(args, function (idx, item, list) {\n                    fn.apply(ctx, arr.concat([idx, item, list]));\n                });\n            };\n        },\n        recreateSelf = function (fn, ctx) {\n            return function () {\n                return new this.__constructor__(fn.apply(ctx || this, arguments));\n            };\n        },\n        /**\n         * @func\n         */\n        filter = function (obj, iteratee, context) {\n            var isArrayResult = isArrayLike(obj),\n                bound = bind(iteratee, context),\n                runCount = 0;\n            return foldl(obj, function (memo, item, key, all) {\n                runCount++;\n                if (bound(item, key, all)) {\n                    if (isArrayResult) {\n                        memo.push(item);\n                    } else {\n                        memo[key] = item;\n                    }\n                }\n                return memo;\n            }, isArrayResult ? [] : {});\n        },\n        unwrapInstance = function (instance_) {\n            return isInstance(instance, factories.Collection) ? instance_ : instance.unwrap();\n        },\n        wrappedCollectionMethods = extend(wrap({\n            each: duff,\n            duff: duff,\n            forEach: duff,\n            eachCall: eachCall,\n            eachRight: duffRight,\n            duffRight: duffRight,\n            forEachRight: duffRight,\n            eachCallRight: eachCallRight\n        }, function (fn) {\n            return function (handler, context) {\n                // unshiftContext\n                var args0 = this.unwrap(),\n                    args1 = handler,\n                    args2 = arguments[LENGTH] > 1 ? context : this;\n                fn(args0, args1, args2);\n                return this;\n            };\n        }), wrap(gapSplit('min max hypot pop shift'), function (name) {\n            return function () {\n                return _[name](this.unwrap());\n            };\n        }), wrap(gapSplit('push unshift'), function (name) {\n            return function () {\n                _[name](this.unwrap(), arguments);\n                return this;\n            };\n        }), wrap(gapSplit('join'), function (name) {\n            return function (arg) {\n                return this.unwrap()[name](arg);\n            };\n        }), wrap(gapSplit('reverse', function (name) {\n            return function () {\n                this.unwrap()[name]();\n                return this;\n            };\n        })), wrap(gapSplit('count countTo countFrom merge eachCallWith'), function (name) {\n            return function (one, two, three) {\n                var ctx = this;\n                _[name](ctx.unwrap(), one, ctx, two, three);\n                return ctx;\n            };\n        }), wrap(gapSplit('foldr foldl reduce find findLast findWhere findLastWhere'), function (name) {\n            return function (fn, ctx, memo) {\n                return _[name](this.unwrap(), fn, ctx, memo);\n            };\n        }), wrap(gapSplit('add addAt remove removeAt indexOf posit foldr foldl reduce'), function (name) {\n            return function (one, two, three) {\n                return _[name](this.unwrap(), one, two, three);\n            };\n        }), wrap(gapSplit('eq map filter pluck where whereNot cycle uncycle flatten'), function (name) {\n            return recreateSelf(function (fn) {\n                return _[name](this.unwrap(), fn);\n            });\n        })),\n        ret = _.exports({\n            eachCall: eachCall,\n            eachCallRight: eachCallRight,\n            eachCallWith: eachCallWith,\n            filter: filter,\n            matches: matches,\n            add: add,\n            addAt: addAt,\n            concatUnique: concatUnique,\n            removeAt: removeAt,\n            remove: remove,\n            cycle: cycle,\n            uncycle: uncycle,\n            mamboWrap: internalMambo,\n            mambo: externalMambo,\n            concat: concat,\n            pluck: pluck,\n            where: where,\n            findWhere: findWhere,\n            findLastWhere: findLastWhere,\n            between: between,\n            posit: posit,\n            range: range,\n            count: count,\n            countTo: countTo,\n            countFrom: countFrom,\n            whereNot: whereNot,\n            eachRight: eachRight,\n            duffRight: duffRight,\n            flatten: flatten,\n            eq: eq\n        }),\n        interactWithById = function (fun, expecting) {\n            return function (one, two, three) {\n                var directive = this,\n                    bycategories = directive.register,\n                    passedCategory = arguments[LENGTH] === expecting,\n                    category = passedCategory ? one : ID,\n                    categoryHash = bycategories[category] = bycategories[category] || {},\n                    key = passedCategory ? two : one,\n                    thing = passedCategory ? three : two;\n                return fun(directive, categoryHash, category, key, thing, passedCategory);\n            };\n        },\n        Collection = factories.Directive.extend('Collection', extend({\n            range: recreateSelf(range),\n            concat: recreateSelf(function () {\n                // this allows us to mix collections with regular arguments\n                var base = this.unwrap();\n                return base.concat.apply(base, map(arguments, function (arg) {\n                    return Collection(arg).unwrap();\n                }));\n            }),\n            has: function (object) {\n                return this.indexOf(object) !== -1;\n            },\n            call: function (arg) {\n                this.each(function (fn) {\n                    fn(arg);\n                });\n                return this;\n            },\n            results: function (key, arg, handle) {\n                this.each(function (obj) {\n                    result(obj, key, arg);\n                });\n                return this;\n            },\n            unwrap: function () {\n                return this.directive('list').items;\n            },\n            empty: _.flow(_.directives.parody('list', 'empty'), _.directives.parody('registry', 'reset')),\n            swap: function (arr) {\n                this.directive('list').items = arr || [];\n            },\n            length: function () {\n                return this.unwrap()[LENGTH];\n            },\n            first: function () {\n                return this.unwrap()[0];\n            },\n            last: function () {\n                return this.unwrap()[this[LENGTH]() - 1];\n            },\n            index: function (number) {\n                return this.unwrap()[number || 0];\n            },\n            sort: function (fn_) {\n                sort(this.unwrap(), fn_);\n                return this;\n            },\n            toString: function () {\n                return stringify(this.unwrap());\n            },\n            toJSON: function () {\n                return map(this.unwrap(), function (item) {\n                    return result(item, TO_JSON);\n                });\n            },\n            /**\n             * @description adds models to the children array\n             * @param {Object|Object[]} objs - object or array of objects to be passed through the model factory and pushed onto the children array\n             * @param {Object} [secondary] - secondary hash that is common among all of the objects being created. The parent property is automatically overwritten as the object that the add method was called on\n             * @returns {Object|Box} the object that was just created, or the object that the method was called on\n             * @name Box#add\n             * @func\n             */\n            constructor: function (arr) {\n                var collection = this;\n                if (isArrayLike(arr)) {\n                    if (!isArray(arr)) {\n                        arr = toArray(arr);\n                    }\n                } else {\n                    if (arr != NULL) {\n                        arr = [arr];\n                    }\n                }\n                collection.swap(arr);\n                return collection;\n            },\n            get: _.directives.parody('registry', 'get'),\n            register: _.directives.parody('registry', 'keep'),\n            unRegister: _.directives.parody('registry', 'drop'),\n            swapRegister: _.directives.parody('registry', 'swap')\n        }, wrappedCollectionMethods), BOOLEAN_TRUE),\n        isNullMessage = {\n            message: 'object must not be null or undefined'\n        },\n        validIdMessage = {\n            message: 'objects in sorted collections must have either a number or string for their valueOf result'\n        },\n        SortedCollection = Collection.extend('SortedCollection', {\n            constructor: function (list_, skip) {\n                var sorted = this;\n                if (list_ && !skip) {\n                    sorted.load(isArrayLike(list_) ? list_ : [list_]);\n                }\n                return sorted;\n            },\n            sort: function () {\n                var sorted = this;\n                sort(sorted.unwrap(), sorted.reversed ? function (a, b) {\n                    return a < b;\n                } : function (a, b) {\n                    return a > b;\n                });\n                return sorted;\n            },\n            reverse: function () {\n                var sorted = this;\n                sorted.reversed = !sorted.reversed;\n                sorted.sort();\n                return sorted;\n            },\n            closest: function (value) {\n                return closest(this.unwrap(), value);\n            },\n            validIDType: function (id) {\n                return isNumber(id) || isString(id);\n            },\n            indexOf: function (object) {\n                return smartIndexOf(this.unwrap(), object);\n            },\n            load: function (values) {\n                var sm = this;\n                duff(values, sm.add, sm);\n                return sm;\n            },\n            add: function (object) {\n                var registryDirective, sorted = this,\n                    isNotNull = object == NULL && exception(isNullMessage),\n                    valueOfResult = object && object.valueOf(),\n                    retrieved = (registryDirective = sorted.checkDirective('registry')) && sorted.get('id', valueOfResult);\n                if (!retrieved) {\n                    ret = !sorted.validIDType(valueOfResult) && exception(validIdMessage);\n                    sorted.addAt(object, sorted.closest(valueOfResult) + 1);\n                    (registryDirective || sorted.directive('registry')).keep('id', valueOfResult, object);\n                    return BOOLEAN_TRUE;\n                }\n            },\n            remove: function (object) {\n                var where, sorted = this,\n                    isNotNull = object == NULL && exception(isNullMessage),\n                    valueOfResult = object && object.valueOf();\n                if (object != NULL && sorted.get('id', valueOfResult) != NULL) {\n                    sorted.removeAt(sorted.indexOf(object));\n                    sorted.unRegister('id', valueOfResult);\n                }\n            },\n            pop: function () {\n                return this.remove(this.last());\n            },\n            shift: function () {\n                return this.remove(this.first());\n            }\n        }, BOOLEAN_TRUE),\n        StringObject = factories.Model.extend('StringObject', {\n            constructor: function (value, parent) {\n                var string = this;\n                string.value = value;\n                string.parent = parent;\n                string.isValid(BOOLEAN_TRUE);\n                return string;\n            },\n            toggle: function (direction) {\n                this.isValid(toggle(this.isValid(), direction));\n            },\n            isValid: function (value) {\n                var string = this;\n                if (arguments[LENGTH]) {\n                    if (string.valid !== value) {\n                        string.parent.increment();\n                        string.valid = value;\n                    }\n                    return string;\n                } else {\n                    return string.valid;\n                }\n            },\n            valueOf: function () {\n                return this.value;\n            },\n            toString: function () {\n                return this.value;\n            },\n            generate: function () {\n                return this.isValid() ? this.valueOf() : EMPTY_STRING;\n            }\n        }, BOOLEAN_TRUE),\n        StringManager = SortedCollection.extend('StringManager', {\n            Child: StringObject,\n            add: function (string) {\n                var sm = this,\n                    found = sm.get('id', string);\n                if (string) {\n                    if (found) {\n                        found.isValid(BOOLEAN_TRUE);\n                    } else {\n                        found = sm.Child(string, sm);\n                        sm.unwrap().push(found);\n                        sm.register('id', string, found);\n                    }\n                }\n                return found;\n            },\n            empty: function () {\n                var sm = this;\n                // wipes array and id hash\n                Collection[CONSTRUCTOR][PROTOTYPE].empty.call(sm);\n                // resets change counter\n                sm.current(EMPTY_STRING);\n            },\n            increment: function () {\n                this._changeCounter++;\n            },\n            decrement: function () {\n                this._changeCounter--;\n            },\n            remove: function (string) {\n                var sm = this,\n                    found = sm.get('id', string);\n                if (string) {\n                    if (found) {\n                        found.isValid(BOOLEAN_FALSE);\n                    }\n                }\n                return sm;\n            },\n            toggle: function (string) {\n                var sm = this,\n                    found = sm.get('id', string);\n                if (!found) {\n                    sm.add(string);\n                } else {\n                    found.toggle();\n                }\n            },\n            generate: function (delimiter_) {\n                var string = EMPTY_STRING,\n                    parent = this,\n                    previousDelimiter = parent.delimiter,\n                    delimiter = delimiter_;\n                if (!this._changeCounter && previousDelimiter === previousDelimiter) {\n                    return this.current();\n                }\n                parent[ITEMS] = parent.foldl(function (memo, stringInstance) {\n                    if (stringInstance.isValid()) {\n                        memo.push(stringInstance);\n                    }\n                    return memo;\n                }, []);\n                string = parent.unwrap().join(delimiter);\n                parent.current(string);\n                return string;\n            },\n            current: function (current_) {\n                var sm = this;\n                if (arguments[LENGTH]) {\n                    sm._changeCounter = 0;\n                    sm._currentValue = current_;\n                    return sm;\n                } else {\n                    return sm._currentValue;\n                }\n            },\n            ensure: function (value_, splitter) {\n                var sm = this,\n                    value = value_,\n                    delimiter = splitter === UNDEFINED ? ' ' : splitter,\n                    isArrayResult = isArray(value),\n                    madeString = (isArrayResult ? value.join(delimiter) : value);\n                if (sm.current() === madeString) {\n                    return sm;\n                }\n                sm.load(isArrayResult ? value : _.split(value, delimiter));\n                sm.current(madeString);\n                return sm;\n            },\n            refill: function (array) {\n                var sm = this;\n                sm.empty();\n                sm.load(array);\n                return sm;\n            }\n        }, BOOLEAN_TRUE),\n        unwrap = function () {\n            return this.items;\n        },\n        list_swap = function (list) {\n            this.items = list;\n        },\n        empty = function () {\n            this.items = [];\n            this.iterating = 0;\n        };\n    app.defineDirective('list', function () {\n        return {\n            items: [],\n            reversed: BOOLEAN_FALSE,\n            iterating: 0,\n            empty: empty\n        };\n    });\n    var get = function (category, id) {\n        var cat = this.register[category];\n        return cat && cat[id];\n    },\n    keep = function (category, id, value) {\n        var register = this.register,\n            cat = register[category] = register[category] || {};\n        cat[id] = value;\n    },\n    drop = function (category, id) {\n        return this.swap(category, id);\n    },\n    swap = function (category, id, value) {\n        var cached = this.get(category, id);\n        this.keep(category, id, value);\n        return cached;\n    },\n    reset = function () {\n        this.register = {};\n        this.count = 0;\n    };\n    app.defineDirective('registry', function () {\n        return {\n            register: {},\n            count: 0,\n            get: get,\n            keep: keep,\n            drop: drop,\n            swap: swap,\n            reset: reset\n        };\n    });\n});","application.scope(function (app) {\n    var request = function (key, arg) {\n            return result(this.hash, key, arg);\n        },\n        reply = function (key, fn) {\n            var hash = this.hash;\n            intendedObject(key, fn, function (key, handler) {\n                hash[key] = bind(isFunction(handler) ? handler : returns(handler), {});\n            });\n        };\n    app.defineDirective('messenger', function () {\n        return {\n            hash: {},\n            reply: reply,\n            request: request\n        };\n    });\n});","var DISPATCH_EVENT = 'dispatchEvent';\nvar _EVENTS = '_events';\nvar EVENTS = 'events';\nvar HANDLERS = 'handlers';\napplication.scope(function (app) {\n    var remove = _.remove,\n        Collection = factories.Collection,\n        SortedCollection = factories.SortedCollection,\n        REMOVE_QUEUE = 'removeQueue',\n        LISTENING_TO = 'listeningTo',\n        TALKER_ID = 'talkerId',\n        REGISTERED = 'registered',\n        LISTENING_PREFIX = 'l',\n        STATE = 'state',\n        IS_STOPPED = 'isStopped',\n        STOP_LISTENING = 'stopListening',\n        IMMEDIATE_PROP_IS_STOPPED = 'immediatePropagationIsStopped',\n        iterateOverObject = function (box, context, events, handler, iterator, firstArg) {\n            // intendedObject(key, value, function (events, handler) {\n            // only accepts a string or a function\n            var fn = isString(handler) ? box[handler] : handler,\n                valid = !isFunction(fn) && exception({\n                    message: 'handler must be a function'\n                });\n            return duff(gapSplit(events), function (eventName) {\n                iterator(box, eventName, {\n                    disabled: BOOLEAN_FALSE,\n                    namespace: eventName.split(COLON)[0],\n                    name: eventName,\n                    handler: fn,\n                    context: context,\n                    origin: box\n                }, firstArg);\n            });\n        },\n        // user friendly version\n        flattenMatrix = function (iterator, _nameOrObjectIndex) {\n            return function (first) {\n                var context, args, nameOrObjectIndex, handlersIndex, list, nameOrObject, box = this;\n                // if no name or no listen target then fail\n                if (!first) {\n                    return box;\n                }\n                args = toArray(arguments);\n                nameOrObjectIndex = _nameOrObjectIndex;\n                handlersIndex = _nameOrObjectIndex;\n                list = args.splice(nameOrObjectIndex);\n                nameOrObject = list[0];\n                context = list[(isObject(nameOrObject) ? 1 : 2)] || box;\n                intendedObject(nameOrObject, list[1], function (events, handlers) {\n                    iterateOverObject(box, context, events, handlers, iterator, args[0]);\n                });\n                return box;\n            };\n        },\n        curriedEquality = function (key, original) {\n            return function (e) {\n                return isEqual(original, e[TARGET].get(key));\n            };\n        },\n        turnOff = function (e) {\n            return e && e[TARGET] && e[TARGET].off && e[TARGET].off();\n        },\n        setupWatcher = function (iterator, nameOrObjectIndex, triggersOnce) {\n            var after = triggersOnce ? turnOff : noop;\n            return function () {\n                var context, list, args, firstArg, handlersIndex, nameOrObject, original_handler, box = this,\n                    ret = {};\n                if (!arguments[0]) {\n                    return ret;\n                }\n                args = toArray(arguments);\n                handlersIndex = nameOrObjectIndex;\n                list = args.splice(nameOrObjectIndex);\n                nameOrObject = list[0];\n                context = args[handlersIndex - 1];\n                if (nameOrObjectIndex && !args[0]) {\n                    return ret;\n                }\n                intendedObject(nameOrObject, list[1], function (key_, value_, isObject_) {\n                    // only allow one to be watched\n                    var key = key_.split(' ')[0],\n                        fun_things = original_handler || bind(list[isObject_ ? 1 : 2], context || box),\n                        value = isFunction(value_) ? value_ : curriedEquality(key, value_),\n                        handler = function (e) {\n                            if (e && value(e)) {\n                                fun_things(e);\n                                after(e);\n                            }\n                        };\n                    original_handler = fun_things;\n                    iterateOverObject(box, context, CHANGE + COLON + key, handler, iterator, args[0]);\n                    ret[key] = handler;\n                });\n                return ret;\n            };\n        },\n        seekAndDestroy = function (box, list, handler, context) {\n            var events = box.directive(EVENTS);\n            list.duffRight(function (obj) {\n                if (obj.disabled || (handler && obj.handler !== handler) || (context && obj.context !== context)) {\n                    return;\n                }\n                events.detach(obj);\n            });\n        },\n        event_incrementer = 1,\n        __FN_ID__ = '__fnid__',\n        returnsId = function () {\n            return this.id;\n        },\n        attachEventObject = function (box, name, eventObject) {\n            box.directive(EVENTS).attach(name, eventObject);\n        },\n        retreiveListeningObject = function (listener, talker) {\n            var listenerDirective = listener.directive(EVENTS),\n                talkerDirective = talker.directive(EVENTS),\n                talkerId = talkerDirective[TALKER_ID],\n                listeningTo = listenerDirective[LISTENING_TO],\n                listening = listeningTo[talkerId];\n            if (listening) {\n                return listening;\n            }\n            // This talkerect is not listening to any other events on `talker` yet.\n            // Setup the necessary references to track the listening callbacks.\n            listenerDirective[TALKER_ID] = listenerDirective[TALKER_ID] || uniqueId(LISTENING_PREFIX);\n            listening = listeningTo[talkerId] = {\n                talker: talker,\n                talkerId: talkerId,\n                id: listenerDirective[TALKER_ID],\n                listeningTo: listeningTo,\n                // context: listener,\n                count: 0\n            };\n            return listening;\n        },\n        DEFAULT_PREVENTED = 'defaultPrevented',\n        ObjectEvent = factories.Directive.extend('ObjectEvent', {\n            constructor: function (name, target, data) {\n                var evnt = this;\n                evnt.bubbles = BOOLEAN_FALSE;\n                evnt.dispatchChildren = BOOLEAN_FALSE;\n                evnt.dispatchTree = BOOLEAN_FALSE;\n                evnt.onMethodName = camelCase('on:' + name, COLON);\n                evnt.propagationIsStopped = evnt[IMMEDIATE_PROP_IS_STOPPED] = BOOLEAN_FALSE;\n                evnt[TARGET] = target;\n                evnt[NAME] = name;\n                evnt[TYPE] = name.split(COLON)[0];\n                evnt.timeStamp = now();\n                evnt.data(data);\n                evnt.isTrusted = BOOLEAN_TRUE;\n                evnt.returnValue = NULL;\n                evnt.namespace = evnt.getNamespace();\n                return evnt;\n            },\n            getNamespace: function () {\n                return this.name;\n            },\n            isStopped: function () {\n                return this.propagationIsStopped || this.immediatePropagationIsStopped;\n            },\n            data: function () {\n                return this[DATA];\n            },\n            get: function (key) {\n                return this[DATA][key];\n            },\n            set: function (key, value) {\n                intendedObject(key, value, matchesOneToOne, this[DATA]);\n                return this;\n            },\n            stopImmediatePropagation: function () {\n                this.stopPropagation();\n                this[IMMEDIATE_PROP_IS_STOPPED] = BOOLEAN_TRUE;\n            },\n            stopPropagation: function () {\n                this.propagationIsStopped = BOOLEAN_TRUE;\n            },\n            preventDefault: function () {\n                this[DEFAULT_PREVENTED] = BOOLEAN_TRUE;\n            },\n            defaultIsPrevented: function () {\n                return this[DEFAULT_PREVENTED];\n            },\n            action: function (fn) {\n                var evnt = this;\n                evnt.directive('actions').push(fn);\n                return evnt;\n            },\n            finished: function () {\n                var actions, evnt = this;\n                evnt.isTrusted = BOOLEAN_FALSE;\n                if (evnt.defaultIsPrevented()) {\n                    return;\n                }\n                if ((actions = evnt.checkDirective('actions'))) {\n                    actions.call(evnt);\n                }\n            }\n        }, BOOLEAN_TRUE),\n        onceHandler = function (box, name, obj) {\n            var fn = obj.fn || obj.handler;\n            obj.fn = once(function (e) {\n                box.off();\n                return fn.apply(this, arguments);\n            });\n            attachEventObject(box, name, obj);\n        },\n        listenToHandler = function (box, name, obj, target) {\n            var valid, targetDirective = target.directive(EVENTS),\n                listeningObject = retreiveListeningObject(box, target),\n                eventsDirective = target.directive(EVENTS),\n                handlers = eventsDirective[HANDLERS] = eventsDirective[HANDLERS] || {};\n            listeningObject.count++;\n            obj.listening = listeningObject;\n            attachEventObject(target, name, obj);\n        },\n        listenToOnceHandler = function (box, name, obj, extra) {\n            bindOnce(box, name, obj);\n            listenToHandler(box, name, obj, extra);\n        },\n        secretOffIterator = function (box, name, obj) {\n            seekAndDestroy(box, !name || box.directive(EVENTS)[HANDLERS][name], obj.handler, obj.context);\n        },\n        Events = factories.Directive.extend('Events', {\n            /**\n             * @description attach event handlers to the Box event loop\n             * @func\n             * @name Box#on\n             * @param {String} str - event name to listen to\n             * @param {Function|String} fn - event handler or string corresponding to handler on prototype to use for handler\n             * @param {Object} context - context that the handler will run in\n             * @returns {Box} instance\n             */\n            uniqueKey: 'c',\n            initialize: noop,\n            constructor: function (opts) {\n                var model = this;\n                extend(model, opts);\n                model[model.uniqueKey + ID] = model[model.uniqueKey + ID] || uniqueId(model.uniqueKey);\n                // reacting to self\n                model.on(model.events);\n                model.initialize(opts);\n                return model;\n            },\n            on: flattenMatrix(attachEventObject, 0),\n            once: flattenMatrix(onceHandler, 0),\n            listenTo: flattenMatrix(listenToHandler, 1),\n            listenToOnce: flattenMatrix(listenToOnceHandler, 1),\n            watch: setupWatcher(attachEventObject, 0),\n            watchOnce: setupWatcher(attachEventObject, 0, 1),\n            watchOther: setupWatcher(listenToHandler, 1),\n            watchOtherOnce: setupWatcher(listenToHandler, 1, 1),\n            /**\n             * @description attaches an event handler to the events object, and takes it off as soon as it runs once\n             * @func\n             * @name Box#once\n             * @param {String} string - event name that will be triggered\n             * @param {Function} fn - event handler that will run only once\n             * @param {Object} context - context that will be applied to the handler\n             * @returns {Box} instance\n             */\n            /**\n             * @description remove event objects from the _events object\n             * @param {String|Function} type - event type or handler. If a match is found, then the event object is removed\n             * @param {Function} handler - event handler to be matched and removed\n             * @func\n             * @name Box#off\n             * @returns {Box} instance\n             */\n            resetEvents: _.directives.parody(EVENTS, 'reset'),\n            off: function (name_, fn_, context_) {\n                var context, currentObj, box = this,\n                    name = name_,\n                    events = box.checkDirective(EVENTS);\n                if (!events) {\n                    return;\n                }\n                context = isObject(name) ? fn_ : context_;\n                if (arguments[LENGTH]) {\n                    if (!name) {\n                        each(events[HANDLERS], function (list, name) {\n                            seekAndDestroy(box, list, fn_, context_);\n                        });\n                    } else {\n                        intendedObject(name, fn_, function (name, fn_) {\n                            iterateOverObject(box, context, name, fn_, secretOffIterator);\n                        });\n                    }\n                } else {\n                    currentObj = events[STACK].last();\n                    if (currentObj) {\n                        events.detach(currentObj);\n                    }\n                }\n                return box;\n            },\n            request: _.directives.parody('messenger', 'request'),\n            reply: _.directives.parody('messenger', 'reply'),\n            when: _.directives.parody('Linguistics', 'when'),\n            // hash this out later\n            stopTalking: function () {},\n            stopListening: function (target, name, callback) {\n                var ids, targetEventsDirective, stillListening = 0,\n                    origin = this,\n                    originEventsDirective = origin.checkDirective(EVENTS),\n                    listeningTo = originEventsDirective[LISTENING_TO],\n                    notTalking = (target && !(targetEventsDirective = target.checkDirective(EVENTS)));\n                if (!originEventsDirective || notTalking) {\n                    return origin;\n                }\n                ids = target ? [targetEventsDirective[TALKER_ID]] : keys(listeningTo);\n                duff(ids, function (id) {\n                    var listening = listeningTo[id];\n                    if (listening) {\n                        listening.talker.off(name, callback);\n                    }\n                    stillListening = listening[id] ? 1 : 0;\n                });\n                if (!stillListening && !find(target ? keys(listeningTo) : ids, function (id, key) {\n                    return listeningTo[id];\n                })) {\n                    originEventsDirective[LISTENING_TO] = {};\n                }\n                return origin;\n            },\n            /**\n             * @description triggers a event loop\n             * @func\n             * @name Box#fire\n             * @param {String} name of the event loop to be triggered\n             * @returns {Box} object instance the method is being called on\n             */\n            createEvent: function (name, data, options) {\n                return ObjectEvent(name, this, data, options);\n            },\n            dispatchEvents: function (names) {\n                var box = this;\n                return duff(gapSplit(names), box.dispatchStack, box) && box;\n            },\n            dispatchStack: function (name) {\n                return this[DISPATCH_EVENT](name);\n            },\n            dispatchEvent: function (name, data, options) {\n                var evnt, eventsDirective, box = this,\n                    has = (eventsDirective = box.checkDirective(EVENTS)) && eventsDirective.has(name);\n                if (has) {\n                    evnt = box.createEvent(name, data, options);\n                    eventsDirective.dispatch(name, evnt);\n                    return evnt.returnValue;\n                }\n            }\n        }, BOOLEAN_TRUE),\n        listeningCounter = 0,\n        attach = function (name, eventObject) {\n            var list, eventsDirective = this,\n                handlers = eventsDirective[HANDLERS],\n                ret = !handlers && exception({\n                    message: 'events directive needs a handler object'\n                });\n            eventObject.id = ++event_incrementer;\n            eventObject.valueOf = returnsId;\n            eventObject.context = eventObject.context || eventObject.origin;\n            eventObject.fn = bind(eventObject.fn || eventObject.handler, eventObject.context);\n            // attach the id to the bound function because that instance is private\n            eventObject.fn[__FN_ID__] = eventObject.id;\n            list = handlers[name] = handlers[name] || SortedCollection(BOOLEAN_TRUE, BOOLEAN_TRUE);\n            // attaching name so list can remove itself from hash\n            list[NAME] = name;\n            // attached so event can remove itself\n            eventObject.list = list;\n            list.add(eventObject);\n        },\n        detach = function (evnt) {\n            var listeningTo, events = this,\n                listening = evnt.listening,\n                list = evnt.list,\n                disabled = evnt.disabled = BOOLEAN_TRUE;\n            if (events[STACK][LENGTH]()) {\n                events[REMOVE_QUEUE].add(evnt);\n                return BOOLEAN_FALSE;\n            } else {\n                list.remove(evnt);\n                // disconnect it from the list above it\n                evnt.list = UNDEFINED;\n                // check to see if it was a listening type\n                if (!listening) {\n                    return BOOLEAN_TRUE;\n                }\n                // if it was then decrement it\n                listening.count--;\n                if (listening.count) {\n                    return BOOLEAN_TRUE;\n                }\n                listeningTo = listening.listeningTo;\n                listeningTo[listening[TALKER_ID]] = UNDEFINED;\n                this.wipe(list);\n                return BOOLEAN_TRUE;\n            }\n        },\n        wipe = function (list) {\n            if (list[LENGTH]()) {\n                return BOOLEAN_FALSE;\n            }\n            this.scrub(list);\n            return BOOLEAN_TRUE;\n        },\n        scrub = function (list) {\n            list.scrubbed = BOOLEAN_TRUE;\n            this[HANDLERS][list[NAME]] = NULL;\n        },\n        reset = function () {\n            return each(this.handlers, this.scrub, this);\n        },\n        queue = function (stack, handler, evnt) {\n            return stack.add(handler);\n        },\n        unQueue = function (stack, handler, evnt) {\n            return stack.pop();\n        },\n        has = function (key) {\n            return this.handlers[key] && this.handlers[key][LENGTH]();\n        },\n        dispatch = function (name, evnt) {\n            var events = this,\n                stack = events[STACK],\n                handlers = events[HANDLERS],\n                list = handlers[name],\n                removeList = events[REMOVE_QUEUE];\n            if (evnt[IMMEDIATE_PROP_IS_STOPPED] || !list || !list[LENGTH]()) {\n                return;\n            }\n            list.find(function (handler) {\n                var cached;\n                if (!handler.disabled && events.queue(stack, handler, evnt)) {\n                    handler.fn(evnt);\n                    cached = evnt[IMMEDIATE_PROP_IS_STOPPED];\n                    events.unQueue(stack, handler, evnt);\n                    return cached;\n                }\n            });\n            if (!stack[LENGTH]() && removeList[LENGTH]()) {\n                removeList.duffRight(events.detach, events);\n                removeList.empty();\n            }\n            evnt.finished();\n        };\n    app.defineDirective(EVENTS, function () {\n        return {\n            listenId: 'l' + (++listeningCounter),\n            handlers: {},\n            listeningTo: {},\n            stack: Collection(),\n            removeQueue: Collection(),\n            attach: attach,\n            detach: detach,\n            has: has,\n            wipe: wipe,\n            scrub: scrub,\n            reset: reset,\n            queue: queue,\n            unQueue: unQueue,\n            dispatch: dispatch\n        };\n    });\n});","application.scope(function (app) {\n    var _ = app._,\n        factories = _.factories,\n        Collection = factories.Collection,\n        SUCCESS = 'success',\n        REGISTERED = 'registered',\n        STATE = 'state',\n        EVERY = 'every',\n        FAILURES = 'failures',\n        COUNTER = 'counter',\n        GROUP_INDEX = 'groupIndex',\n        curriedEquivalence = function (value) {\n            return function (current) {\n                return isEqual(current, value);\n            };\n        },\n        curriedGreaterThan = function (value) {\n            return function (current) {\n                return current > value;\n            };\n        },\n        curriedLessThan = function (value) {\n            return function (current) {\n                return current < value;\n            };\n        },\n        push = function (where) {\n            return function (fn) {\n                var sequencer = this;\n                sequencer[where].push(bind(fn, sequencer));\n                return sequencer;\n            };\n        },\n        addValue = function (constant1, constant2) {\n            return function () {\n                var sequencer = this;\n                duff(arguments, function (value) {\n                    sequencer.add(value, constant1, constant2);\n                });\n                return sequencer;\n            };\n        },\n        isNot = addValue(BOOLEAN_TRUE),\n        makeLogic = function (context, key, handler, negate) {\n            var bound = bind(handler, context),\n                negative_bound = negate ? _.negate(bound) : bound;\n            return {\n                key: key,\n                context: context,\n                handler: handler,\n                fn: negative_bound\n            };\n        },\n        Linguistics = factories.Events.extend('Linguistics', {\n            then: push(SUCCESS),\n            always: push(EVERY),\n            otherwise: push(FAILURES),\n            constructor: function (origin) {\n                var sequencer = this;\n                sequencer.origin = origin;\n                sequencer[COUNTER] = 0;\n                sequencer[GROUP_INDEX] = -1;\n                sequencer[REGISTERED] = {};\n                sequencer.logic = Collection();\n                sequencer[SUCCESS] = Collection();\n                sequencer[FAILURES] = Collection();\n                sequencer[EVERY] = Collection();\n                sequencer.group();\n                sequencer.listenTo(sequencer.origin, {\n                    change: sequencer.apply,\n                    destroy: sequencer.stopListening\n                });\n                return this;\n            },\n            when: function (key) {\n                this[CURRENT] = key;\n                this.and(key);\n                return this;\n            },\n            and: function (key) {\n                var sequencer = this;\n                sequencer[CURRENT] = key;\n                sequencer.bind(key);\n                return sequencer;\n            },\n            or: function (key) {\n                this.group();\n                this.and(key);\n                return this;\n            },\n            group: function () {\n                var sequencer = this;\n                ++sequencer[GROUP_INDEX];\n                sequencer.logic.push({\n                    index: sequencer[GROUP_INDEX],\n                    list: Collection()\n                });\n                return sequencer;\n            },\n            increment: function () {\n                ++this[COUNTER];\n            },\n            bind: function (target) {\n                var sequencer = this,\n                    registered = sequencer[REGISTERED];\n                if (!registered[target]) {\n                    registered[target] = BOOLEAN_TRUE;\n                    this.listenTo(this.origin, CHANGE_COLON + target, sequencer.increment);\n                }\n            },\n            unbind: function (target) {\n                var sequencer = this,\n                    registered = sequencer[REGISTERED];\n                if (registered[target]) {\n                    registered[target] = BOOLEAN_FALSE;\n                    this[STOP_LISTENING](this.origin, CHANGE_COLON + target, sequencer.increment);\n                }\n            },\n            is: addValue(),\n            isnt: isNot,\n            isNot: isNot,\n            isGreaterThan: addValue(BOOLEAN_FALSE, curriedGreaterThan),\n            isLessThan: addValue(BOOLEAN_FALSE, curriedLessThan),\n            isNotGreaterThan: addValue(BOOLEAN_TRUE, curriedGreaterThan),\n            isNotLessThan: addValue(BOOLEAN_TRUE, curriedLessThan),\n            value: function (value, defaultFn) {\n                return isFunction(value) ? value : defaultFn(value);\n            },\n            add: function (value_, negate, defaultFn) {\n                var object, sequencer = this;\n                var current = sequencer[CURRENT];\n                var value = sequencer.value(value_, defaultFn || curriedEquivalence);\n                var made = makeLogic(sequencer, current, value, negate);\n                sequencer.logic.index(sequencer[GROUP_INDEX]).list.push(made);\n                return sequencer;\n            },\n            check: function () {\n                var sequencer = this;\n                return !!(sequencer[COUNTER] && sequencer.logic.find(function (group) {\n                    return !group.list.find(function (item) {\n                        return !item.fn(sequencer.origin.get(item.key));\n                    });\n                }));\n            },\n            restart: function () {\n                this[COUNTER] = 0;\n                return this;\n            },\n            handle: function (key, arg) {\n                var sequencer = this;\n                var ret = sequencer[key] && sequencer[key].call(arg);\n                return sequencer;\n            },\n            run: function () {\n                var sequencer = this;\n                if (sequencer[STATE]) {\n                    sequencer.handle(SUCCESS);\n                } else {\n                    sequencer.handle(FAILURES);\n                }\n                sequencer.handle(EVERY);\n            },\n            apply: function () {\n                var sequencer = this,\n                    checked = sequencer.check();\n                sequencer.restart();\n                if (sequencer[STATE] !== checked) {\n                    sequencer[STATE] = checked;\n                    sequencer.run();\n                }\n                return sequencer;\n            }\n        }, BOOLEAN_TRUE),\n        LinguisticsManager = Collection.extend('LinguisticsManager', {\n            when: function (key) {\n                var listDirective = this.directive('children');\n                var newish = new Linguistics[CONSTRUCTOR](this.target);\n                listDirective.push(newish);\n                return newish.when(key);\n            },\n            constructor: function (target) {\n                // save it for later\n                this.target = target;\n                return this;\n            }\n        }, BOOLEAN_TRUE);\n    app.defineDirective('Linguistics', function (target) {\n        return new LinguisticsManager[CONSTRUCTOR](target);\n    });\n});","application.scope(function (app) {\n    var Collection = factories.Collection,\n        Events = factories.Events,\n        ID = 'id',\n        SORT = 'sort',\n        ADDED = 'added',\n        UNWRAP = 'unwrap',\n        REMOVED = 'removed',\n        CURRENT = 'current',\n        // _COUNTER = '_counter',\n        DESTROY = 'destroy',\n        BEFORE_DESTROY = BEFORE_COLON + DESTROY,\n        INTERNAL_EVENTS = '_events',\n        STOP_LISTENING = 'stopListening',\n        EVENT_REMOVE = '_removeEventList',\n        _DELEGATED_CHILD_EVENTS = '_delegatedParentEvents',\n        _PARENT_DELEGATED_CHILD_EVENTS = '_parentDelgatedChildEvents',\n        CHANGE_COUNTER = 'counter',\n        PREVIOUS = 'previous',\n        /**\n         * @class Box\n         * @description event and attribute extensor object that creates the Box Constructor and convenience method at _.Box\n         * @augments Model\n         */\n        Container = factories.Events.extend('Container', {\n            // this id prefix is nonsense\n            // define the actual key\n            idAttribute: ID,\n            comparator: ID,\n            constructor: function (attributes, secondary) {\n                var model = this;\n                model.reset(attributes);\n                Events[CONSTRUCTOR].call(this, secondary);\n                return model;\n            },\n            reset: function (data_) {\n                var childModel, children, model = this,\n                    dataDirective = model.directive(DATA),\n                    current = dataDirective[CURRENT],\n                    // automatically checks to see if the data is a string\n                    passed = parse(data_) || {},\n                    // build new data\n                    newAttributes = extend(result(model, 'defaults', passed), passed),\n                    // try to get the id from the attributes\n                    idAttributeResult = result(model, 'idAttribute', newAttributes),\n                    discoveredId = model.id || newAttributes[idAttributeResult] || uniqueId(BOOLEAN_FALSE, BOOLEAN_TRUE);\n                // set the id of the object\n                model._setId(discoveredId);\n                // set id and let parent know what your new id is\n                model[DISPATCH_EVENT](BEFORE_COLON + RESET);\n                // setup previous data\n                dataDirective.reset(newAttributes);\n                dataDirective[PREVIOUS] = {};\n                // let everything know that it is changing\n                model[DISPATCH_EVENT](RESET);\n            },\n            /**\n             * @description remove attributes from the Box object. Does not completely remove from object with delete, but instead simply sets it to UNDEFINED / undefined\n             * @param {String} attr - property string that is on the attributes object\n             * @returns {Box} instance the method was called on\n             * @func\n             * @name Box#unset\n             */\n            unset: _.directives.parodyCheck(DATA, 'unset'),\n            /**\n             * @description returns attribute passed into\n             * @param {String} attr - property string that is being gotten from the attributes object\n             * @returns {*} valuethat is present on the attributes object\n             * @func\n             * @name Box#get\n             */\n            get: _.directives.parodyCheck(DATA, 'get'),\n            /**\n             * @func\n             * @param {String} attr - property string that is being gotten from the attributes object\n             * @returns {Boolean} evaluation of whether or not the Box instance has a value at that attribute key\n             * @description checks to see if the current attribute is on the attributes object as anything other an undefined\n             * @name Box#has\n             */\n            has: _.directives.parodyCheck(DATA, 'has'),\n            /**\n             * @description collects a splat of arguments and condenses them into a single object. Object is then extended onto the attributes object and any items that are different will be fired as events\n             * @param {...*} series - takes a series of key value pairs. can be mixed with objects. All key value pairs will be placed on a new object, which is to be passed into the function below\n             * @func\n             * @name Box#set\n             * @returns {Box} instance\n             */\n            destroy: function () {\n                var removeRet, box = this;\n                // notify things like parent that it's about to destroy itself\n                box[DISPATCH_EVENT](BEFORE_DESTROY);\n                // actually detach\n                removeRet = box[PARENT] && box[PARENT].remove(box);\n                // stop listening to other views\n                box[DISPATCH_EVENT](DESTROY);\n                // stops listening to everything\n                box[STOP_LISTENING]();\n                return box;\n            },\n            set: function (key, value) {\n                var changedList = [],\n                    model = this,\n                    dataDirective = model.directive(DATA),\n                    current = dataDirective[CURRENT] = dataDirective[CURRENT] || {},\n                    previous = dataDirective[PREVIOUS] = dataDirective[PREVIOUS] || {},\n                    compiled = {};\n                intendedObject(key, value, function (key, value) {\n                    if (dataDirective.set(key, value) && !dataDirective.changing[name]) {\n                        changedList.push(key);\n                        compiled[key] = value;\n                    }\n                });\n                // do not digest... this time\n                if (!changedList[LENGTH]) {\n                    return model;\n                }\n                // list\n                dataDirective.digest(model, function () {\n                    duff(changedList, function (name) {\n                        dataDirective.changing[name] = BOOLEAN_TRUE;\n                        model[DISPATCH_EVENT](CHANGE_COLON + name);\n                        dataDirective.changing[name] = BOOLEAN_FALSE;\n                    });\n                });\n                return model;\n            },\n            setDeep: function (where, value) {\n                var former, lastkey, model = this,\n                    dataDirective = model.directive(DATA),\n                    triggers = [],\n                    path = toArray(where, PERIOD);\n                if (!dataDirective.setDeep(path, value)) {\n                    return model;\n                }\n                dataDirective.digest(model, function () {\n                    duffRev(path, function (item) {\n                        var name = path.join(PERIOD);\n                        dataDirective.changing[name] = BOOLEAN_TRUE;\n                        model[DISPATCH_EVENT](CHANGE_COLON + name);\n                        dataDirective.changing[name] = BOOLEAN_FALSE;\n                        path.pop();\n                    });\n                });\n                return model;\n            },\n            /**\n             * @description basic json clone of the attributes object\n             * @func\n             * @name Box#toJSON\n             * @returns {Object} json clone of the attributes object\n             */\n            toJSON: function () {\n                // does not prevent circular dependencies.\n                // swap this out for something else if you want\n                // to prevent circular dependencies\n                return clone(this.directive(DATA)[CURRENT]);\n            },\n            current: function () {\n                return clone(this.directive(DATA)[CURRENT]);\n            },\n            valueOf: function () {\n                return this.id;\n            },\n            /**\n             * @description stringified version of attributes object\n             * @func\n             * @name Box#stringify\n             * @returns {String} stringified json version of\n             */\n            toString: function () {\n                return stringify(this);\n            },\n            _setId: function (id_) {\n                var model = this,\n                    id = id_ === UNDEFINED ? uniqueId(BOOLEAN_FALSE) : id_;\n                model.id = id;\n            }\n        }, BOOLEAN_TRUE),\n        modelMaker = function (attributes, options) {\n            return Box(attributes, options);\n        },\n        Box = factories.Container.extend('Box', {\n            Child: modelMaker,\n            /**\n             * @description resets the box's attributes to the object that is passed in\n             * @name Box#reset\n             * @func\n             * @param {Object} attributes - non circular hash that is extended onto what the defaults object produces\n             * @returns {Box} instance the method was called on\n             */\n            resetChildren: function (newChildren) {\n                var length, child, box = this,\n                    children = box.directive(CHILDREN),\n                    arr = children[UNWRAP]();\n                // this can be made far more efficient\n                while (arr[LENGTH]) {\n                    child = arr[0];\n                    length = arr[LENGTH];\n                    if (child) {\n                        result(child, DESTROY);\n                    }\n                    // if it didn't remove itself,\n                    // then you should remove it here\n                    // this gets run if the child is a basic data type\n                    if (arr[0] === child && arr[LENGTH] === length) {\n                        remove(arr, child);\n                    }\n                }\n                box.add(newChildren);\n                return box;\n            },\n            // registers and actually adds child to hash\n            _addToHash: function (newModel, where) {\n                var parent = this,\n                    children = this.directive(CHILDREN);\n                // add to collection\n                children.add(newModel);\n                // register with parent\n                children.register(ID, newModel.id, newModel);\n                children.register(newModel.uniqueKey + ID, newModel[newModel.uniqueKey + ID], newModel);\n            },\n            // ties child events to new child\n            _delegateChildEvents: function (model) {\n                var parent = this,\n                    childEvents = _.result(parent, CHILD + 'Events');\n                if (model && childEvents) {\n                    model[_PARENT_DELEGATED_CHILD_EVENTS] = childEvents;\n                    parent.listenTo(model, childEvents);\n                }\n            },\n            // ties child events to new child\n            _unDelegateChildEvents: function (model) {\n                if (model && model[_PARENT_DELEGATED_CHILD_EVENTS] && this[STOP_LISTENING]) {\n                    this[STOP_LISTENING](model, model[_PARENT_DELEGATED_CHILD_EVENTS]);\n                }\n            },\n            _delegateParentEvents: function (model) {\n                var parent = model[PARENT],\n                    parentEvents = _.result(model, 'parentEvents');\n                if (parent && parentEvents) {\n                    model[_DELEGATED_CHILD_EVENTS] = parentEvents;\n                    model.listenTo(parent, parentEvents);\n                }\n            },\n            // ties child events to new child\n            _unDelegateParentEvents: function (model) {\n                var parent = this;\n                if (model[STOP_LISTENING] && model[_DELEGATED_CHILD_EVENTS]) {\n                    model[STOP_LISTENING](parent, model[_DELEGATED_CHILD_EVENTS]);\n                }\n            },\n            _isChildType: function (child) {\n                return isInstance(child, this.Child);\n            },\n            // this one forcefully adds\n            _add: function (model) {\n                var parent = this,\n                    children = parent.directive(CHILDREN),\n                    evt = model[DISPATCH_EVENT] && model[DISPATCH_EVENT](BEFORE_COLON + ADDED);\n                // let the child know it's about to be added\n                // (tied to it's parent via events)\n                // unties boxes\n                parent._remove(model);\n                // explicitly tie to parent\n                model[PARENT] = parent;\n                // attach events from parent\n                parent._addToHash(model);\n                // ties boxes together\n                parent._delegateParentEvents(model);\n                parent._delegateChildEvents(model);\n                evt = model[DISPATCH_EVENT] && model[DISPATCH_EVENT](ADDED);\n                // notify that you were added\n                return model;\n            },\n            // public facing version filters\n            add: function (objs_, secondary_) {\n                var childAdded, parent = this,\n                    children = parent.directive(CHILDREN),\n                    secondary = extend(result(parent, CHILD + 'Options'), secondary_ || {}),\n                    list = Collection(objs_);\n                // unwrap it if you were passed a collection\n                if (!parent.Child || !list[LENGTH]()) {\n                    return list[UNWRAP]();\n                }\n                list = list.foldl(function (memo, obj) {\n                    var isChildType = parent._isChildType(obj),\n                        // create a new model\n                        // call it with new in case they use a constructor\n                        newModel = isChildType ? obj : new parent.Child(obj, secondary),\n                        // find by the newly created's id\n                        foundModel = children.get(newModel.id);\n                    if (foundModel) {\n                        // update the old\n                        foundModel.set(obj);\n                        newModel = foundModel;\n                    } else {\n                        // add the new\n                        childAdded = BOOLEAN_TRUE;\n                        parent._add(newModel);\n                    }\n                    memo.push(newModel);\n                    return memo;\n                }, []);\n                if (childAdded) {\n                    parent[DISPATCH_EVENT](CHILD + COLON + ADDED);\n                }\n                return list;\n            },\n            _removeFromHash: function (child) {\n                var parent = this,\n                    children = parent.directive(CHILDREN);\n                if (!children || !child) {\n                    return;\n                }\n                // remove the child from the children hash\n                children.remove(child);\n                parent.directive(CHILDREN).unRegister(ID, child.id);\n                // unregister from the child hash keys\n                parent.directive(CHILDREN).unRegister(child.uniqueKey + ID, child[child.uniqueKey + ID]);\n            },\n            _remove: function (model) {\n                // cache the parent\n                var parent = this;\n                // let everyone know that this object is about to be removed\n                model[DISPATCH_EVENT](BEFORE_COLON + REMOVED);\n                // notify the child that the remove pipeline is starting\n                // remove the parent events\n                parent._unDelegateParentEvents(model);\n                // have parent remove it's child events\n                parent._unDelegateChildEvents(model);\n                // attach events from parent\n                parent._removeFromHash(model);\n                // void out the parent member tied directly to the model\n                model[PARENT] = UNDEFINED;\n                // let everyone know that you've offically separated\n                model[DISPATCH_EVENT](REMOVED);\n                // notify the child that the remove pipeline is done\n                return model;\n            },\n            remove: function (idModel_) {\n                var parent = this,\n                    children = parent.directive(CHILDREN),\n                    retList = Collection(),\n                    args = toArray(arguments).splice(1),\n                    idModel = idModel_;\n                if (!isObject(idModel)) {\n                    // it's a string\n                    idModel = parent.directive(CHILDREN).get(ID, idModel + EMPTY_STRING);\n                }\n                if (!idModel || !isObject(idModel)) {\n                    return retList;\n                }\n                Collection(idModel && idModel.unwrap ? idModel.unwrap() : idModel).duff(function (model) {\n                    var parent = model[PARENT];\n                    parent._remove(model);\n                    retList.add(model);\n                });\n                if (retList[LENGTH]()) {\n                    parent[DISPATCH_EVENT](CHILD + COLON + REMOVED);\n                }\n                return retList;\n            },\n            /**\n             * @description removes pointers from parent\n             * @func\n             * @name Box#destroy\n             * @returns {Box} instance\n             */\n            _destroy: function () {\n                var box = this,\n                    // removes all parent / parent's child listeners\n                    removeRet = box[PARENT] && box[PARENT].remove(box);\n                // destroys it's children\n                box.resetChildren();\n            },\n            /**\n             * @description basic sort function\n             * @param {Function|String} comparator - argument to sort children against\n             * @returns {Box} instance\n             * @func\n             * @name Box#sort\n             */\n            sort: function (comparator_) {\n                var comparatorString, isReversed, model = this,\n                    children = model.directive(CHILDREN),\n                    comparator = comparator_ || result(model, 'comparator');\n                if (isString(comparator)) {\n                    isReversed = comparator[0] === '!';\n                    comparatorString = comparator;\n                    if (isReversed) {\n                        comparatorString = comparator.slice(1);\n                    }\n                    comparator = function (a, b) {\n                        var val_, val_A = a.get(comparatorString),\n                            val_B = b.get(comparatorString);\n                        if (isReversed) {\n                            val_ = val_B - val_A;\n                        } else {\n                            val_ = val_A - val_B;\n                        }\n                        return val_;\n                    };\n                }\n                model[DISPATCH_EVENT](BEFORE_COLON + SORT, model);\n                children[SORT](comparator);\n                model[DISPATCH_EVENT](SORT, model);\n                return model;\n            }\n        }, BOOLEAN_TRUE),\n        set = function (key, newValue) {\n            var dataDirective = this,\n                current = dataDirective[CURRENT],\n                oldValue = current[key];\n            if (!isEqual(oldValue, newValue)) {\n                current[key] = newValue;\n                return BOOLEAN_TRUE;\n            }\n            return BOOLEAN_FALSE;\n        },\n        get = function (key) {\n            return this[CURRENT][key];\n        },\n        unset = function (key) {\n            this[CURRENT][key] = UNDEFINED;\n        },\n        reset = function (hash) {\n            this[CURRENT] = hash;\n            // this.counter = 0;\n        },\n        setDeep = function (path, value) {\n            var previous, dataDirective = this,\n                current = dataDirective[CURRENT];\n            duff(path, function (key, index) {\n                var no_more = index === path[LENGTH] - 1;\n                previous = current;\n                current = no_more ? current[key] : isObject(current[key]) ? current[key] : (previous[key] = {});\n            });\n            if (previous && !isEqual(current, value)) {\n                previous[key] = value;\n                return BOOLEAN_TRUE;\n            }\n        },\n        digest = function (model, fn) {\n            var dataDirective = this;\n            dataDirective[CHANGE_COUNTER]++;\n            fn();\n            dataDirective[CHANGE_COUNTER]--;\n            // this event should only ever exist here\n            if (!dataDirective[CHANGE_COUNTER]) {\n                model[DISPATCH_EVENT](CHANGE, dataDirective[PREVIOUS]);\n                dataDirective[PREVIOUS] = {};\n                dataDirective.changing = {};\n            }\n        },\n        has = function (key) {\n            return this.current[key] != NULL;\n        };\n    app.defineDirective('data', function () {\n        return {\n            current: {},\n            changing: {},\n            counter: 0,\n            set: set,\n            get: get,\n            has: has,\n            unset: unset,\n            reset: reset,\n            digest: digest\n        };\n    });\n    app.defineDirective('children', function () {\n        return Collection();\n    });\n    modelMaker[CONSTRUCTOR] = Box[CONSTRUCTOR];\n});","application.scope(function (app) {\n    var blank, _ = app._,\n        factories = _.factories,\n        Box = factories.Box,\n        Collection = factories.Collection,\n        isFunction = _.isFunction,\n        extend = _.extend,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        PARENT = 'parent',\n        STOP = 'stop',\n        START = 'start',\n        _EXTRA_MODULE_ARGS = '_extraModuleArguments',\n        startableMethods = {\n            start: function (evnt) {\n                var startable = this;\n                if (!startable.started) {\n                    startable.dispatchEvent('before:' + START, evnt);\n                    startable.started = BOOLEAN_TRUE;\n                    startable.dispatchEvent(START, evnt);\n                }\n                return startable;\n            },\n            stop: function (evnt) {\n                var startable = this;\n                if (startable.started) {\n                    startable.dispatchEvent('before:' + STOP, evnt);\n                    startable.started = BOOLEAN_FALSE;\n                    startable.dispatchEvent(STOP, evnt);\n                }\n                return startable;\n            },\n            toggle: function () {\n                var startable = this;\n                if (startable.started) {\n                    startable[STOP](evnt);\n                } else {\n                    startable[START](evnt);\n                }\n                return startable;\n            }\n        },\n        Startable = factories.Box.extend('Startable', startableMethods, BOOLEAN_TRUE),\n        doStart = function (e) {\n            if (this.get('startWithParent')) {\n                this[START](e);\n            }\n        },\n        doStop = function (e) {\n            if (this.get('stopWithParent')) {\n                this[STOP](e);\n            }\n        },\n        // moduleHandler = ,\n        // moduleRunner = ,\n        moduleMethods = extend({}, startableMethods, {\n            // idAttribute: 'name',\n            module: function (name_, fn) {\n                var modules, attrs, parentIsModule, nametree, parent = this,\n                    originalParent = parent,\n                    name = name_,\n                    globalname = name,\n                    namespace = name.split(PERIOD),\n                    parentModulesDirective = parent.directive('modules'),\n                    module = parentModulesDirective.get(name_);\n                while (namespace.length > 1) {\n                    parent = parent.module(namespace[0]);\n                    namespace.shift();\n                }\n                name = namespace.join(PERIOD);\n                module = parentModulesDirective.get(name);\n                if (!module) {\n                    parentIsModule = _.isInstance(parent, Module);\n                    if (parentIsModule) {\n                        namespace.unshift(globalname);\n                    }\n                    namespace = namespace.join(PERIOD);\n                    module = Module({\n                        id: name,\n                        globalname: namespace\n                    }, {\n                        application: app,\n                        parent: parent\n                    });\n                    if (module.topLevel()) {\n                        parentModulesDirective.add(module);\n                    } else {\n                        parent.add(module);\n                    }\n                    parentModulesDirective.register(name, module);\n                    app.directive('modules').register(globalname, module);\n                }\n                if (!module.hasInitialized && isFunction(fn)) {\n                    module.hasInitialized = BOOLEAN_TRUE;\n                    module.handler(fn);\n                }\n                return module;\n            },\n            run: function (fn) {\n                var module = this;\n                fn.apply(module, module.createArguments());\n                return module;\n            },\n            parentEvents: function () {\n                return {\n                    start: doStart,\n                    stop: doStop\n                };\n            },\n            exports: function (obj) {\n                extend(BOOLEAN_TRUE, this.get('exports'), obj);\n                return this;\n            },\n            createArguments: function () {\n                return [this].concat(this.application.createArguments());\n            },\n            constructor: function (attrs, opts) {\n                var module = this;\n                module.application = opts.application;\n                module.handlers = Collection();\n                // module.modules = Collection();\n                Box.constructor.apply(this, arguments);\n                return module;\n            },\n            defaults: function () {\n                return {\n                    startWithParent: BOOLEAN_TRUE,\n                    stopWithParent: BOOLEAN_TRUE,\n                    exports: {}\n                };\n            },\n            topLevel: function () {\n                return this.application === this[PARENT];\n            },\n            childOptions: function () {\n                return {\n                    application: this.application,\n                    parent: this\n                };\n            },\n            handler: function (fn) {\n                var module = this;\n                module.handlers.push(fn);\n                module.run(fn);\n                return module;\n            }\n        }),\n        Module = factories.Box.extend('Module', moduleMethods, BOOLEAN_TRUE),\n        appextendresult = app.extend(extend({}, factories.Events.constructor.prototype, moduleMethods, {\n            _extraModuleArguments: [],\n            /**\n             * @func\n             * @name Specless#baseModuleArguments\n             * @returns {Array} list of base arguments to apply to submodules\n             */\n            baseModuleArguments: function () {\n                var app = this;\n                return [app, app._, app._ && app._.factories];\n            },\n            /**\n             * @func\n             * @name Specless#addModuleArguments\n             * @param {Array} arr - list of arguments that will be added to the extraModule args list\n             * @returns {Specless} instance\n             */\n            addModuleArguments: function (arr) {\n                var app = this;\n                app._.duff(arr, function (item) {\n                    app._.add(app[_EXTRA_MODULE_ARGS], item);\n                });\n                return app;\n            },\n            /**\n             * @func\n             * @name Specless#removeModuleArguments\n             * @param {Array} arr - list of objects or functions that will be removed from the extraModuleArgs\n             * @returns {Specless} instance\n             */\n            removeModuleArguments: function (arr) {\n                var app = this;\n                app._.duff(arr, function (item) {\n                    app._.remove(app[_EXTRA_MODULE_ARGS], item);\n                });\n                return app;\n            },\n            /**\n             * @func\n             * @name Specless#createArguments\n             * @returns {Object[]}\n             */\n            createArguments: function () {\n                return this.baseModuleArguments().concat(this[_EXTRA_MODULE_ARGS]);\n            },\n            require: function (modulename) {\n                var module = this.module(modulename);\n                return module.getExports();\n            }\n        }));\n    app.defineDirective('modules', function () {\n        return Collection();\n    });\n});","application.scope().module('Looper', function (module, app, _, factories) {\n    var blank, x = 0,\n        lastTime = 0,\n        LENGTH = 'length',\n        isFunction = _.isFunction,\n        isNumber = _.isNumber,\n        pI = _.pI,\n        posit = _.posit,\n        nowish = _.now,\n        gapSplit = _.gapSplit,\n        vendors = gapSplit('ms moz webkit o'),\n        REQUEST_ANIMATION_FRAME = 'requestAnimationFrame',\n        allLoopers = [],\n        runningLoopers = [],\n        bind = _.bind,\n        duff = _.duff,\n        remove = _.remove,\n        removeAll = _.removeAll,\n        duffRev = _.duffRight,\n        extend = _.extend,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        running = BOOLEAN_FALSE,\n        setup = function () {\n            running = BOOLEAN_TRUE;\n            win[REQUEST_ANIMATION_FRAME](function (time) {\n                duff(runningLoopers, function (looper) {\n                    looper.run(time);\n                });\n                teardown();\n            });\n        },\n        teardown = function () {\n            duffRight(runningLoopers, function (looper, idx) {\n                if (looper.halted() || looper.stopped() || looper.destroyed() || !looper.length()) {\n                    runningLoopers.splice(idx, 1);\n                }\n            });\n            running = BOOLEAN_FALSE;\n            if (runningLoopers[LENGTH]) {\n                setup();\n            }\n        },\n        add = function (looper) {\n            allLoopers.push(looper);\n        },\n        start = function (looper) {\n            if (!posit(runningLoopers, looper)) {\n                runningLoopers.push(looper);\n            }\n            if (!running) {\n                setup();\n            }\n        },\n        shim = (function () {\n            for (; x < vendors[LENGTH] && !win[REQUEST_ANIMATION_FRAME]; ++x) {\n                win[REQUEST_ANIMATION_FRAME] = win[vendors[x] + 'RequestAnimationFrame'];\n                win.cancelAnimationFrame = win[vendors[x] + 'CancelAnimationFrame'] || win[vendors[x] + 'CancelRequestAnimationFrame'];\n            }\n            if (!win[REQUEST_ANIMATION_FRAME]) {\n                win[REQUEST_ANIMATION_FRAME] = function (callback) {\n                    var currTime = new Date().getTime(),\n                        timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n                        id = win.setTimeout(function () {\n                            callback(currTime + timeToCall);\n                        }, timeToCall);\n                    lastTime = currTime + timeToCall;\n                    return id;\n                };\n            }\n            if (!win.cancelAnimationFrame) {\n                win.cancelAnimationFrame = function (id) {\n                    win.clearTimeout(id);\n                };\n            }\n        }()),\n        Looper = factories.Directive.extend('Looper', {\n            constructor: function (_runner) {\n                var fns, stopped = BOOLEAN_FALSE,\n                    halted = BOOLEAN_FALSE,\n                    destroyed = BOOLEAN_FALSE,\n                    running = BOOLEAN_FALSE,\n                    looper = this,\n                    counter = 0,\n                    fnList = [],\n                    addList = [],\n                    removeList = [],\n                    combineAdd = function () {\n                        if (addList[LENGTH]) {\n                            fnList = fnList.concat(addList);\n                            addList = [];\n                        }\n                    };\n                extend(looper, {\n                    length: function () {\n                        return fnList[LENGTH];\n                    },\n                    destroy: function () {\n                        destroyed = BOOLEAN_TRUE;\n                        remove(allLoopers, this);\n                        return this.halt();\n                    },\n                    destroyed: function () {\n                        return destroyed;\n                    },\n                    running: function () {\n                        return !!running;\n                    },\n                    run: function () {\n                        var tween = this,\n                            removeLater = [],\n                            _nowish = nowish();\n                        if (halted || stopped) {\n                            return;\n                        }\n                        combineAdd();\n                        duff(fnList, function (fnObj) {\n                            if (!posit(removeList, fnObj)) {\n                                if (!fnObj.disabled && !halted) {\n                                    running = fnObj;\n                                    fnObj.fn(_nowish);\n                                }\n                            } else {\n                                removeLater.push(fnObj);\n                            }\n                        });\n                        running = BOOLEAN_FALSE;\n                        combineAdd();\n                        removeAll(fnList, removeList.concat(removeLater));\n                        removeList = [];\n                    },\n                    remove: function (id) {\n                        var ret, fnObj, i = 0;\n                        if (!arguments[LENGTH]) {\n                            if (running) {\n                                id = running.id;\n                            }\n                        }\n                        if (isNumber(id)) {\n                            for (; i < fnList[LENGTH] && !ret; i++) {\n                                fnObj = fnList[i];\n                                if (fnObj.id === id) {\n                                    if (!posit(removeList, fnObj)) {\n                                        removeList.push(fnObj);\n                                        ret = 1;\n                                    }\n                                }\n                            }\n                        }\n                        return !!ret;\n                    },\n                    stop: function () {\n                        stopped = BOOLEAN_TRUE;\n                        return this;\n                    },\n                    start: function () {\n                        var looper = this;\n                        stopped = BOOLEAN_FALSE;\n                        halted = BOOLEAN_FALSE;\n                        return looper;\n                    },\n                    halt: function () {\n                        halted = BOOLEAN_TRUE;\n                        return this.stop();\n                    },\n                    halted: function () {\n                        return halted;\n                    },\n                    stopped: function () {\n                        return stopped;\n                    },\n                    reset: function () {\n                        fnList = [];\n                        removeList = [];\n                        addList = [];\n                        return this;\n                    },\n                    add: function (fn) {\n                        var obj, id = counter,\n                            tween = this;\n                        if (!isFunction(fn)) {\n                            return;\n                        }\n                        if (!fnList[LENGTH]) {\n                            tween.start();\n                        }\n                        start(tween);\n                        obj = {\n                            fn: tween.bind(fn),\n                            id: id,\n                            disabled: BOOLEAN_FALSE,\n                            bound: tween\n                        };\n                        if (tween.running()) {\n                            addList.push(obj);\n                        } else {\n                            fnList.push(obj);\n                        }\n                        counter++;\n                        return id;\n                    }\n                });\n                add(looper);\n                return looper;\n            },\n            bind: function (fn) {\n                return bind(fn, this);\n            },\n            once: function (fn) {\n                return this.count(1, fn);\n            },\n            count: function (timey, fn_) {\n                var fn, count = 0,\n                    times = pI(timey) || 1;\n                if (!fn_ && isFunction(times)) {\n                    fn_ = timey;\n                    times = 1;\n                }\n                if (!isFunction(fn_)) {\n                    return;\n                }\n                fn = this.bind(fn_);\n                if (times < 1 || !isNumber(times)) {\n                    times = 1;\n                }\n                return this.add(function (ms) {\n                    var last = 1;\n                    count++;\n                    if (count >= times) {\n                        this.remove();\n                        last = 0;\n                    }\n                    fn(ms, !last, count);\n                });\n            },\n            tween: function (time, fn_) {\n                var fn, added = nowish();\n                if (!time) {\n                    time = 0;\n                }\n                if (!isFunction(fn)) {\n                    return;\n                }\n                fn = this.bind(fn_);\n                return this.interval(0, function (ms) {\n                    var tween = 1,\n                        diff = ms - added;\n                    if (diff >= time) {\n                        tween = 0;\n                        this.remove();\n                    }\n                    fn(ms, Math.min(1, (diff / time)), !tween);\n                });\n            },\n            time: function (time, fn_) {\n                var fn;\n                if (!isFunction(fn)) {\n                    return this;\n                }\n                fn = this.bind(fn_);\n                return this.interval(time, function (ms) {\n                    this.remove();\n                    fn(ms);\n                });\n            },\n            frameRate: function (time, fn_, min) {\n                var fn, tween = this,\n                    minimum = Math.min(min || 0.8, 0.8),\n                    expectedFrameRate = 30 * minimum,\n                    lastDate = 1,\n                    lastSkip = nowish();\n                time = time || 125;\n                if (!isFunction(fn_)) {\n                    return tween;\n                }\n                fn = bind(fn_, this);\n                return tween.add(function (ms) {\n                    var frameRate = 1000 / (ms - lastDate);\n                    if (frameRate > 40) {\n                        expectedFrameRate = 60 * minimum;\n                    }\n                    if (frameRate < expectedFrameRate) {\n                        lastSkip = ms;\n                    }\n                    if (ms - lastSkip > time) {\n                        this.remove();\n                        fn(ms);\n                    }\n                    lastDate = ms;\n                });\n            },\n            interval: function (time, fn_) {\n                var fn, last = nowish();\n                if (!isFunction(fn)) {\n                    return;\n                }\n                if (!time) {\n                    time = 0;\n                }\n                fn = this.bind(fn);\n                return this.add(function (ms) {\n                    if (ms - time >= last) {\n                        last = ms;\n                        fn(ms);\n                    }\n                });\n            }\n        }, !0);\n    _.exports({\n        AF: new Looper()\n    });\n});","application.scope().module('Promise', function (module, app, _, factories) {\n    var blank, FAILURE = 'failure',\n        SUCCESS = 'success',\n        STATE = 'state',\n        ALWAYS = 'always',\n        IS_EMPTYING = 'isEmptying',\n        ALL_STATES = 'allStates',\n        STASHED_ARGUMENT = 'stashedArgument',\n        flatten = _.flatten,\n        bind = _.bind,\n        isString = _.isString,\n        intendedObject = _.intendedObject,\n        duff = _.duff,\n        each = _.each,\n        extend = _.extend,\n        toArray = _.toArray,\n        isFunction = _.isFunction,\n        foldl = _.foldl,\n        result = _.result,\n        wraptry = _.wraptry,\n        indexOf = _.indexOf,\n        when = function () {\n            var promise = factories.Promise();\n            promise.add(foldl(flatten(arguments), function (memo, pro) {\n                if (promise._isChildType(pro)) {\n                    memo.push(pro);\n                }\n                return memo;\n            }, []));\n            return promise;\n        },\n        dispatch = function (promise, name, opts) {\n            var shouldstop, finalName = name,\n                allstates = result(promise, ALL_STATES),\n                collected = [];\n            while (!shouldstop) {\n                if (indexOf(collected, finalName) === -1) {\n                    collected.push(finalName);\n                    promise.executeHandlers(finalName);\n                    finalName = allstates[finalName];\n                } else {\n                    finalName = BOOLEAN_FALSE;\n                }\n                shouldstop = !isString(finalName);\n            }\n        },\n        executeIfNeeded = function (promise, name) {\n            return function () {\n                each(flatten(arguments), function (fn) {\n                    if (isFunction(fn)) {\n                        promise.executeHandler(name, fn, BOOLEAN_TRUE);\n                    }\n                });\n                return promise;\n            };\n        },\n        addState = function (key) {\n            var promise = this;\n            // if you haven't already attached a method, then do so now\n            if (!promise[key]) {\n                promise[key] = executeIfNeeded(promise, key);\n            }\n            return promise;\n        },\n        stateChecker = function (lookingfor) {\n            return function () {\n                var resulting = BOOLEAN_FALSE,\n                    allstates = result(this, ALL_STATES),\n                    next = this.get(STATE);\n                while (isString(next) && !resulting) {\n                    if (next === lookingfor) {\n                        resulting = BOOLEAN_TRUE;\n                    }\n                }\n                return resulting;\n            };\n        },\n        Promise = factories.Box.extend('Promise', {\n            addState: addState,\n            childEvents: {\n                always: 'check'\n            },\n            events: {\n                'child:added': 'check'\n            },\n            baseStates: function () {\n                return {\n                    success: ALWAYS,\n                    failure: ALWAYS,\n                    error: ALWAYS,\n                    always: BOOLEAN_TRUE\n                };\n            },\n            constructor: function () {\n                var promise = this;\n                factories.Box.constructor.call(promise);\n                promise.restart();\n                // cannot have been resolved in any way yet\n                intendedObject(extend({}, result(promise, 'baseStates'), result(promise, 'associativeStates')), NULL, bind(addState, promise));\n                // add passed in success handlers\n                promise.success(arguments);\n                return promise;\n            },\n            check: function () {\n                var notSuccessful, resolveAs, parent = this,\n                    children = parent.children,\n                    argumentAggregate = [];\n                if (children.length() && !children.find(function (child) {\n                    notSuccessful = notSuccessful || child.state() !== SUCCESS;\n                    argumentAggregate.push(child.get(STASHED_ARGUMENT));\n                    return !child.resolved();\n                })) {\n                    parent.resolveAs(notSuccessful ? FAILURE : SUCCESS, argumentAggregate);\n                }\n            },\n            _isChildType: function (promise) {\n                return promise[SUCCESS] && promise[FAILURE] && promise[ALWAYS];\n            },\n            defaults: function () {\n                return {\n                    state: 'pending',\n                    resolved: BOOLEAN_FALSE,\n                    stashedArgument: NULL,\n                    stashedHandlers: {},\n                    reason: BOOLEAN_FALSE\n                };\n            },\n            restart: function () {\n                return this.set(this.defaults());\n            },\n            state: function () {\n                return this.get(STATE);\n            },\n            auxilaryStates: function () {\n                return BOOLEAN_FALSE;\n            },\n            allStates: function () {\n                var resultResult = this._allStates = this._allStates || extend({}, result(this, 'baseStates'), result(this, 'auxilaryStates') || {});\n                return resultResult;\n            },\n            fullfillments: function () {\n                var allstates = result(this, ALL_STATES);\n                var results = this._fullfillments = this._fullfillments || wrap(allstates, function (value, key_) {\n                    var key = key_;\n                    while (isString(key)) {\n                        key = allstates[key];\n                    }\n                    // has to end in a boolean\n                    return key;\n                });\n                return results;\n            },\n            isFulfilled: stateChecker(SUCCESS),\n            isRejected: stateChecker(FAILURE),\n            resolved: function () {\n                // allows resolved to be defined in a different way\n                return this.get('resolved');\n            },\n            isPending: function () {\n                return this.get(STATE) === 'pending';\n            },\n            resolveAs: function (resolveAs_, opts_, reason_) {\n                var opts = opts_,\n                    resolveAs = resolveAs_,\n                    promise = this;\n                if (promise.resolved()) {\n                    return promise;\n                }\n                if (!isString(resolveAs)) {\n                    opts = resolveAs;\n                    resolveAs = BOOLEAN_FALSE;\n                }\n                promise.set({\n                    resolved: BOOLEAN_TRUE,\n                    // default state if none is given, is to have it succeed\n                    state: resolveAs || FAILURE,\n                    stashedArgument: opts,\n                    reason: reason_ ? reason_ : BOOLEAN_FALSE\n                });\n                resolveAs = promise.get(STATE);\n                wraptry(function () {\n                    dispatch(promise, resolveAs);\n                }, function () {\n                    promise.set(STASHED_ARGUMENT, {\n                        // nest the sucker again in case it's an array or something else\n                        options: opts,\n                        message: 'javascript execution error'\n                    });\n                    dispatch(promise, 'error');\n                });\n                return promise;\n            },\n            // convenience functions\n            resolve: function (opts) {\n                return this.resolveAs(SUCCESS, opts);\n            },\n            reject: function (opts) {\n                return this.resolveAs(FAILURE, opts);\n            },\n            executeHandlers: function (name) {\n                var handler, countLimit, promise = this,\n                    arg = promise.get(STASHED_ARGUMENT),\n                    handlers = promise.get('stashedHandlers')[name];\n                if (!handlers || !handlers[LENGTH]) {\n                    return promise;\n                }\n                countLimit = handlers[LENGTH];\n                promise.set(IS_EMPTYING, BOOLEAN_TRUE);\n                while (handlers[0] && --countLimit >= 0) {\n                    handler = handlers.shift();\n                    // should already be bound\n                    handler(arg);\n                }\n                promise.set(IS_EMPTYING, BOOLEAN_FALSE);\n                return promise;\n            },\n            executeHandler: function (name, fn_, needsbinding) {\n                var promise = this,\n                    arg = promise.get(STASHED_ARGUMENT),\n                    fn = fn_;\n                promise.stashHandler(name, fn);\n                if (promise.resolved() && !promise.get(IS_EMPTYING)) {\n                    promise.executeHandlers(name);\n                }\n                return promise;\n            },\n            stashHandler: function (name, fn, needsbinding) {\n                var promise = this,\n                    stashedHandlers = promise.get('stashedHandlers'),\n                    byName = stashedHandlers[name] = stashedHandlers[name] || [];\n                if (isFunction(fn)) {\n                    byName.push(bind(fn, this));\n                }\n            },\n            handle: function (resolutionstate, fun) {\n                this.addState(resolutionstate);\n                this.executeHandler(resolutionstate, fun, BOOLEAN_TRUE);\n                return this;\n            }\n        }, BOOLEAN_TRUE);\n    _.exports({\n        when: when\n    });\n});","application.scope().module('Ajax', function (module, app, _, factories) {\n    var gapSplit = _.gapSplit,\n        duff = _.duff,\n        each = _.each,\n        unCamelCase = _.unCamelCase,\n        posit = _.posit,\n        result = _.result,\n        wraptry = _.wraptry,\n        BOOLEAN_TRUE = !0,\n        BOOLEAN_FALSE = !1,\n        STATUS = 'status',\n        FAILURE = 'failure',\n        SUCCESS = 'success',\n        READY_STATE = 'readyState',\n        XDomainRequest = win.XDomainRequest,\n        isObject = _.isObject,\n        isArray = _.isArray,\n        stringify = _.stringify,\n        parse = _.parse,\n        extend = _.extend,\n        stringifyQuery = _.stringifyQuery,\n        GET = 'GET',\n        validTypes = gapSplit(GET + ' POST PUT DELETE'),\n        baseEvents = gapSplit('progress timeout abort error'),\n        /**\n         * @description helper function to attach a bunch of event listeners to the request object as well as help them trigger the appropriate events on the Ajax object itself\n         * @private\n         * @arg {Ajax} instance to listen to\n         * @arg {Xhr} instance to place event handlers to trigger events on the Ajax instance\n         * @arg {string} event name\n         */\n        attachBaseListeners = function (ajax) {\n            var prog = 0,\n                req = ajax.requestObject;\n            duff(baseEvents, function (evnt) {\n                if (evnt === 'progress') {\n                    req['on' + evnt] = function (e) {\n                        prog++;\n                        ajax.executeHandlers(evnt, {\n                            percent: (e.loaded / e.total) || (prog / (prog + 1)),\n                            counter: prog\n                        });\n                    };\n                } else {\n                    req['on' + evnt] = function (e) {\n                        ajax.resolveAs(evnt);\n                    };\n                }\n            });\n        },\n        sendthething = function (xhrReq, args) {\n            return function () {\n                wraptry(function () {\n                    xhrReq.send.apply(xhrReq, args);\n                }, function (e) {\n                    // handle an xhr req send error here\n                    factories.reportError('xhr', e + EMPTY_STRING);\n                });\n            };\n        },\n        alterurlHandler = function () {\n            var ajax = this,\n                xhrReq = ajax.requestObject,\n                type = ajax.get('type'),\n                url = ajax.getUrl(),\n                args = [],\n                data = ajax.get('data');\n            if (!url) {\n                return;\n            }\n            ajax.attachResponseHandler();\n            xhrReq.open(type, url, ajax.get('async'));\n            if (data) {\n                args.push(stringify(data));\n            }\n            ajax.setHeaders(ajax.get('headers'));\n            attachBaseListeners(ajax);\n            // have to wrap in set timeout for ie\n            setTimeout(sendthething(xhrReq, args));\n        },\n        /**\n         * @class Ajax\n         * @alias factories.Ajax\n         * @augments Box\n         * @augments Model\n         * @classdesc XHR object wrapper Triggers events based on xhr state changes and abstracts many anomalies that have to do with IE\n         */\n        Ajax = factories.Promise.extend('Ajax', {\n            /**\n             * @func\n             * @name Ajax#constructor\n             * @param {string} str - url to get from\n             * @returns {Ajax} new ajax object\n             */\n            constructor: function (str, secondary) {\n                var promise, url, thingToDo, typeThing, type, xhrReq, ajax = this,\n                    method = 'onreadystatechange';\n                // Add a cache buster to the url\n                // ajax.async = BOOLEAN_TRUE;\n                xhrReq = new XMLHttpRequest();\n                // covers ie9\n                if (!_.isUndefined(XDomainRequest)) {\n                    xhrReq = new XDomainRequest();\n                    method = 'onload';\n                }\n                if (!_.isObject(str)) {\n                    str = str || EMPTY_STRING;\n                    type = GET;\n                    typeThing = str.toUpperCase();\n                    if (posit(validTypes, typeThing)) {\n                        type = typeThing;\n                    } else {\n                        url = str;\n                    }\n                    str = {\n                        url: url || EMPTY_STRING,\n                        type: type\n                    };\n                }\n                str.async = BOOLEAN_TRUE;\n                str.type = (str.type || GET).toUpperCase();\n                str.method = method;\n                factories.Promise.constructor.apply(ajax);\n                ajax.on('change:url', alterurlHandler);\n                extend(ajax, secondary);\n                ajax.requestObject = xhrReq;\n                ajax.set(str);\n                return ajax;\n            },\n            status: function (code, handler) {\n                return this.handle(STATUS + ':' + code, handler);\n            },\n            setHeaders: function (headers) {\n                var ajax = this,\n                    xhrReq = ajax.requestObject;\n                each(headers, function (val, key) {\n                    xhrReq.setRequestHeader(unCamelCase(key), val);\n                });\n                return ajax;\n            },\n            /**\n             * @description specialized function to stringify url if it is an object\n             * @returns {string} returns the completed string that will be fetched / posted / put / or deleted against\n             * @name Ajax#getUrl\n             */\n            getUrl: function () {\n                var url = this.get('url');\n                if (isObject(url) && !isArray(url)) {\n                    url = stringifyQuery(url);\n                }\n                return url;\n            },\n            /**\n             * @description makes public the ability to attach a response handler if one has not already been attached. We recommend not passing a function in and instead just listening to the various events that the xhr object will trigger directly, or indirectly on the ajax object\n             * @param {function} [fn=handler] - pass in a function to have a custom onload, onreadystatechange handler\n             * @returns {ajax}\n             * @name Ajax#attachResponseHandler\n             */\n            auxilaryStates: function () {\n                return {\n                    'status:200': SUCCESS,\n                    'status:202': SUCCESS,\n                    'status:205': SUCCESS,\n                    'status:302': SUCCESS,\n                    'status:304': SUCCESS,\n                    'status:400': FAILURE,\n                    'status:401': FAILURE,\n                    'status:403': FAILURE,\n                    'status:404': FAILURE,\n                    'status:405': FAILURE,\n                    'status:406': FAILURE,\n                    'status:500': FAILURE,\n                    'status:502': FAILURE,\n                    'status:505': FAILURE,\n                    'status:511': FAILURE,\n                    timeout: FAILURE,\n                    abort: FAILURE\n                };\n            },\n            parse: function (rawData) {\n                return parse(rawData);\n            },\n            attachResponseHandler: function () {\n                var ajax = this,\n                    xhrReqObj = ajax.requestObject,\n                    hasFinished = BOOLEAN_FALSE,\n                    method = ajax.get('method'),\n                    handler = function (evnt) {\n                        var status, doIt, allStates, rawData, readystate, xhrReqObj = this;\n                        if (!xhrReqObj || hasFinished) {\n                            return;\n                        }\n                        status = xhrReqObj[STATUS];\n                        readystate = xhrReqObj[READY_STATE];\n                        rawData = xhrReqObj.responseText;\n                        ajax.currentEvent = evnt;\n                        ajax.set('readystate', readystate);\n                        if (method === 'onload' || (method === 'onreadystatechange' && readystate === 4)) {\n                            ajax.set(STATUS, status);\n                            allStates = result(ajax, 'allStates');\n                            if (allStates[STATUS + ':' + xhrReqObj[STATUS]] === SUCCESS) {\n                                rawData = result(ajax, 'parse', rawData);\n                            }\n                            rawData = parse(rawData);\n                            hasFinished = BOOLEAN_TRUE;\n                            ajax.resolveAs(STATUS + ':' + xhrReqObj[STATUS], rawData);\n                        }\n                    };\n                if (!xhrReqObj[method]) {\n                    xhrReqObj[method] = handler;\n                }\n                return ajax;\n            }\n        }, BOOLEAN_TRUE);\n    _.exports(_.foldl(validTypes, function (memo, key_) {\n        var key = key_;\n        key = key.toLowerCase();\n        memo[key] = function (url) {\n            return Ajax({\n                type: key_,\n                url: url\n            });\n        };\n        return memo;\n    }, {}));\n});","application.scope().module('Associator', function (module, app, _, factories) {\n    /**\n     * @class Associator\n     * @augments Model\n     */\n    var blank, DATA = 'data',\n        ITEMS = 'items',\n        LENGTH = 'length',\n        DATASET = DATA + 'set',\n        IS_ELEMENT = 'isElement',\n        INDEX_OF = 'indexOf',\n        __ELID__ = '__elid__',\n        BOOLEAN_TRUE = !0,\n        extend = _.extend,\n        isObject = _.isObject,\n        removeAt = _.removeAt,\n        Associator = factories.Directive.extend('Associator', {\n            /**\n             * @func\n             * @name Associator#get\n             * @param {Object} obj - object that data is being gotten against in the Associator\n             * @param {String} [type] - toString version of the object being passed in\n             */\n            get: function (obj, type) {\n                var returnData, idxOf, dataset, n, key, instance = this,\n                    canRead = 0,\n                    data = {},\n                    current = instance.sameType(obj),\n                    els = current[ITEMS] = current[ITEMS] || [],\n                    eldata = current[__ELID__] = current[__ELID__] || {},\n                    dataArray = current[DATA] = current[DATA] || [];\n                if (obj && current.readData) {\n                    // dataset = obj[DATASET];\n                    key = obj[__ELID__] = obj[__ELID__] || uniqueId('el');\n                    if (key) {\n                        data = eldata[key] = eldata[key] || {};\n                    }\n                } else {\n                    idxOf = current[ITEMS][INDEX_OF](obj);\n                    if (idxOf === blank || idxOf === -1) {\n                        idxOf = current[ITEMS][LENGTH];\n                        current[ITEMS].push(obj);\n                        dataArray[idxOf] = data;\n                    }\n                    data = dataArray[idxOf];\n                }\n                data.target = obj;\n                return data;\n            },\n            /**\n             * @func\n             * @name Associator#set\n             * @param {Node} el - Element to store data against\n             * @param {Object} obj - object to extend onto current data\n             * @param {String} [type] - toString evaluation of element, if it has already been evaluated\n             * @returns {Object} data that is being held on the Associator\n             */\n            set: function (el, extensor, type) {\n                var n, data = this.get(el, type);\n                extend(data, extensor || {});\n                return data;\n            },\n            remove: function (el) {\n                var type = this.sameType(el),\n                    idx = _[INDEX_OF](type[ITEMS], el),\n                    ret = removeAt(type[DATA], idx);\n                removeAt(type[ITEMS], idx);\n                return ret;\n            },\n            /**\n             * @func\n             * @name Associator#sameType\n             * @param {Object} obj - object to find matched types against\n             */\n            sameType: function (obj) {\n                var instance = this,\n                    type = _.toString(obj),\n                    current = instance[type] = instance[type] || {},\n                    lowerType = type.toLowerCase(),\n                    globalindex = lowerType[INDEX_OF]('global');\n                // skip reading data\n                if (globalindex === -1 && lowerType[INDEX_OF](WINDOW) === -1) {\n                    current.readData = BOOLEAN_TRUE;\n                }\n                return current;\n            },\n            ensure: function (el, attr, failure) {\n                var data = this.get(el);\n                data[attr] = data[attr] || failure(el);\n                // data[attr][TARGET] = data[attr][TARGET] || data[TARGET];\n                return data[attr];\n            }\n        }, BOOLEAN_TRUE);\n    _.exports({\n        associator: Associator()\n    });\n});","application.scope().module('DOMM', function (module, app, _, factories) {\n    var posit = _.posit,\n        Collection = factories.Collection,\n        elementData = _.associator,\n        DOMM_STRING = 'DOMM',\n        NODE_TYPE = 'nodeType',\n        LOCAL_NAME = 'localName',\n        APPEND_CHILD = 'appendChild',\n        REMOVE_CHILD = 'removeChild',\n        PARENT_NODE = 'parentNode',\n        ITEMS = '_items',\n        INNER_HTML = 'innerHTML',\n        INNER_TEXT = 'innerText',\n        DELEGATE_COUNT = '__delegateCount',\n        REMOVE_QUEUE = 'removeQueue',\n        ADD_QUEUE = 'addQueue',\n        CLASSNAME = 'className',\n        CLASS__NAME = (CLASS + HYPHEN + NAME),\n        FONT_SIZE = 'fontSize',\n        DEFAULT_VIEW = 'defaultView',\n        DIV = 'div',\n        IFRAME = 'iframe',\n        ELEMENT = 'element',\n        devicePixelRatio = (win.devicePixelRatio || 1),\n        ua = navigator.userAgent,\n        isElement = function (object) {\n            return !!(object && isNumber(object[NODE_TYPE]) && object[NODE_TYPE] === object.ELEMENT_NODE);\n        },\n        // isElementUnwrapped = function (manager) {\n        //     return isElement(manager.unwrap());\n        // },\n        /**\n         * @private\n         * @func\n         */\n        isWindow = function (obj) {\n            return obj && obj === obj[WINDOW];\n        },\n        /**\n         * @private\n         * @func\n         */\n        isDocument = function (obj) {\n            return obj && isNumber(obj[NODE_TYPE]) && obj[NODE_TYPE] === obj.DOCUMENT_NODE;\n        },\n        isFragment = function (frag) {\n            return frag && frag[NODE_TYPE] === doc.DOCUMENT_FRAGMENT_NODE;\n        },\n        getClosestWindow = function (windo_) {\n            var windo = windo_ || win;\n            return isWindow(windo) ? windo : (windo && windo[DEFAULT_VIEW] ? windo[DEFAULT_VIEW] : (windo.ownerGlobal ? windo.ownerGlobal : DOMM(windo).parent(WINDOW)[INDEX](0) || win));\n        },\n        getComputed = function (el, ctx) {\n            var ret = getClosestWindow(ctx).getComputedStyle(el);\n            return ret ? ret : getClosestWindow(el).getComputedStyle(el) || clone(el[STYLE]) || {};\n        },\n        allStyles = getComputed(doc[BODY], win),\n        rkeyEvent = /^key/,\n        rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n        rforceEvent = /^webkitmouseforce/,\n        hasWebP = (function () {\n            var countdown = 4,\n                result = BOOLEAN_TRUE,\n                queue = [],\n                emptyqueue = function (fn) {\n                    return function () {\n                        countdown--;\n                        fn();\n                        if (!countdown) {\n                            duff(queue, function (item) {\n                                item(result);\n                            });\n                            queue = [];\n                        }\n                    };\n                };\n            duff([\"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\", \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\", \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\", \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"], function (val) {\n                var img = new Image();\n                img.onload = emptyqueue(noop);\n                img.onerror = emptyqueue(function () {\n                    result = BOOLEAN_FALSE;\n                });\n                img.src = \"data:image/webp;base64,\" + val;\n            });\n            return function (cb) {\n                if (!countdown || !result) {\n                    cb(result);\n                } else {\n                    queue.push(cb);\n                }\n            };\n        }()),\n        saveDOMContentLoadedEvent = function (domm) {\n            var manager = domm.index(0);\n            if (manager.isReady === UNDEFINED) {\n                manager.isReady = BOOLEAN_FALSE;\n                domm.on('DOMContentLoaded', function (e) {\n                    manager.DOMContentLoadedEvent = e;\n                    manager.isReady = BOOLEAN_TRUE;\n                });\n            }\n        },\n        _DOMM = factories._DOMM = function (doc_) {\n            var doc = DOMM(doc_);\n            saveDOMContentLoadedEvent(doc);\n            var scoped = function (sel, ctx) {\n                return DOMM(sel, ctx || doc, UNDEFINED, BOOLEAN_TRUE);\n            };\n            scoped[CONSTRUCTOR] = DOMM[CONSTRUCTOR];\n            return scoped;\n        },\n        writeAttribute = function (el, key, val_) {\n            el.setAttribute(key, (val_ === BOOLEAN_TRUE ? EMPTY_STRING : stringify(val_)) + EMPTY_STRING);\n        },\n        coerceValue = function (value) {\n            var val = value;\n            if (val === EMPTY_STRING) {\n                val = BOOLEAN_TRUE;\n            } else {\n                if (val == NULL) {\n                    val = BOOLEAN_FALSE;\n                } else {\n                    val = +val == val ? +val : val;\n                }\n            }\n            return val === val ? val : BOOLEAN_FALSE;\n        },\n        readAttribute = function (el, key) {\n            return coerceValue(parse(el.getAttribute(key)));\n        },\n        /**\n         * @private\n         * @func\n         */\n        removeAttribute = function (el, key) {\n            el.removeAttribute(key);\n        },\n        attributeInterface = {\n            read: readAttribute,\n            write: writeAttribute,\n            remove: removeAttribute\n        },\n        addRemoveAttributes = function (value_, stringManager) {\n            // handle complex adding and removing\n            var value = value_,\n                isArrayResult = isArray(value);\n            if (isObject(value) && !isArrayResult) {\n                // toggles add remove value\n                each(value, function (value, key) {\n                    stringManager.add(key).toggle(!!value);\n                });\n            } else {\n                if (!isArrayResult) {\n                    value += EMPTY_STRING;\n                }\n                stringManager.refill(gapSplit(value));\n            }\n            return stringManager;\n        },\n        // scopedInterface = function (attribute, remove, add) {\n        //     return function (el) {\n        //         var stringManager = elementData.ensure(el, DOMM_STRING, DomManager).get(attribute, StringManager);\n        //     };\n        // },\n        trackedAttributeInterface = function (el, key, val, isProp, manager) {\n            // set or remove if not undefined\n            // undefined fills in the gap by returning some value, which is never undefined\n            var isArrayResult, cameledKey = camelCase(key),\n                el_interface = isProp ? propertyInterface : attributeInterface,\n                stringManager = !isProp && (manager || returnsElementData(el)).get(cameledKey, StringManager),\n                readAttribute = el_interface.read(el, key);\n            if (!isProp && isString(readAttribute)) {\n                stringManager.ensure(readAttribute);\n            }\n            if (val == NULL) {\n                return readAttribute;\n            }\n            if (!val && val !== 0) {\n                el_interface.remove(el, key);\n            } else {\n                el_interface.write(el, key, isProp ? val : addRemoveAttributes(val, stringManager).generate(' '));\n            }\n        },\n        getClassName = function (el, key) {\n            var className, failed = key === CLASS;\n            if (!failed) {\n                className = el[CLASSNAME];\n                if (!isString(className)) {\n                    failed = BOOLEAN_TRUE;\n                }\n            }\n            if (failed) {\n                className = getAttribute(el, CLASS, BOOLEAN_FALSE);\n            }\n            return (className || EMPTY_STRING).split(' ');\n        },\n        setClassName = function (el, key, value) {\n            var failed = key === CLASS;\n            if (!failed) {\n                if (isString(el[CLASSNAME])) {\n                    el[CLASSNAME] = value;\n                } else {\n                    failed = BOOLEAN_TRUE;\n                }\n            }\n            if (failed) {\n                setAttribute(el, CLASS, value, BOOLEAN_FALSE);\n            }\n        },\n        DO_NOT_TRUST = BOOLEAN_FALSE,\n        cannotTrust = function (fn) {\n            return function () {\n                var ret, cachedTrust = DO_NOT_TRUST;\n                DO_NOT_TRUST = BOOLEAN_TRUE;\n                ret = fn.apply(this, arguments);\n                DO_NOT_TRUST = cachedTrust;\n                return ret;\n            };\n        },\n        triggerEventWrapper = function (attr_, api) {\n            var attr = attr_ || api,\n                eachHandler = cannotTrust(function (manager) {\n                    var whichever = api || attr,\n                        el = manager.unwrap();\n                    if (isFunction(el[whichever])) {\n                        el[whichever]();\n                    } else {\n                        manager.dispatchEvent(whichever);\n                    }\n                });\n            return function (fn, fn2, capturing) {\n                var args, evnt, count = 0,\n                    domm = this;\n                if (isFunction(fn) || isFunction(fn2)) {\n                    domm.on(attr, fn, fn2, capturing);\n                } else {\n                    domm.duff(eachHandler);\n                }\n                return domm;\n            };\n        },\n        /**\n         * @private\n         * @func\n         */\n        htmlDataMatch = function (string, regexp, callback, nameFinder) {\n            var matches = string.trim().match(regexp);\n            duff(matches, function (match) {\n                var value;\n                match = match.trim();\n                value = match.match(/~*=[\\'|\\\"](.*?)[\\'|\\\"]/);\n                name = match.match(/(.*)(?:~*=)/igm);\n                name = _.join(_.split(name, '='), EMPTY_STRING).trim();\n                callback(value[1], name, match);\n            });\n        },\n        Events = gapSplit('abort afterprint beforeprint blocked cached canplay canplaythrough change chargingchange chargingtimechange checking close complete dischargingtimechange DOMContentLoaded downloading durationchange emptied ended error fullscreenchange fullscreenerror input invalid languagechange levelchange loadeddata loadedmetadata message noupdate obsolete offline online open pagehide pageshow paste pause pointerlockchange pointerlockerror play playing ratechange reset seeked seeking stalled storage submit success suspend timeupdate updateready upgradeneeded versionchange visibilitychange'),\n        SVGEvent = gapSplit('SVGAbort SVGError SVGLoad SVGResize SVGScroll SVGUnload SVGZoom volumechange waiting'),\n        KeyboardEvent = gapSplit('keydown keypress keyup'),\n        GamePadEvent = gapSplit('gamepadconnected gamepadisconnected'),\n        CompositionEvent = gapSplit('compositionend compositionstart compositionupdate drag dragend dragenter dragleave dragover dragstart drop'),\n        MouseEvents = gapSplit('click contextmenu dblclick mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup show wheel'),\n        TouchEvents = gapSplit('touchcancel touchend touchenter touchleave touchmove touchstart'),\n        DeviceEvents = gapSplit('devicemotion deviceorientation deviceproximity devicelight'),\n        FocusEvent = gapSplit('blur focus'),\n        // BeforeUnloadEvent = gapSplit(EMPTY_STRING),\n        TimeEvent = gapSplit('beginEvent endEvent repeatEvent'),\n        AnimationEvent = gapSplit('animationend animationiteration animationstart transitionend'),\n        AudioProcessingEvent = gapSplit('audioprocess complete'),\n        UIEvents = gapSplit('abort error hashchange load orientationchange readystatechange resize scroll select unload beforeunload'),\n        ProgressEvent = gapSplit('abort error load loadend loadstart popstate progress timeout'),\n        AllEvents = _.concatUnique(Events, SVGEvent, KeyboardEvent, CompositionEvent, GamePadEvent, MouseEvents, TouchEvents, DeviceEvents, FocusEvent, TimeEvent, AnimationEvent, AudioProcessingEvent, UIEvents, ProgressEvent),\n        knownPrefixes = gapSplit('-o- -ms- -moz- -webkit- mso- -xv- -atsc- -wap- -khtml- -apple- prince- -ah- -hp- -ro- -rim- -tc-'),\n        trustedEvents = gapSplit('load scroll resize orientationchange click dblclick mousedown mouseup mouseover mouseout mouseenter mouseleave mousemove change contextmenu hashchange load mousewheel wheel readystatechange'),\n        ALL_EVENTS_HASH = wrap(AllEvents, BOOLEAN_TRUE),\n        knownPrefixesHash = wrap(knownPrefixes, BOOLEAN_TRUE),\n        StringManager = factories.StringManager,\n        // isProp = isProp_ === UNDEFINED ? !isObject(el[CLASSNAME]) : isProp_,\n        //         currentClassName = getAttribute(el, key, isProp),\n        // gapSplit(currentClassName)\n        // because classes are always strings, we can use a different management tool\n        // LAZYattributeInterface = function (el, key, remove, add, current, wipes, data_, manager_) {\n        //     var data = manager_ || data_ || returnsElementData(el),\n        //         _manager = manager_ || data.get(key, StringManager),\n        //         manager = _manager.ensure(current, ' ');\n        //     return manager;\n        // },\n        readProperty = function (el, property) {\n            return el[property];\n        },\n        writeProperty = function (el, property, value) {\n            el[property] = value;\n        },\n        removeProperty = function (el, property) {\n            writeProperty(el, property, NULL);\n        },\n        propertyInterface = {\n            read: readProperty,\n            write: writeProperty,\n            remove: removeProperty\n        },\n        ensureManager = function (manager, attribute, currentValue) {\n            var _attributeManager = manager.get(attribute, StringManager);\n            return _attributeManager.ensure(currentValue, ' ');\n        },\n        queueAttributes = function (attribute, first_, second_, api, merge, after) {\n            var first = gapSplit(first_),\n                second = gapSplit(second_);\n            return function (manager) {\n                var el = manager.unwrap();\n                var result = merge(ensureManager(manager, attribute, api.read(el, attribute)), first, second);\n                return after && api[after] && api[after](el, attribute, result.generate(' '));\n            };\n        },\n        DOMQueueAttributes = function (list, attribute, first_, second_, api, merge, after) {\n            duff(list, queueAttributes(attribute, first_, second_, api, merge, after));\n        },\n        globalQueueAttributes = function (merge, multipleOrNot) {\n            return function (attribute, api, insides) {\n                return function (list, first, second, attribute_, insides_) {\n                    var inside = insides_ === UNDEFINED ? insides : insides_;\n                    return multipleOrNot(list, attribute_ || attribute, first, second, api, merge, inside);\n                };\n            };\n        },\n        _addAttributeValues = function (attributeManager, add) {\n            duff(add, attributeManager.add, attributeManager);\n            return attributeManager;\n        },\n        _removeAttributeValues = function (attributeManager, remove) {\n            duff(remove, attributeManager.remove, attributeManager);\n            return attributeManager;\n        },\n        _toggleAttributeValues = function (attributeManager, togglers) {\n            duff(togglers, attributeManager.toggle, attributeManager);\n            return attributeManager;\n        },\n        _changeAttributeValues = function (attributeManager, remove, add) {\n            return _addAttributeValues(_removeAttributeValues(attributeManager, remove), add);\n        },\n        _booleanAttributeValues = function (attributeManager, addremove, follows) {\n            // rework this\n            return (addremove ? _addAttributeValues : _removeAttributeValues)(attributeManager, follows);\n        },\n        // global attribute manager handlers\n        addAttributeValues = globalQueueAttributes(_addAttributeValues, DOMQueueAttributes),\n        removeAttributeValues = globalQueueAttributes(_removeAttributeValues, DOMQueueAttributes),\n        toggleAttributeValues = globalQueueAttributes(_toggleAttributeValues, DOMQueueAttributes),\n        changeAttributeValues = globalQueueAttributes(_changeAttributeValues, DOMQueueAttributes),\n        booleanAttributeValues = globalQueueAttributes(_booleanAttributeValues, DOMQueueAttributes),\n        // scoped to class\n        classNameApi = {\n            read: getClassName,\n            write: setClassName,\n            remove: removeAttribute\n        },\n        addClass = addAttributeValues(CLASSNAME, classNameApi),\n        removeClass = removeAttributeValues(CLASSNAME, classNameApi),\n        toggleClass = toggleAttributeValues(CLASSNAME, classNameApi),\n        changeClass = changeAttributeValues(CLASSNAME, classNameApi),\n        booleanClass = booleanAttributeValues(CLASSNAME, classNameApi),\n        DOMAttributeApplication = function (fn, key, applies) {\n            return function (one, two) {\n                return fn(this.unwrap(), one, two, key, applies);\n            };\n        },\n        attributeApplication = function (fn, key, applies) {\n            return function (one, two) {\n                return fn(this, one, two, key, applies);\n            };\n        },\n        managerContainsClass = function (classes) {\n            return function (manager) {\n                var el = manager.unwrap(),\n                    _attributeManager = manager.get(CLASSNAME, StringManager),\n                    classManager = _attributeManager.ensure(getClassName(el), ' ');\n                return find(classes, function (clas) {\n                    var stringInstance = classManager.get(ID, clas);\n                    return stringInstance ? !stringInstance.isValid() : BOOLEAN_TRUE;\n                });\n            };\n        },\n        containsClass = function (classes_) {\n            var classes = gapSplit(classes_);\n            return !!(classes[LENGTH] && this[LENGTH]() && !find(this.unwrap(), managerContainsClass(classes)));\n        },\n        /**\n         * @private\n         * @func\n         */\n        toStyleString = function (css) {\n            var cssString = [];\n            each(css, function (name, val) {\n                var nameSplit;\n                name = unCamelCase(name);\n                nameSplit = name.split(HYPHEN);\n                if (knownPrefixesHash[nameSplit[0]]) {\n                    nameSplit.unshift(EMPTY_STRING);\n                }\n                name = nameSplit.join(HYPHEN);\n                cssString.push(name + ': ' + val + ';');\n            });\n            return cssString.join(' ');\n        },\n        /**\n         * @private\n         * @func\n         */\n        ensureDOM = function (fn) {\n            return function (manager, one, two) {\n                if (manager.isElement) {\n                    fn(el, one, two);\n                }\n            };\n        },\n        /**\n         * @private\n         * @func\n         */\n        // returns the flow of the element passed on relative to the element's bounding window\n        flow = function (el, ctx) {\n            var clientRect = el.getBoundingClientRect(),\n                computedStyle = getComputed(el, ctx),\n                marginTop = parseFloat(computedStyle.marginTop),\n                marginLeft = parseFloat(computedStyle.marginLeft),\n                marginRight = parseFloat(computedStyle.marginRight),\n                marginBottom = parseFloat(computedStyle.marginBottom);\n            return {\n                height: clientRect[HEIGHT],\n                width: clientRect[WIDTH],\n                top: clientRect[TOP] - marginTop,\n                left: clientRect[LEFT] - marginLeft,\n                right: clientRect[LEFT] - marginLeft + clientRect[WIDTH] - marginRight,\n                bottom: clientRect[TOP] - marginTop + clientRect[HEIGHT] - marginBottom\n            };\n        },\n        numberBasedCss = {\n            columnCount: BOOLEAN_TRUE,\n            columns: BOOLEAN_TRUE,\n            fontWeight: BOOLEAN_TRUE,\n            lineHeight: BOOLEAN_TRUE,\n            opacity: BOOLEAN_TRUE,\n            zIndex: BOOLEAN_TRUE,\n            zoom: BOOLEAN_TRUE,\n            animationIterationCount: BOOLEAN_TRUE,\n            boxFlex: BOOLEAN_TRUE,\n            boxFlexGroup: BOOLEAN_TRUE,\n            boxOrdinalGroup: BOOLEAN_TRUE,\n            flex: BOOLEAN_TRUE,\n            flexGrow: BOOLEAN_TRUE,\n            flexPositive: BOOLEAN_TRUE,\n            flexShrink: BOOLEAN_TRUE,\n            flexNegative: BOOLEAN_TRUE,\n            flexOrder: BOOLEAN_TRUE,\n            lineClamp: BOOLEAN_TRUE,\n            order: BOOLEAN_TRUE,\n            orphans: BOOLEAN_TRUE,\n            tabSize: BOOLEAN_TRUE,\n            widows: BOOLEAN_TRUE,\n            // SVG-related properties\n            fillOpacity: BOOLEAN_TRUE,\n            stopOpacity: BOOLEAN_TRUE,\n            strokeDashoffset: BOOLEAN_TRUE,\n            strokeOpacity: BOOLEAN_TRUE,\n            strokeWidth: BOOLEAN_TRUE\n        },\n        timeBasedCss = {\n            transitionDuration: BOOLEAN_TRUE,\n            animationDuration: BOOLEAN_TRUE,\n            transitionDelay: BOOLEAN_TRUE,\n            animationDelay: BOOLEAN_TRUE\n        },\n        /**\n         * @private\n         * @func\n         */\n        css = (function () {\n            var i, j, n, found, prefixIndex, __prefix, styleName, currentCheck, deprefixed, currentLen,\n                validCssNames = [],\n                prefixed = {},\n                len = 0,\n                valueModifiers = {\n                    '-webkit-transform': function (val) {\n                        return val;\n                    }\n                },\n                modifyFinalProp = function (prop, val) {\n                    if (valueModifiers[prop]) {\n                        val = valueModifiers[prop](val);\n                    }\n                    return val;\n                },\n                addPrefix = function (list, prefix) {\n                    if (!posit(list, __prefix)) {\n                        list.push(__prefix);\n                    }\n                };\n            for (i = 0; i < knownPrefixes[LENGTH]; i++) {\n                currentLen = knownPrefixes[i][LENGTH];\n                if (len < currentLen) {\n                    len = currentLen;\n                }\n            }\n            for (n in allStyles) {\n                found = 0;\n                currentCheck = EMPTY_STRING;\n                __prefix = EMPTY_STRING;\n                if (isNumber(+n)) {\n                    styleName = allStyles[n];\n                } else {\n                    styleName = unCamelCase(n);\n                }\n                deprefixed = styleName;\n                for (j = 0; j < len && styleName[j] && !found; j++) {\n                    currentCheck += styleName[j];\n                    prefixIndex = indexOf(knownPrefixes, currentCheck);\n                    if (prefixIndex !== -1) {\n                        __prefix = knownPrefixes[prefixIndex];\n                        deprefixed = styleName.split(__prefix).join(EMPTY_STRING);\n                        found = 1;\n                    }\n                    prefixIndex = indexOf(knownPrefixes, HYPHEN + currentCheck);\n                    if (prefixIndex !== -1) {\n                        __prefix = knownPrefixes[prefixIndex];\n                        deprefixed = styleName.split(currentCheck).join(EMPTY_STRING);\n                        found = 1;\n                    }\n                }\n                deprefixed = camelCase(deprefixed);\n                validCssNames.push(deprefixed);\n                if (!prefixed[deprefixed]) {\n                    prefixed[deprefixed] = [];\n                }\n                addPrefix(prefixed[deprefixed], __prefix);\n            }\n            return function (el, key, value) {\n                var n, m, j, firstEl, lastKey, prefixes, unCameled, computed, _ret, retObj, finalProp, i = 0,\n                    ret = {},\n                    count = 0,\n                    nuCss = {};\n                if (!isObject(el)) {\n                    return;\n                }\n                if (isBoolean(key)) {\n                    key = el;\n                    retObj = 1;\n                }\n                firstEl = el[0];\n                intendedObject(key, value, function (key, value) {\n                    if (value != NULL) {\n                        count++;\n                        prefixes = [EMPTY_STRING];\n                        if (prefixed[m]) {\n                            prefixes = prefixed[m].concat(prefixes);\n                        }\n                        for (j = 0; j < prefixes[LENGTH]; j++) {\n                            finalProp = camelCase(prefixes[j] + m);\n                            nuCss[finalProp] = modifyFinalProp(finalProp, value);\n                        }\n                    } else {\n                        ret[m] = value;\n                    }\n                });\n                if (retObj) {\n                    return nuCss;\n                }\n                if (isElement(el)) {\n                    el = [el];\n                }\n                if (!count) {\n                    if (isElement(firstEl)) {\n                        _ret = {};\n                        computed = getComputed(firstEl);\n                        count--;\n                        each(ret, function (val_, key, obj) {\n                            _ret[key] = convertStyleValue(key, computed[key]);\n                            count++;\n                            lastKey = key;\n                        });\n                        if (count + 1) {\n                            if (count) {\n                                return _ret;\n                            } else {\n                                return _ret[lastKey];\n                            }\n                        }\n                    }\n                } else {\n                    style(el, nuCss);\n                }\n            };\n        }()),\n        convertStyleValue = function (key, value) {\n            return value !== +value ? value : (timeBasedCss[key] ? value + 'ms' : (!numberBasedCss[key] ? value + PIXELS : value));\n        },\n        /**\n         * @private\n         * @func\n         */\n        // eachProc = function (fn) {\n        //     return function (one, two, three, four, five) {\n        //         var domm = this;\n        //         return domm.duff(function (zero, idx) {\n        //             fn(zero, one, two, three, four, five);\n        //         });\n        //     };\n        // },\n        // styleIteration = eachProc(function (manager, key, value) {\n        //     if (manager.isElement) {\n        //         manager[TARGET][STYLE][key] = value;\n        //     }\n        // }),\n        style = function (els, key, value) {\n            if (!els[LENGTH]) {\n                return;\n            }\n            // var bound = bind(styleIteration, this);\n            intendedObject(key, value, function (key, value_) {\n                bound(key, convertStyleValue(value_));\n            });\n        },\n        prefixer = function (obj) {\n            var rez = css(obj, BOOLEAN_TRUE);\n            return rez;\n        },\n        jsToCss = function (obj) {\n            var nuObj = {};\n            each(obj, function (key, val) {\n                var deCameled = unCamelCase(key),\n                    split = deCameled.split(HYPHEN),\n                    starter = split[0],\n                    idx = indexOf(knownPrefixes, HYPHEN + starter + HYPHEN);\n                if (idx !== -1) {\n                    split[0] = HYPHEN + starter;\n                }\n                nuObj[split.join(HYPHEN)] = val;\n            });\n            return nuObj;\n        },\n        /**\n         * @private\n         * @func\n         */\n        box = function (el, ctx) {\n            var clientrect, computed, ret = {};\n            if (!isElement(el)) {\n                return ret;\n            }\n            computed = getComputed(el, ctx);\n            clientrect = clientRect(el, ctx);\n            return {\n                borderBottom: +computed.borderBottomWidth || 0,\n                borderRight: +computed.borderRightWidth || 0,\n                borderLeft: +computed.borderLeftWidth || 0,\n                borderTop: +computed.borderTopWidth || 0,\n                paddingBottom: +computed.paddingBottom || 0,\n                paddingRight: +computed.paddingRight || 0,\n                paddingLeft: +computed.paddingLeft || 0,\n                paddingTop: +computed.paddingTop || 0,\n                marginBottom: +computed.marginBottom || 0,\n                marginRight: +computed.marginRight || 0,\n                marginLeft: +computed.marginLeft || 0,\n                marginTop: +computed.marginTop || 0,\n                computedBottom: +computed[BOTTOM] || 0,\n                computedRight: +computed[RIGHT] || 0,\n                computedLeft: +computed[LEFT] || 0,\n                computedTop: +computed[TOP] || 0,\n                top: clientrect[TOP] || 0,\n                left: clientrect[LEFT] || 0,\n                right: clientrect[RIGHT] || 0,\n                bottom: clientrect[BOTTOM] || 0,\n                width: clientrect[WIDTH] || 0,\n                height: clientrect[HEIGHT] || 0\n            };\n        },\n        clientRect = function (item) {\n            var ret = {};\n            if (isElement(item)) {\n                ret = item.getBoundingClientRect();\n            }\n            return {\n                top: ret[TOP] || 0,\n                left: ret[LEFT] || 0,\n                right: ret[RIGHT] || 0,\n                bottom: ret[BOTTOM] || 0,\n                width: ret[WIDTH] || 0,\n                height: ret[HEIGHT] || 0\n            };\n        },\n        /**\n         * @private\n         * @func\n         */\n        unitRemoval = function (str, unit) {\n            return +(str.split(unit || 'px').join(EMPTY_STRING).trim()) || 0;\n        },\n        /**\n         * @private\n         * @func\n         */\n        getStyleSize = function (el, attr, win) {\n            var val, elStyle, num = el;\n            if (isObject(el)) {\n                if (isElement(el)) {\n                    elStyle = getComputed(el, win);\n                } else {\n                    elStyle = el;\n                }\n                val = elStyle[attr];\n            } else {\n                val = el;\n            }\n            if (isString(val)) {\n                val = unitRemoval(val);\n            }\n            return val;\n        },\n        /**\n         * @private\n         * @func\n         */\n        filterExpressions = {\n            ':even': function (el, idx) {\n                return (idx % 2);\n            },\n            ':odd': function (el, idx) {\n                return ((idx + 1) % 2);\n            }\n        },\n        // always in pixels\n        numberToUnit = {\n            'in': function (val, el, win, styleAttr) {\n                return val / 96;\n            },\n            vh: function (val, el, win, styleAttr) {\n                return (val / win[INNER_HEIGHT]) * 100;\n            },\n            px: function (val, el, win, styleAttr) {\n                return val;\n            },\n            cm: function (val, el, win, styleAttr) {\n                return val / 37.79527559055118;\n            },\n            vw: function (val, el, win, styleAttr) {\n                return (val / win[INNER_WIDTH]) * 100;\n            },\n            em: function (val, el, win, styleAttr) {\n                return val / getStyleSize(el, FONT_SIZE, win);\n            },\n            mm: function (val, el, win, styleAttr) {\n                return val / 3.779527559055118;\n            },\n            vmin: function (val, el, win, styleAttr) {\n                var mult = Math.min(win[INNER_HEIGHT], win[INNER_WIDTH]);\n                return (val / mult) * 100;\n            },\n            rem: function (val, el, win, styleAttr) {\n                return val / getStyleSize(win[DOCUMENT][BODY][PARENT_NODE], FONT_SIZE, win);\n            },\n            pt: function (val, el, win, styleAttr) {\n                return val / 1.333333333333333;\n            },\n            vmax: function (val, el, win, styleAttr) {\n                var mult = Math.max(win[INNER_HEIGHT], win[INNER_WIDTH]);\n                return (val / mult) * 100;\n            },\n            '%': function (val, el, win, styleAttr) {\n                var parent = isElement(el) ? el[PARENT_NODE] : el,\n                    _val = getStyleSize(parent, styleAttr, win);\n                return (val / _val) * 100;\n            },\n            pc: function (val, el, win, styleAttr) {\n                return val / 16;\n            }\n        },\n        numToUnits = function (num, unit, el, winTop, styleAttr, returnNum) {\n            var number = num;\n            if (num) {\n                number = numberToUnit[unit](num, el, winTop, styleAttr);\n            }\n            number = (number || 0);\n            if (!returnNum) {\n                number += unit;\n            }\n            return number;\n        },\n        /**\n         * @private\n         * @func\n         */\n        unitToNumber = {\n            'in': function (val, el, win, styleAttr) {\n                return val * 96;\n            },\n            vh: function (val, el, win, styleAttr) {\n                return win[INNER_HEIGHT] * val / 100;\n            },\n            px: function (val, el, win, styleAttr) {\n                return val;\n            },\n            cm: function (val, el, win, styleAttr) {\n                return val * 37.79527559055118;\n            },\n            vw: function (val, el, win, styleAttr) {\n                return win[INNER_WIDTH] * val / 100;\n            },\n            em: function (val, el, win, styleAttr) {\n                return getStyleSize(el, FONT_SIZE) * val;\n            },\n            mm: function (val, el, win, styleAttr) {\n                return val * 3.779527559055118;\n            },\n            vmin: function (val, el, win, styleAttr) {\n                return ((Math.min(win[INNER_HEIGHT], win[INNER_WIDTH]) || 1) * val / 100);\n            },\n            rem: function (val, el, win, styleAttr) {\n                return getStyleSize(win[DOCUMENT][BODY][PARENT_NODE], FONT_SIZE) * val;\n            },\n            pt: function (val, el, win, styleAttr) {\n                return val * 1.333333333333333;\n            },\n            vmax: function (val, el, win, styleAttr) {\n                return ((Math.max(win[INNER_HEIGHT], win[INNER_WIDTH]) || 1) * val / 100);\n            },\n            '%': function (val, el, win, styleAttr) {\n                var parent = isElement(el) ? el[PARENT_NODE] : el,\n                    _val = getStyleSize(parent, styleAttr);\n                return (val * _val) / 100;\n            },\n            pc: function (val, el, win, styleAttr) {\n                return val * 16;\n            }\n        },\n        unitsToNum = function (str, el, winTop, styleAttr) {\n            var ret, number, unit = units(str);\n            if (!unit) {\n                return str;\n            }\n            number = +(str.split(unit).join(EMPTY_STRING)) || 0;\n            if (unitToNumber[unit]) {\n                number = unitToNumber[unit](number, el, winTop, styleAttr) || 0;\n            }\n            return number;\n        },\n        /**\n         * @private\n         * @func\n         */\n        tag = function (el, str) {\n            var tagName;\n            if (!el || !isElement(el)) {\n                return BOOLEAN_FALSE;\n            }\n            tagName = el[LOCAL_NAME].toLowerCase();\n            return str ? tagName === str.toLowerCase() : tagName;\n        },\n        /**\n         * @private\n         * @func\n         */\n        isTrustedEvent = function (name) {\n            return (indexOf(trustedEvents, name) !== -1);\n        },\n        /**\n         * @private\n         * @func\n         */\n        createElement = function (str) {\n            return doc.createElement(str);\n        },\n        makeEmptyFrame = function (str) {\n            var frame, div = createElement(DIV);\n            div[INNER_HTML] = str;\n            frame = div.children[0];\n            return DOMM(frame);\n        },\n        makeTree = function (str) {\n            var div = createElement(DIV);\n            div[INNER_HTML] = str;\n            return DOMM(div).children().remove().unwrap();\n        },\n        /**\n         * @private\n         * @func\n         */\n        matches = function (element, selector) {\n            var match, parent, temp, matchesSelector;\n            if (!selector || !element || element[NODE_TYPE] !== 1) {\n                return BOOLEAN_FALSE;\n            }\n            matchesSelector = element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector;\n            if (matchesSelector) {\n                return matchesSelector.call(element, selector);\n            }\n            // fall back to performing a selector:\n            parent = element[PARENT_NODE];\n            temp = !parent;\n            if (temp) {\n                parent = createElement(DIV);\n                parent[APPEND_CHILD](element);\n            }\n            // temp && tempParent.removeChild(element);\n            return !!posit(Sizzle(selector, parent), element);\n        },\n        createDocumentFragment = function () {\n            return doc.createDocumentFragment();\n        },\n        /**\n         * @private\n         * @func\n         */\n        createElements = function (tagName) {\n            return DOMM(foldl(gapSplit(tagName), function (memo, name) {\n                memo.push(createElement(name));\n                return memo;\n            }, []));\n        },\n        fragment = function (els_, handler) {\n            var frag, els = els_;\n            if (isFragment(els)) {\n                frag = els;\n            } else {\n                if (isInstance(els, DOMM[CONSTRUCTOR])) {\n                    els = els.unwrap();\n                }\n                if (!isArray(els)) {\n                    els = [els];\n                }\n                frag = createDocumentFragment();\n                duff(els, function (manager_) {\n                    var manager = returnsElementData(manager_),\n                        el = manager.unwrap();\n                    if (!isElement(el)) {\n                        return;\n                    }\n                    frag[APPEND_CHILD](el);\n                });\n            }\n            return frag;\n        },\n        htmlTextManipulator = function (attr) {\n            return function (string) {\n                var dom = this;\n                return isString(string) ? dom.eachCall(attrParody, string) : dom.map(function (manager) {\n                    return getInnard(manager, attr);\n                }).join(EMPTY_STRING);\n            };\n        },\n        horizontalTraverser = function (_idxChange) {\n            return attachPrevious(function (idxChange_) {\n                var domm = this,\n                    collected = [],\n                    list = domm.unwrap(),\n                    idxChange = _idxChange || idxChange_;\n                if (idxChange) {\n                    duff(list, function (idx_, el) {\n                        var parent = el[PARENT_NODE],\n                            idx = (indexOf(parent.children, el) + idxChange),\n                            item = parent.children[idx];\n                        if (item && !posit(list, item)) {\n                            add(collected, item);\n                        }\n                    });\n                } else {\n                    // didn't go anywhere\n                    collected = list;\n                }\n                return collected;\n            });\n        },\n        discernClassProperty = function (isProp) {\n            return isProp ? CLASSNAME : CLASS;\n        },\n        dataAttributeManipulator = function (el, _key, val, isProp, data) {\n            return trackedAttributeInterface(el, makeDataKey(_key), val, isProp, data);\n        },\n        scopedDomAttrManipulator = function (method, fn, isProp) {\n            return function (key, value) {\n                var context = this,\n                    el = context.unwrap(),\n                    hash = {},\n                    list = [];\n                intendedObject(key, value, function (_key, value) {\n                    var cachedIsProp = isProp,\n                        unCameledKey = unCamelCase(_key);\n                    if (unCameledKey === CLASS__NAME) {\n                        cachedIsProp = isString(el[CLASSNAME]);\n                        unCameledKey = discernClassProperty(cachedIsProp);\n                    }\n                    value = fn(el, unCameledKey, value, cachedIsProp, context);\n                    list.push(_key);\n                    if (value !== UNDEFINED) {\n                        hash[_key] = value;\n                    }\n                });\n                return list[LENGTH] === 1 ? hash[list[0]] : context;\n            };\n        },\n        domAttrManipulator = function (fn, isProp) {\n            // cant wrap in each because need to return custom data\n            return function (key, value) {\n                var list = [],\n                    context = this,\n                    hash = {},\n                    domList = context.unwrap();\n                // moved to outside because iterating over objects is more\n                // time consuming than iterating over a straight list\n                intendedObject(key, value, function (_key, val) {\n                    // var __keys = gapSplit(__key);\n                    list.push(_key);\n                    context.duff(function (manager) {\n                        var el = manager.unwrap(),\n                            value, cachedIsProp = isProp,\n                            unCameledKey = unCamelCase(_key);\n                        if (unCameledKey === CLASS__NAME) {\n                            cachedIsProp = isString(el[CLASSNAME]);\n                            unCameledKey = discernClassProperty(cachedIsProp);\n                        }\n                        value = fn(el, unCameledKey, val, cachedIsProp, manager);\n                        if (value !== UNDEFINED) {\n                            hash[_key] = value;\n                        }\n                    });\n                });\n                return list[LENGTH] === 1 ? hash[list[0]] : context;\n            };\n        },\n        attachPrevious = function (fn) {\n            return function () {\n                var prev = this;\n                // ensures it's still a dom object\n                var result = fn.apply(this, arguments);\n                // don't know if we went up or down, so use null as context\n                var obj = new DOMM[CONSTRUCTOR](result, NULL, BOOLEAN_TRUE);\n                obj._previous = prev;\n                return obj;\n            };\n        },\n        // coordinates\n        covers = function (element, coords) {\n            var _clientRect = clientRect(element),\n                bottom = _clientRect[BOTTOM],\n                right = _clientRect[RIGHT],\n                left = _clientRect[LEFT],\n                tippytop = _clientRect[TOP],\n                x = coords.x,\n                y = coords.y,\n                ret = BOOLEAN_FALSE;\n            if (x > left && x < right && y > tippytop && y < bottom) {\n                ret = BOOLEAN_TRUE;\n            }\n            return ret;\n        },\n        center = function (clientRect) {\n            return {\n                x: clientRect[LEFT] + (clientRect[WIDTH] / 2),\n                y: clientRect[TOP] + (clientRect[HEIGHT] / 2)\n            };\n        },\n        distance = function (a, b) {\n            var xdiff = a.x - b.x,\n                ydiff = a.y - b.y;\n            return Math.sqrt((xdiff * xdiff) + (ydiff * ydiff));\n        },\n        closer = function (center, current, challenger) {\n            return distance(center, current) < distance(center, challenger);\n        },\n        createSelector = function (domm, args, fn) {\n            var fun, selector, name = args.shift();\n            if (isString(args[0]) || args[0] == NULL) {\n                selector = args.shift();\n            }\n            if (isFunction(args[0])) {\n                fn = bind(fn, domm);\n                fun = args[0];\n                duff(gapSplit(name), function (nme) {\n                    var split = eventToNamespace(nme),\n                        captures = BOOLEAN_FALSE,\n                        namespaceSplit = nme.split(PERIOD),\n                        nm = namespaceSplit.shift(),\n                        namespace = namespaceSplit.join(PERIOD);\n                    if (nm[0] === '_') {\n                        nm = nm.slice(1);\n                        captures = BOOLEAN_TRUE;\n                    }\n                    fn(nm, namespace, selector, fun, captures);\n                });\n            }\n        },\n        // ensureOne = function (fn) {\n        //     return function () {\n        //         if (this[LENGTH]()) {\n        //             fn.apply(this, arguments);\n        //         }\n        //         return this;\n        //     };\n        // },\n        expandEventListenerArguments = function (fn) {\n            return function () {\n                var args, obj, selector, domm = this;\n                // if there's nothing selected, then do nothing\n                args = toArray(arguments);\n                obj = args.shift();\n                if (isObject(obj)) {\n                    if (isString(args[0])) {\n                        selector = args.shift();\n                    }\n                    each(obj, function (key, handlers) {\n                        createSelector(domm, [key, selector, handlers].concat(args), fn);\n                    });\n                } else {\n                    args.unshift(obj);\n                    createSelector(domm, args, fn);\n                }\n            };\n        },\n        validateEvent = function (evnt, el, name_) {\n            return !isObject(evnt) ? {\n                type: evnt || name_,\n                bubbles: BOOLEAN_FALSE,\n                eventPhase: 2,\n                cancelable: BOOLEAN_FALSE,\n                defaultPrevented: BOOLEAN_FALSE,\n                data: EMPTY_STRING,\n                isTrusted: BOOLEAN_FALSE,\n                timeStamp: now(),\n                target: el\n            } : evnt;\n        },\n        isCapturing = function (evnt) {\n            var capturing = BOOLEAN_FALSE,\n                eventPhase = evnt.eventPhase;\n            if (eventPhase === 1) {\n                capturing = BOOLEAN_TRUE;\n            }\n            if (eventPhase === 2 && !evnt.bubbles && isElement(evnt.srcElement)) {\n                capturing = BOOLEAN_TRUE;\n            }\n            return capturing;\n        },\n        findMatch = function (el, target, selector) {\n            var parent, found = NULL;\n            if (selector && isString(selector)) {\n                parent = target;\n                while (parent && !found && isElement(parent) && parent !== el) {\n                    if (matches(parent, selector)) {\n                        found = parent;\n                    }\n                    parent = parent[PARENT_NODE];\n                }\n            }\n            return found;\n        },\n        _eventExpander = wrap({\n            ready: 'DOMContentLoaded',\n            deviceorientation: 'deviceorientation mozOrientation',\n            fullscreenalter: 'webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange',\n            hover: 'mouseenter mouseleave',\n            forcetouch: 'webkitmouseforcewillbegin webkitmouseforcedown webkitmouseforceup webkitmouseforcechanged'\n        }, function (val) {\n            return gapSplit(val);\n        }),\n        distilledEventName = foldl(_eventExpander, function (memo, arr, key) {\n            duff(arr, function (item) {\n                memo[item] = key;\n            });\n            return memo;\n        }, {}),\n        eventExpander = function (fn_) {\n            return function (nme) {\n                var fn = bind(fn_, this);\n                duff(gapSplit(_eventExpander[nme] || nme), function (name) {\n                    fn(name, nme);\n                });\n            };\n        },\n        addEventListener = expandEventListenerArguments(function (name, namespace, selector, callback, capture) {\n            var manager = this;\n            return isFunction(callback) ? _addEventListener(manager, name, namespace, selector, callback, capture) : manager;\n        }),\n        addEventListenerOnce = expandEventListenerArguments(function (types, namespace, selector, callback, capture) {\n            var _callback, manager = this;\n            return isFunction(callback) && _addEventListener(manager, types, namespace, selector, (_callback = once(function () {\n                _removeEventListener(manager, types, namespace, selector, _callback, capture);\n                return callback.apply(this, arguments);\n            })), capture);\n        }),\n        removeEventListener = expandEventListenerArguments(function (name, namespace, selector, handler, capture) {\n            var manager = this;\n            return isFunction(handler) ? _removeEventListener(manager, name, namespace, selector, handler, capture) : manager;\n        }),\n        _addEventListener = function (manager, types, namespace, selector, fn_, capture) {\n            var handleObj, eventHandler, el = manager.unwrap(),\n                events = manager.directive(EVENTS),\n                elementHandlers = events.elementHandlers = events.elementHandlers || {},\n                fn = bind(fn_, el);\n            duff(gapSplit(types), eventExpander(function (name, passedName) {\n                var foundDuplicate, handlerKey = capture + COLON + name,\n                    handlers = events[HANDLERS][handlerKey] = events[HANDLERS][handlerKey] || SortedCollection(),\n                    mainHandler = elementHandlers[handlerKey];\n                if (!mainHandler) {\n                    eventHandler = function (e) {\n                        return eventDispatcher(manager, e.type, e, isCapturing(e));\n                    };\n                    mainHandler = elementHandlers[handlerKey] = {\n                        fn: eventHandler,\n                        __delegateCount: 0,\n                        events: events,\n                        currentEvent: NULL,\n                        capturing: capture\n                    };\n                    el.addEventListener(name, eventHandler, capture);\n                }\n                foundDuplicate = handlers.find(function (obj) {\n                    // remove any duplicates\n                    if (fn_ === obj.handler && obj.namespace === namespace && selector === obj.selector) {\n                        return BOOLEAN_TRUE;\n                    }\n                });\n                if (foundDuplicate) {\n                    return;\n                }\n                addEventQueue({\n                    id: ++eventIdIncrementor,\n                    valueOf: returnsId,\n                    fn: fn,\n                    handler: fn_,\n                    persist: BOOLEAN_TRUE,\n                    disabled: BOOLEAN_FALSE,\n                    list: handlers,\n                    namespace: namespace,\n                    mainHandler: mainHandler,\n                    selector: selector,\n                    name: name,\n                    passedName: passedName\n                });\n            }));\n            return manager;\n        },\n        // expandEventListenerArguments(function (types, namespace, selector, fn, capture) {\n        //         return this.duff(function (el) {\n        //             var _fn = once(function () {\n        //                 _removeEventListener(el, types, namespace, selector, _fn, capture);\n        //                 return fn.apply(this, arguments);\n        //             });\n        //             _addEventListener(el, types, namespace, selector, _fn, capture);\n        //         });\n        //     }),\n        // ____addEventListener = expandEventListenerArguments(function (name, namespace, selector, callback, capture) {\n        //     var dom = this;\n        //     return isFunction(callback) ? dom.duff(function (manager) {\n        //         _addEventListener(manager, name, namespace, selector, callback, capture);\n        //     }) && dom : dom;\n        // }),\n        eventToNamespace = function (evnt) {\n            if (!isString(evnt)) {\n                evnt = evnt.type;\n            }\n            evnt = evnt.split(PERIOD);\n            var evntName = evnt.shift();\n            return [evntName, evnt.sort().join(PERIOD)];\n        },\n        SortedCollection = factories.SortedCollection,\n        eventIdIncrementor = 0,\n        returnsId = function () {\n            return this.id;\n        },\n        appendChild = function (el) {\n            var manager = returnsElementData(el),\n                cachedRemoving = manager.isRemoving || BOOLEAN_FALSE;\n            if (!cachedRemoving) {\n                manager.isRemoving = BOOLEAN_TRUE;\n                this.unwrap()[APPEND_CHILD](manager.unwrap());\n                manager.isRemoving = cachedRemoving;\n            }\n        },\n        attributeParody = function (method) {\n            return function (one, two) {\n                return attributeInterface[method](this.unwrap(), one, two);\n            };\n        },\n        getInnard = function (manager, attribute, isIframe) {\n            var win, doc, el = manager[TARGET],\n                returnValue = EMPTY_STRING;\n            if (manager.isIframe && manager.isFriendly) {\n                win = el.contentWindow;\n                if (win) {\n                    doc = win[DOCUMENT];\n                    returnValue = doc.body ? doc.body[PARENT_NODE].outerHTML : EMPTY_STRING;\n                }\n            } else {\n                returnValue = manager[TARGET][attribute];\n            }\n            return returnValue;\n        },\n        setInnard = function (manager, attribute, value) {\n            var win, doc, el = manager[TARGET];\n            if (manager.isIframe && manager.isFriendly) {\n                win = el.contentWindow;\n                if (win) {\n                    doc = win[DOCUMENT];\n                    doc.open();\n                    doc.write(value);\n                    doc.close();\n                }\n            } else {\n                el[attribute] = value || EMPTY_STRING;\n            }\n        },\n        innardManipulator = function (attribute) {\n            return function (value) {\n                var manager = this,\n                    returnValue = manager,\n                    isIframe = manager.isIframe;\n                if (value === UNDEFINED) {\n                    returnValue = getInnard(manager, attribute);\n                } else {\n                    setInnard(manager, attribute, value);\n                }\n                return returnValue;\n            };\n        },\n        testIframe = function (el) {\n            var returnValue = BOOLEAN_FALSE;\n            return wraptry(function () {\n                var ret = el.contentWindow.document;\n                return BOOLEAN_TRUE;\n            }, function (e) {\n                return BOOLEAN_FALSE;\n            });\n            // don't use finally handler here\n        },\n        eventDispatcher = function (manager, name, e, capturing_) {\n            var capturing = !!capturing_;\n            return factories.Events[CONSTRUCTOR][PROTOTYPE][DISPATCH_EVENT].call(manager, capturing + COLON + name, validateEvent(e, manager.target, name), capturing);\n        },\n        DomManager = factories.Events.extend('DomManager', {\n            constructor: function (el) {\n                var manager = this;\n                manager[TARGET] = el;\n                manager.test();\n                return manager;\n            },\n            test: function () {\n                var manager = this,\n                    el = manager[TARGET];\n                manager.markElement();\n                manager.isDocument = isDocument(el);\n                manager.isWindow = isWindow(el);\n                manager.isFragment = isFragment(el);\n            },\n            markElement: function () {\n                var isIframe, manager = this,\n                    el = manager[TARGET];\n                manager.isElement = isElement(el);\n                isIframe = manager.isIframe = tag(el, 'iframe');\n                if (isIframe) {\n                    manager.isFriendly = testIframe(el);\n                }\n            },\n            wrap: function () {\n                return $(this);\n            },\n            on: addEventListener,\n            addEventListener: addEventListener,\n            once: addEventListenerOnce,\n            off: removeEventListener,\n            removeEventListener: removeEventListener,\n            isValidDomManager: BOOLEAN_TRUE,\n            appendChild: appendChild,\n            append: appendChild,\n            getAttribute: attributeParody('read'),\n            setAttribute: attributeParody('write'),\n            removeAttribute: attributeParody('remove'),\n            data: scopedDomAttrManipulator(DATA, dataAttributeManipulator),\n            attr: scopedDomAttrManipulator('attr', trackedAttributeInterface),\n            prop: scopedDomAttrManipulator('prop', trackedAttributeInterface, BOOLEAN_TRUE),\n            html: innardManipulator(INNER_HTML),\n            text: innardManipulator(INNER_TEXT),\n            addClass: attributeApplication(addClass, UNDEFINED, WRITE),\n            removeClass: attributeApplication(removeClass, UNDEFINED, WRITE),\n            toggleClass: attributeApplication(toggleClass, UNDEFINED, WRITE),\n            resetEvents: noop,\n            applyStyle: function (key, value) {\n                var manager = this;\n                if (manager.isElement) {\n                    manager[TARGET][STYLE][key] = value;\n                }\n                return manager;\n            },\n            style: function (key, value) {\n                return intendedObject(key, value, this.applyStyle, this);\n            },\n            remove: function () {\n                var el, parent, manager = this,\n                    cachedRemoving = manager.isRemoving || BOOLEAN_FALSE;\n                if (!cachedRemoving) {\n                    el = manager.unwrap();\n                    parent = el[PARENT_NODE];\n                    manager.isRemoving = BOOLEAN_TRUE;\n                    result(parent, REMOVE_CHILD, el);\n                    manager.isRemoving = cachedRemoving;\n                }\n            },\n            hasClass: function (classes) {\n                var newClasses = gapSplit(classes);\n                return newClasses[LENGTH] && !managerContainsClass(newClasses)(this);\n            },\n            changeClass: attributeApplication(changeClass, UNDEFINED, WRITE),\n            booleanClass: attributeApplication(booleanClass, UNDEFINED, WRITE),\n            find: function (selector) {\n                return $(this[TARGET].querySelectorAll(selector), this.wrap());\n            },\n            createEvent: function (type, original, opts) {\n                return new DomEvent[CONSTRUCTOR](original, {\n                    target: this.target,\n                    capturing: toBoolean(type.split(COLON)[0]),\n                    arg2: opts\n                });\n            },\n            unwrap: function () {\n                return this[TARGET];\n            },\n            get: function (where, defaults) {\n                var events = this,\n                    attrs = events.directive(ATTRIBUTES),\n                    found = attrs[where] = attrs[where] || defaults();\n                return found;\n            },\n            // revisit this\n            queueHandler: function (evnt, handler, list) {\n                var selectorsMatch, ctx, domManager = this,\n                    originalTarget = evnt.currentTarget,\n                    el = domManager[TARGET],\n                    mainHandler = handler.mainHandler;\n                domManager.stashed = originalTarget;\n                if (mainHandler.currentEvent) {\n                    // cancel this event because this stack has already been called\n                    exception({\n                        message: 'queue prevented because this element is already being dispatched with the same event'\n                    });\n                    return;\n                }\n                mainHandler.currentEvent = handler;\n                if (!handler) {\n                    return;\n                }\n                if (handler.selector) {\n                    ctx = findMatch(el, evnt.target, handler.selector);\n                    if (ctx) {\n                        e.currentTarget = ctx;\n                    } else {\n                        mainHandler.currentEvent = NULL;\n                        return;\n                    }\n                }\n                return BOOLEAN_TRUE;\n            },\n            dispatchEvent: cannotTrust(function (name, e, capturing_) {\n                return eventDispatcher(this, name, e, capturing_);\n            }),\n            unQueueHandler: function (e, handler, list) {\n                var domManager = this;\n                e.currentTarget = domManager.stashed;\n                domManager.stashed = NULL;\n                handler.mainHandler.currentEvent = NULL;\n            },\n            toJSON: function () {\n                var children, obj, node = this.unwrap();\n                if (!canBeProcessed(node)) {\n                    return node;\n                }\n                children = DOMM(node).children().toJSON();\n                obj = {\n                    tag: tag(node)\n                };\n                if (children[LENGTH]) {\n                    obj.children = children;\n                }\n                if (node.innerText) {\n                    obj.innerText = node.innerText;\n                }\n                duff(node.directive(DATA), function (attr) {\n                    obj[camelCase(attr[LOCAL_NAME])] = attr.nodeValue;\n                });\n                return obj;\n            }\n        }, BOOLEAN_TRUE),\n        ret = app.defineDirective('DomManager', function () {\n            return DomManager();\n        }),\n        addEventQueue = function (obj) {\n            var mainHandler = obj.mainHandler,\n                selector = obj.selector;\n            if (!mainHandler.currentEvent) {\n                if (selector) {\n                    obj.list.splice(mainHandler[DELEGATE_COUNT]++, 0, obj);\n                } else {\n                    obj.list.push(obj);\n                }\n            } else {\n                mainHandler[ADD_QUEUE].push(obj);\n            }\n        },\n        removeEventQueue = function (obj, idx) {\n            var gah, mainHandler = obj.mainHandler,\n                list = obj.list,\n                selector = obj.selector;\n            if (!mainHandler.currentEvent) {\n                if (!obj.isDestroyed) {\n                    obj.isDestroyed = BOOLEAN_TRUE;\n                    idx = idx === UNDEFINED ? list.indexOf(obj) : idx;\n                    if (idx + 1) {\n                        if (selector) {\n                            mainHandler[DELEGATE_COUNT]--;\n                        }\n                        gah = list.splice(idx, 1);\n                    }\n                    obj.list = NULL;\n                }\n            } else {\n                if (obj.persist) {\n                    mainHandler[REMOVE_QUEUE].push(obj);\n                }\n            }\n            obj.persist = BOOLEAN_FALSE;\n        },\n        removeEvent = function (obj) {\n            var mainHandler = obj.mainHandler;\n            if (obj.selector) {\n                mainHandler[DELEGATE_COUNT] = Math.max(mainHandler[DELEGATE_COUNT] - 1, 0);\n            }\n            _.remove(obj.list, obj);\n        },\n        _removeEventListener = function (el, name, namespace, selector, handler, capture_) {\n            var data = elementData.ensure(el, DOMM_STRING, DomManager),\n                directive = data.directive(EVENTS),\n                removeFromList = function (list, name) {\n                    return list && list.duffRight(function (obj) {\n                        if ((!name || name === obj[NAME]) && (!handler || obj.handler === handler) && (!namespace || obj.namespace === namespace) && (!selector || obj.selector === selector)) {\n                            removeEventQueue(obj);\n                        }\n                    });\n                };\n            return name ? removeFromList(directive[HANDLERS][name], name) : each(directive[HANDLERS][!!capture_], removeFromList);\n        },\n        /**\n         * @class DOMM\n         * @augments Model\n         * @augments Collection\n         */\n        fixHooks = {\n            // Includes some event props shared by KeyEvent and MouseEvent\n            props: gapSplit(\"data altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\"),\n            fixedHooks: {},\n            keyHooks: {\n                props: gapSplit(\"char charCode key keyCode\"),\n                filter: function (evnt, original) {\n                    var charCode;\n                    // Add which for key evnts\n                    if (evnt.which == NULL) {\n                        charCode = original.charCode;\n                        evnt.which = charCode != NULL ? charCode : original.keyCode;\n                    }\n                    return evnt;\n                }\n            },\n            forceHooks: {\n                props: [],\n                filter: function (evnt, original) {\n                    evnt.value = (original.webkitForce / 3) || original;\n                    return evnt;\n                }\n            },\n            mouseHooks: {\n                props: gapSplit(\"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\"),\n                filter: function (evnt, original) {\n                    var eventDoc, doc, body,\n                        button = original.button;\n                    // Calculate pageX/Y if missing and clientX/Y available\n                    if (evnt.pageX == NULL && original.clientX != NULL) {\n                        evntDoc = evnt.target.ownerDocument || doc;\n                        doc = evntDoc.documentElement;\n                        body = evntDoc[BODY];\n                        evnt.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n                        evnt.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n                    }\n                    evnt.movementX = original.movementX || 0;\n                    evnt.movementY = original.movementY || 0;\n                    evnt.layerX = original.layerX || 0;\n                    evnt.layerY = original.layerY || 0;\n                    evnt.x = original.x || 0;\n                    evnt.y = original.y || 0;\n                    // Add which for click: 1 === left; 2 === middle; 3 === right\n                    // Note: button is not normalized, so don't use it\n                    if (!evnt.which && button !== UNDEFINED) {\n                        evnt.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));\n                    }\n                    return evnt;\n                }\n            },\n            make: function (evnt, originalEvent, data) {\n                var doc, target, val, i, prop, copy, type = originalEvent.type,\n                    // Create a writable copy of the event object and normalize some properties\n                    fixHook = fixHooks.fixedHooks[type];\n                if (!fixHook) {\n                    fixHooks.fixedHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : rforceEvent.test(type) ? this.forceHooks : {};\n                }\n                copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;\n                i = copy[LENGTH];\n                while (i--) {\n                    prop = copy[i];\n                    val = originalEvent[prop];\n                    if (val != NULL) {\n                        evnt[prop] = val;\n                    }\n                }\n                evnt.originalType = originalEvent.type;\n                // Support: Cordova 2.5 (WebKit) (#13255)\n                // All events should have a target; Cordova deviceready doesn't\n                // ie also does not have a target... so use current target\n                target = evnt.target || (evnt.view ? evnt.view.event.currentTarget : event && event.currentTarget) || evnt.delegateTarget;\n                if (!target) {\n                    target = evnt.target = doc;\n                }\n                // Support: Safari 6.0+, Chrome<28\n                // Target should not be a text node (#504, #13143)\n                if (target[NODE_TYPE] === 3) {\n                    evnt.target = target[PARENT_NODE];\n                }\n                if (isFunction(fixHook.filter)) {\n                    fixHook.filter(evnt, originalEvent);\n                }\n                evnt.type = distilledEventName[originalEvent.type] || originalEvent.type;\n                evnt.data = originalEvent.data || data || EMPTY_STRING;\n                evnt.isImmediatePropagationStopped = evnt.isPropagationStopped = evnt.isDefaultPrevented = BOOLEAN_FALSE;\n                // special\n                if (evnt.type === 'fullscreenchange') {\n                    doc = evnt.target;\n                    if (isWindow(doc)) {\n                        doc = doc[DOCUMENT];\n                    } else {\n                        while (doc && !isDocument(doc) && doc[PARENT_NODE]) {\n                            doc = doc[PARENT_NODE];\n                        }\n                    }\n                    evnt.fullscreenDocument = doc;\n                    if (isDocument(doc)) {\n                        evnt.isFullScreen = (doc.fullScreen || doc.webkitFullscreenElement || doc.mozFullScreenElement || doc.fullscreenElement) ? BOOLEAN_TRUE : BOOLEAN_FALSE;\n                    }\n                }\n                evnt.isTrusted = _.has(originalEvent, 'isTrusted') ? originalEvent.isTrusted : !DO_NOT_TRUST;\n                return evnt;\n            }\n        },\n        DomEvent = factories.ObjectEvent.extend('DomEvent', {\n            constructor: function (evnt, opts) {\n                var e = this;\n                if (isInstance(evnt, DomEvent[CONSTRUCTOR])) {\n                    return evnt;\n                }\n                e.originalEvent = evnt;\n                e.delegateTarget = opts.target;\n                fixHooks.make(e, evnt, opts.arg2);\n                e.capturing = opts.capturing === UNDEFINED ? isCapturing(e) : opts.capturing;\n                return e;\n            },\n            getNamespace: function () {\n                return this.capturing + COLON + this.originalType;\n            },\n            preventDefault: function () {\n                var e = this.originalEvent;\n                this.isDefaultPrevented = BOOLEAN_TRUE;\n                if (e && e.preventDefault) {\n                    e.preventDefault();\n                }\n            },\n            stopPropagation: function () {\n                var e = this.originalEvent;\n                this.isPropagationStopped = BOOLEAN_TRUE;\n                if (e && e.stopPropagation) {\n                    e.stopPropagation();\n                }\n            },\n            stopImmediatePropagation: function () {\n                var e = this.originalEvent;\n                this.isImmediatePropagationStopped = BOOLEAN_TRUE;\n                if (e && e.stopImmediatePropagation) {\n                    e.stopImmediatePropagation();\n                }\n                this.stopPropagation();\n            }\n        }, BOOLEAN_TRUE),\n        eq = _.eq,\n        objectMatches = _.matches,\n        createDomFilter = function (filtr) {\n            return isFunction(filtr) ? filtr : (isString(filtr) ? (filterExpressions[filtr] || function (item) {\n                return matches(item, filtr);\n            }) : (isNumber(filtr) ? function (el, idx) {\n                return idx === filtr;\n            } : (isObject(filtr) ? objectMatches(filtr) : function () {\n                return BOOLEAN_TRUE;\n            })));\n        },\n        unwrapsOnLoop = function (fn) {\n            return function (manager, idx, list) {\n                return fn(manager.unwrap(), idx, list);\n            };\n        },\n        dataReconstructor = function (list, fn) {\n            return foldl(list, function (memo, arg1, arg2, arg3) {\n                if (fn(arg1, arg2, arg3)) {\n                    memo.push(arg1);\n                }\n                return memo;\n            }, []);\n        },\n        domFilter = function (items, filtr) {\n            var filter = createDomFilter(filtr);\n            return dataReconstructor(items, unwrapsOnLoop(filter));\n        },\n        dimFinder = function (element, doc, win) {\n            return function (num) {\n                var ret, el = this[INDEX](num);\n                if (isElement(el)) {\n                    ret = clientRect(el)[element];\n                } else {\n                    if (isDocument(el) && el[BODY]) {\n                        ret = el[BODY][doc];\n                    } else {\n                        if (isWindow(el)) {\n                            ret = el[win];\n                        }\n                    }\n                }\n                return ret || 0;\n            };\n        },\n        dommFind = attachPrevious(function (str) {\n            var passedString = isString(str),\n                push = function (el) {\n                    matchers.push(el);\n                };\n            return foldl(this.unwrap(), function (memo, el) {\n                if (passedString) {\n                    duff(Sizzle(str, el.unwrap()), function (el) {\n                        memo.push(returnsElementData(el));\n                    });\n                } else {\n                    memo.push(returnsElementData(el));\n                }\n                return memo;\n            }, []);\n        }),\n        makeDataKey = function (_key) {\n            var dataString = 'data-',\n                key = _key,\n                sliced = _key.slice(0, 5);\n            if (dataString !== sliced) {\n                key = dataString + _key;\n            }\n            return key;\n        },\n        canBeProcessed = function (item) {\n            return isElement(item) || isWindow(item) || isDocument(item) || isFragment(item);\n        },\n        append = function (els, clone) {\n            var fragmentResult, domm = this,\n                domManager = domm.index(0);\n            if (domManager) {\n                if (!clone) {\n                    fragmentResult = fragment(els);\n                    domManager.appendChild(fragmentResult);\n                }\n            }\n        },\n        // append = function (els) {\n        //     var context = this,\n        //         data = DOMM(els);\n        //     data.duff(function (manager) {\n        //         var cachedRemoving = manager.isRemoving;\n        //         if (!cachedRemoving) {\n        //             manager.isRemoving = BOOLEAN_TRUE;\n        //             context.element()[APPEND_CHILD](manager.unwrap());\n        //             manager.isRemoving = cachedRemoving;\n        //         }\n        //     });\n        // },\n        prependChild = function (els) {\n            return this.insertAt(els, 0);\n        },\n        returnsElementData = function (element) {\n            return element && element.isValidDomManager ? element : elementData.ensure(element, DOMM_STRING, DomManager);\n        },\n        AttributeManager = Collection.extend('AttributeManager', {}, BOOLEAN_TRUE),\n        makeQueues = function (list, queuedData_) {\n            return AttributeManager(queuedData_ || map(list, returnsElementData));\n        },\n        applyQueueManager = function (list) {},\n        _makeQueueManager = function () {\n            var queues = makeQueues(this.unwrap(), this._data);\n            console.log(queues);\n            return queues;\n        },\n        _applyQueueManager = function () {\n            return applyQueues(this.unwrap(), this._data);\n        },\n        loadData = function (data, items) {\n            return data || foldl(items || this.unwrap(), returnsElementData, []);\n        },\n        Sizzle = function (str, ctx) {\n            return (ctx || doc).querySelectorAll(str);\n        },\n        exportResult = _.exports({\n            covers: covers,\n            center: center,\n            closer: closer,\n            distance: distance,\n            css: css,\n            box: box,\n            fragment: fragment,\n            isElement: isElement,\n            isWindow: isWindow,\n            isDocument: isDocument,\n            isFragment: isFragment,\n            createElement: createElement,\n            createElements: createElements,\n            createDocumentFragment: createDocumentFragment,\n            Sizzle: Sizzle,\n            unitToNumber: unitToNumber,\n            numberToUnit: numberToUnit\n        }),\n        // removeChild = eachProc(),\n        setupDomContentLoaded = function (ctx) {\n            var $doc = DOMM(ctx),\n                docEl = $doc[INDEX](),\n                docData = returnsElementData(docEl),\n                handler = bind(str, $doc);\n            if (docData.isReady) {\n                // make it async\n                _.AF.once(function () {\n                    handler($, docData.DOMContentLoadedEvent);\n                });\n                els = dom.unwrap();\n            } else {\n                dom = $doc.on('DOMContentLoaded', function (e) {\n                    handler($, e);\n                });\n                els = dom.unwrap();\n            }\n            return $doc;\n        },\n        applyToEach = function (method) {\n            return function (one, two, three, four, five) {\n                return this.duff(function (manager) {\n                    manager[method](one, two, three, four, five);\n                });\n            };\n        },\n        DOMM = factories[DOMM_STRING] = factories.Collection.extend(DOMM_STRING, extend({\n            /**\n             * @func\n             * @name DOMM#constructor\n             * @param {String | Node | Function} str - string to query the dom with, or a function to run on document load, or an element to wrap in a DOMM instance\n             * @returns {DOMM} instance\n             */\n            constructor: function (str, ctx, isValid, validContext) {\n                var isArrayResult, els = str,\n                    dom = this,\n                    context = dom.context = validContext ? ctx.index(0) : returnsElementData(ctx || win[DOCUMENT]),\n                    unwrapped = context.unwrap();\n                if (isFunction(str)) {\n                    if (isDocument(unwrapped)) {\n                        return setupDomContentLoaded(unwrapped);\n                    }\n                } else {\n                    if (!isValid) {\n                        if (isString(str)) {\n                            if (str[0] === '<') {\n                                els = makeTree(str);\n                            } else {\n                                els = map(Sizzle(str, unwrapped), returnsElementData);\n                            }\n                        } else {\n                            els = str;\n                            if (DomManager.isInstance(els)) {\n                                els = [els];\n                            } else {\n                                if (canBeProcessed(els)) {\n                                    els = [returnsElementData(els)];\n                                } else {\n                                    els = els && map(els, returnsElementData);\n                                }\n                            }\n                        }\n                    }\n                    dom.swap(els);\n                }\n                return dom;\n            },\n            loadData: loadData,\n            // swap: function (list) {\n            //     // var domm = this;\n            //     // domm._data = loadData(data, list || []);\n            //     return Collection[CONSTRUCTOR][PROTOTYPE].swap.apply(domm, arguments);\n            // },\n            push: function (el) {\n                this.unwrap().push(returnsElementData(el));\n            },\n            elements: function () {\n                // to array of DOMManagers\n                return map(this.unwrap(), function (manager) {\n                    // to element\n                    return manager.unwrap();\n                });\n            },\n            /**\n             * @func\n             * @name DOMM#isWin\n             * @description asks if the first or specified index of the object is a window type object\n             * @returns {Boolean}\n             */\n            isWindow: function (num) {\n                return isWindow(this[ELEMENT](num || 0));\n            },\n            isElement: function (num) {\n                return isElement(this[ELEMENT](num || 0));\n            },\n            /**\n             * @func\n             * @name DOMM#isDoc\n             * @description asks if the first or specified index of the object is a document type object\n             * @returns {Boolean}\n             */\n            isDocument: function (num) {\n                return isDocument(this[ELEMENT](num || 0));\n            },\n            isFragment: function (num) {\n                return isFragment(this[ELEMENT](num || 0));\n            },\n            fragment: attachPrevious(function (els) {\n                return fragment(els || this);\n            }),\n            /**\n             * @func\n             * @name DOMM#filter\n             * @param {String|Function|Object} filtr - filter variable that will filter by matching the object that is passed in, or by selector if it is a string, or simply with a custom function\n             * @returns {DOMM} new DOMM instance object\n             */\n            filter: attachPrevious(function (filter) {\n                return domFilter(this.unwrap(), filter);\n            }),\n            /**\n             * @func\n             * @name DOMM#find\n             * @param {String} str - string to use sizzle to find against\n             * @returns {DOMM} matching elements\n             */\n            find: dommFind,\n            $: dommFind,\n            /**\n             * @func\n             * @name DOMM#children\n             * @param {Number} [eq] - index of the children to gather. If none is provided, then all children will be added\n             * @returns {DOMM} all / matching children\n             */\n            children: attachPrevious(function (eq) {\n                var dom = this,\n                    items = dom.unwrap(),\n                    filter = createDomFilter(eq);\n                return foldl(items, function (memo, el_) {\n                    var el = el_.unwrap();\n                    return foldl(el.children || el.childNodes, function (memo, child, idx, children) {\n                        if (filter(child, idx, children)) {\n                            memo.push(returnsElementData(child));\n                        }\n                        return memo;\n                    }, memo);\n                }, []);\n            }),\n            /**\n             * @func\n             * @name DOMM#offAll\n             * @returns {DOMM} instance\n             */\n            resetEvents: applyToEach('resetEvents'),\n            // resetEvents: eachProc(function (manager) {\n            //     // var el = manager.unwrap();\n            //     // each(data.handlers, function (key, fn, eH) {\n            //     //     // var wasCapt, split = key.split(COLON);\n            //     //     // eH[key] = UNDEFINED;\n            //     //     // wasCapt = data[_EVENTS][split[0]];\n            //     //     // if (wasCapt) {\n            //     //     //     wasCapt[split[1]] = [];\n            //     //     // }\n            //     // });\n            //     // elementData.remove(el);\n            // }),\n            /**\n             * @name DOMM#off\n             * @param {String|Function} type - event type\n             * @param {Function} handler - specific event handler to be removed\n             * @returns {DOMM} instnace\n             */\n            on: applyToEach('addEventListener'),\n            off: applyToEach('removeEventListener'),\n            once: applyToEach('once'),\n            addEventListener: applyToEach('addEventListener'),\n            removeEventListener: applyToEach('removeEventListener'),\n            dispatchEvent: applyToEach('dispatchEvent'),\n            /**\n             * @func\n             * @name DOMM#once\n             * @param {String} space delimited list of event names to attach handlers to\n             * @param {Function} fn - handler to put on the event loop\n             * @returns {DOMM} instance\n             */\n            /**\n             * @func\n             * @name DOMM#css\n             * @param {...*} splat of objects and key value pairs that create a single object to be applied to the element\n             * @returns {DOMM} instance\n             */\n            css: function (key, value) {\n                var dom = this,\n                    ret = css(dom.unwrap(), key, value);\n                if (ret == NULL) {\n                    ret = dom;\n                }\n                return ret;\n            },\n            style: applyToEach('style'),\n            // style: function (key, value) {\n            //     intendedObject(key, value, this.applyStyle, this);\n            // },\n            // style: ensureOne(function (key, value) {\n            //     style(this.unwrap(), key, value);\n            //     return this;\n            // }),\n            /**\n             * @func\n             * @name DOMM#allDom\n             * @returns {Boolean} value indicating whether or not there were any non dom elements found in the collection\n             */\n            allElements: function () {\n                var count = 0,\n                    length = this[LENGTH](),\n                    result = length && find(this.unwrap(), negate(function (manager) {\n                        return isElement(manager.unwrap());\n                    }));\n                return length && result === UNDEFINED;\n            },\n            /**\n             * @func\n             * @name DOMM#height\n             * @returns {Number} height of the first object, adjusting for the different types of possible objects such as dom element, document or window\n             */\n            height: dimFinder(HEIGHT, 'scrollHeight', INNER_HEIGHT),\n            /**\n             * @func\n             * @name DOMM#width\n             * @returns {Number} width of the first object, adjusting for the different types of possible objects such as dom element, document or window\n             */\n            width: dimFinder(WIDTH, 'scrollWidth', INNER_WIDTH),\n            /**\n             * @func\n             * @name DOMM#getStyle\n             * @retuns {Object} the get computed result or a UNDEFINED object if first or defined index is not a dom element and therefore cannot have a style associated with it\n             */\n            getStyle: function (eq) {\n                var ret = {},\n                    first = this.index();\n                if (first && isElement(first)) {\n                    ret = getComputed(first, this.context);\n                }\n                return ret;\n            },\n            /**\n             * @func\n             * @name DOMM#data\n             * @param {...*} splat of objects and key value pairs that create a single object to be applied to the element\n             * @returns {Object|*} can return the value that is asked for by the initial function call\n             */\n            data: domAttrManipulator(dataAttributeManipulator),\n            /**\n             * @func\n             * @name DOMM#attr\n             * @param {...*} splat of objects and key value pairs that create a single object to be applied to the element\n             * @returns {DOMM|*} if multiple attributes were requested then a plain hash is returned, otherwise the DOMM instance is returned\n             */\n            attr: domAttrManipulator(trackedAttributeInterface),\n            prop: domAttrManipulator(trackedAttributeInterface, BOOLEAN_TRUE),\n            // prop: domAttrManipulator(function (el, key, val) {\n            //     var value;\n            //     if (val == NULL) {\n            //         value = el[key];\n            //         value = value == NULL ? NULL : value;\n            //     } else {\n            //         el[key] = val == NULL ? NULL : val;\n            //     }\n            //     return value;\n            // }),\n            /**\n             * @func\n             * @name DOMM#eq\n             * @param {Number|Array} [num=0] - index or list of indexes to create a new DOMM element with.\n             * @returns {DOMM} instance\n             */\n            eq: attachPrevious(function (num) {\n                return eq(this.unwrap(), num);\n            }),\n            /**\n             * @func\n             * @name DOMM#clientRect\n             * @param {Number} [num=0] - item who's bounding client rect will be assessed and extended\n             * @returns {Object} hash of dimensional properties (getBoundingClientRect)\n             */\n            clientRect: function (num) {\n                return clientRect(eq(this.unwrap(), num)[0]);\n            },\n            /**\n             * @func\n             * @name DOMM#each\n             * @param {Function} callback - iterator to apply to each item on the list\n             * @param {Boolean} elOnly - switches the first argument from a DOMM wrapped object to the Node itself\n             * @returns {DOMM} instance\n             */\n            // each: ensureOne(function (callback_) {\n            //     var domm = this,\n            //         callback = bind(callback_, domm);\n            //     domm.duff(function (item_, index, all) {\n            //         callback(DOMM([item_]), index, all);\n            //     }, NULL);\n            // }),\n            /**\n             * @func\n             * @name DOMM#addClass\n             * @param {String|Array} add - space delimited string that separates classes to be added through the change class function\n             * @returns {DOMM} instance\n             */\n            addClass: DOMAttributeApplication(addClass, UNDEFINED, WRITE),\n            /**\n             * @func\n             * @name DOMM#removeClass\n             * @param {String|Array} remove - space delimited string that separates classes to be removed through the change class function\n             * @returns {DOMM} instance\n             */\n            removeClass: DOMAttributeApplication(removeClass, UNDEFINED, WRITE),\n            /**\n             * @func\n             * @name DOMM#toggleClass\n             * @params {String|Array} list - space delimited string that separates classes to be removed and added through the change class function\n             * @returns {DOMM} instance\n             */\n            toggleClass: DOMAttributeApplication(toggleClass, UNDEFINED, WRITE),\n            /**\n             * @func\n             * @name DOMM#hasClass\n             * @param {String|Array} list - space delimited string that each element is checked againsts to ensure that it has the classs\n             * @returns {Boolean} do all of the elements in the collection have all of the classes listed\n             */\n            hasClass: containsClass,\n            /**\n             * @func\n             * @name DOMM#changeClass\n             * @param {String|Array} [remove] - removes space delimited list or array of classes\n             * @param {String|Array} [add] - adds space delimited list or array of classes\n             * @returns {DOMM} instance\n             */\n            changeClass: DOMAttributeApplication(changeClass, UNDEFINED, WRITE),\n            booleanClass: DOMAttributeApplication(booleanClass, UNDEFINED, WRITE),\n            /**\n             * @func\n             * @name DOMM#box\n             * @param {Number} [num=0] - index to get the boxmodel of\n             */\n            box: function (num) {\n                return box(this[INDEX](num), this.context);\n            },\n            flow: function (num) {\n                return flow(this[INDEX](num), this.context);\n            },\n            /**\n             * @func\n             * @name DOMM#end\n             * @returns {DOMM} object that started the traversal chain\n             */\n            end: function () {\n                var that = this;\n                while (that._previous) {\n                    that = that._previous;\n                }\n                return that;\n            },\n            /**\n             * @func\n             * @name DOMM#hide\n             * @description sets all elements to display\n             * @returns {DOMM} instance\n             */\n            applyStyle: applyToEach('applyStyle'),\n            hide: function () {\n                return this.applyStyle('display', 'none');\n            },\n            /**\n             * @func\n             * @name DOMM#show\n             */\n            show: function () {\n                return this.applyStyle('display', 'block');\n            },\n            /**\n             * @func\n             * @name DOMM#append\n             */\n            append: append,\n            appendChild: append,\n            prepend: prependChild,\n            prependChild: prependChild,\n            /**\n             * @func\n             * @name DOMM#remove\n             * @returns {DOMM} instance\n             */\n            remove: applyToEach('remove'),\n            /**\n             * @func\n             * @name DOMM#next\n             * @returns {DOMM} instance\n             */\n            next: horizontalTraverser(1),\n            /**\n             * @func\n             * @name DOMM#previous\n             * @returns {DOMM} instance\n             */\n            prev: horizontalTraverser(-1),\n            /**\n             * @func\n             * @name DOMM#skip\n             * @returns {DOMM} instance\n             */\n            skip: horizontalTraverser(0),\n            /**\n             * @func\n             * @name DOMM#insertAt\n             * @returns {DOMM} instance\n             */\n            insertAt: function (els, idx) {\n                var lastChildIndex, dom = this,\n                    frag = DOMM(els).fragment(),\n                    first = dom.eq(0),\n                    children = idx == NULL ? NULL : first.children(),\n                    manager = children && children.index() || NULL,\n                    element = manager && manager.unwrap() || NULL,\n                    parent = first.index(),\n                    parentEl = parent && parent.unwrap();\n                return parentEl && element && parentEl.insertBefore(frag.unwrap(), element);\n            },\n            /**\n             * @func\n             * @name DOMM#parent\n             * @param {Number} [count=1] - number of elements to go up in the parent chain\n             * @returns {DOMM} instance of collected, unique parents\n             */\n            parent: (function () {\n                var finder = function (collect, fn, original) {\n                        return function (el) {\n                            var rets, found, parent = el,\n                                next = original;\n                            while (parent && parent.unwrap() && !found) {\n                                parent = parent.unwrap();\n                                rets = fn(parent[PARENT_NODE] || parent[DEFAULT_VIEW], original, next);\n                                parent = returnsElementData(rets[0]);\n                                found = rets[1];\n                                next = rets[2];\n                            }\n                            if (parent) {\n                                collect.push(parent);\n                            }\n                        };\n                    },\n                    number = function (parent, original, next) {\n                        next -= 1;\n                        if (next < 0 || !isFinite(next) || isNaN(next)) {\n                            next = 0;\n                        }\n                        return [parent, !next, next];\n                    },\n                    string = function (parent, original, next) {\n                        return [parent, matches(parent, original)];\n                    },\n                    speshal = {\n                        document: function (parent, original, next) {\n                            return [parent, isDocument(parent)];\n                        },\n                        window: function (parent, original, next) {\n                            return [parent, isWindow(parent)];\n                        },\n                        iframe: function (parent, original, next) {\n                            var win;\n                            if (isWindow(parent) || (parent === win[TOP])) {\n                                return [parent, BOOLEAN_FALSE];\n                            }\n                            win = parent;\n                            return [parent, wraptry(function () {\n                                parent = win.frameElement;\n                                if (parent) {\n                                    return BOOLEAN_TRUE;\n                                }\n                                return BOOLEAN_FALSE;\n                            }, function () {\n                                return BOOLEAN_FALSE;\n                            }) && parent];\n                        }\n                    };\n                return attachPrevious(function (original) {\n                    var iterator, data = [],\n                        doDefault = BOOLEAN_FALSE,\n                        collect = Collection();\n                    if (isNumber(original)) {\n                        iterator = number;\n                    } else {\n                        if (isString(original)) {\n                            iterator = speshal[original] || string;\n                        } else {\n                            doDefault = original ? BOOLEAN_TRUE : doDefault;\n                        }\n                    }\n                    if (doDefault) {\n                        this.duff(finder(collect, function (el) {\n                            return [el, original(el)];\n                        }));\n                    } else {\n                        if (!iterator) {\n                            iterator = number;\n                            original = 1;\n                        }\n                        this.duff(finder(collect, iterator, original));\n                    }\n                    return collect.unwrap();\n                });\n            }()),\n            /**\n             * @func\n             * @name DOMM#has\n             * @param {Node|Array} els - list of elements to check the current instance against\n             * @returns {Boolean} whether or not the current domm element has all of the elements that were passed in\n             */\n            has: function (els) {\n                var domm = this,\n                    collection = Collection(els),\n                    length = collection.length();\n                return !!length && collection.find(function (el) {\n                    return domm.posit(el) ? BOOLEAN_FALSE : BOOLEAN_TRUE;\n                });\n            },\n            /**\n             * @func\n             * @name DOMM#indexOf\n             * @param {Node|Array} el - element to check against the collection\n             * @returns {Number} index of the element\n             */\n            element: function (idx) {\n                var manager = this.index(idx);\n                return manager && manager.unwrap();\n            },\n            /**\n             * @func\n             * @name DOMM#html\n             * @returns {DOMM} instance\n             */\n            html: htmlTextManipulator(INNER_HTML),\n            /**\n             * @func\n             * @name DOMM#text\n             * @returns {DOMM} instance\n             */\n            text: htmlTextManipulator('innerText'),\n            /**\n             * @func\n             * @name DOMM#contentRect\n             * @returns {Object} dimensions of the content rectangle\n             */\n            contentRect: function (num) {\n                var box = this.box(num),\n                    pB = box.paddingBottom,\n                    pT = box.paddingTop,\n                    pR = box.paddingRight,\n                    pL = box.paddingLeft,\n                    bT = box.borderTop,\n                    bB = box.borderBottom,\n                    bR = box.borderRight,\n                    bL = box.borderLeft;\n                return {\n                    bottom: box[BOTTOM] - pB - bB,\n                    height: box[HEIGHT] - pT - bT - pB - bB,\n                    right: box[RIGHT] - pR - bR,\n                    width: box[WIDTH] - pL - bL - pR - bR,\n                    left: box[LEFT] + pL - bL,\n                    top: box[TOP] + pT - bT\n                };\n            },\n            /**\n             * @func\n             * @name DOMM#flowRect\n             * @returns {Object} dimensions of the flow rectangle: the amount of space the element should take up in the dom\n             */\n            flowRect: function () {\n                var box = this.box(0),\n                    mT = box.marginTop,\n                    mL = box.marginLeft,\n                    mB = box.marginBottom,\n                    mR = box.marginRight;\n                return {\n                    height: box[HEIGHT] + mT + mB,\n                    bottom: box[BOTTOM] + mB,\n                    width: box[WIDTH] + mR + mL,\n                    right: box[RIGHT] + mR,\n                    left: box[LEFT] + mL,\n                    top: box[TOP] + mT\n                };\n            },\n            /**\n             * @func\n             * @name DOMM#childOf\n             */\n            childOf: function (oParent_) {\n                var domm = this,\n                    _oParent = DOMM(oParent_),\n                    children = domm.unwrap(),\n                    oParent = _oParent.unwrap();\n                // has to use utility find because the DOMM find is just a scoped query ($)\n                return !!children[LENGTH] && !!oParent[LENGTH] && !find(oParent, function (_parent) {\n                    return find(children, function (child) {\n                        var parent = child,\n                            finding = BOOLEAN_TRUE;\n                        while (parent && finding) {\n                            if (_parent === parent) {\n                                finding = BOOLEAN_FALSE;\n                            }\n                            parent = parent[PARENT_NODE];\n                        }\n                        return finding;\n                    });\n                });\n            },\n            map: function (handler, context) {\n                return Collection(map(this.unwrap(), handler, context));\n            },\n            toJSON: function () {\n                var domm = this;\n                return map(domm.unwrap(), function (manager) {\n                    return manager.toJSON();\n                });\n            },\n            toString: function () {\n                return JSON.stringify(this);\n            },\n            tag: function (str) {\n                return tag(this.index(0), str);\n            },\n            queue: _makeQueueManager,\n            apply: _applyQueueManager\n        }, wrap({\n            id: BOOLEAN_FALSE,\n            src: BOOLEAN_FALSE,\n            checked: BOOLEAN_FALSE,\n            disabled: BOOLEAN_FALSE,\n            classes: 'className'\n        }, function (attr, api) {\n            if (!attr) {\n                attr = api;\n            }\n            return function (str) {\n                var item, setter = {};\n                if (isString(str)) {\n                    setter[attr] = str;\n                    return this.attr(setter);\n                }\n                item = this[INDEX](str);\n                if (item) {\n                    return item[attr];\n                }\n            };\n        }), wrap({\n            play: 'playing',\n            pause: 'paused'\n        }, triggerEventWrapper), wrap(gapSplit('blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu'), function (attr) {\n            return triggerEventWrapper(attr);\n        })), BOOLEAN_TRUE),\n        $ = _.$ = _DOMM(doc);\n    app.addModuleArguments([$]);\n    app.defineDirective('attributes', function () {\n        return {};\n    });\n});","application.scope().module('View', function (module, app, _, factories, $) {\n    var Box = factories.Box,\n        Collection = factories.Collection,\n        protoProp = _.protoProp,\n        isFragment = _.isFragment,\n        isInstance = _.isInstance,\n        isFunction = _.isFunction,\n        isArrayLike = _.isArrayLike,\n        reverseParams = _.reverseParams,\n        intendedObject = _.intendedObject,\n        createDocumentFragment = _.createDocumentFragment,\n        RENDER = 'render',\n        OPTIONS = 'options',\n        IS_RENDERED = '_isRendered',\n        PARENT_NODE = 'parentNode',\n        CONSTRUCTOR = 'constructor',\n        ESTABLISH_REGIONS = 'establishRegions',\n        ESTABLISHED_REGIONS = '_establishedRegions',\n        APPEND_CHILD_ELEMENTS = '_appendChildElements',\n        ELEMENT = 'element',\n        REGION_MANAGER = 'regionManager',\n        templates = {},\n        compile = function (id, force) {\n            var matches, tag, template, attrs,\n                templateFn = templates[id];\n            if (templateFn && !force) {\n                return templateFn;\n            }\n            tag = $(id);\n            template = tag.html();\n            matches = template.match(/\\{\\{([\\w\\s\\d]*)\\}\\}/mgi);\n            attrs = map(matches || [], function (match) {\n                return {\n                    match: match,\n                    attr: match.split('{{').join(EMPTY_STRING).split('}}').join(EMPTY_STRING).trim()\n                };\n            });\n            // template = template.trim();\n            templateFn = templates[id] = function (obj) {\n                var str = template,\n                    cloneResult = clone(obj);\n                duff(attrs, function (match) {\n                    if (!cloneResult[match.attr]) {\n                        cloneResult[match.attr] = EMPTY_STRING;\n                    }\n                    str = str.replace(match.match, cloneResult[match.attr]);\n                });\n                return str;\n            };\n            return templateFn;\n        },\n        makeDelegateEventKey = function (view, name) {\n            return name + '.delegateEvents' + view.cid;\n        },\n        makeDelegateEventKeys = function (view, key, namespace) {\n            if (namespace) {\n                namespace = PERIOD + namespace;\n            } else {\n                namespace = EMPTY_STRING;\n            }\n            var viewNamespace = 'delegateEvents' + view.cid;\n            return map(gapSplit(key), function (_key) {\n                var __key = _key.split(PERIOD);\n                if (__key[1] !== viewNamespace) {\n                    __key.splice(1, 0, viewNamespace);\n                    _key = __key.join(PERIOD);\n                }\n                return _key += namespace;\n            }).join(' ');\n        },\n        normalizeUIString = function (uiString, ui) {\n            return uiString.replace(/@ui\\.[a-zA-Z_$0-9]*/g, function (r) {\n                return ui[r.slice(4)];\n            });\n        },\n        // allows for the use of the @ui. syntax within\n        // a given key for triggers and events\n        // swaps the @ui with the associated selector.\n        // Returns a new, non-mutated, parsed events hash.\n        normalizeUIKeys = function (hash, ui) {\n            return reduce(hash, function (memo, val, key) {\n                var normalizedKey = normalizeUIString(key, ui);\n                memo[normalizedKey] = val;\n                return memo;\n            }, {});\n        },\n        getRegion = function (key) {\n            return this.directive(REGION_MANAGER).list.get('id', key);\n        },\n        addRegion = function (key, selector) {\n            var regionManagerDirective = this.directive(REGION_MANAGER);\n            intendedObject(key, selector, function (key, selector) {\n                var region = regionManagerDirective.list.get(key);\n                if (!region) {\n                    regionManagerDirective.establish(key, selector);\n                }\n            });\n        },\n        /**\n         * @class View\n         * @augments Model\n         * @augments Box\n         * @classDesc Objects that have one or more element associated with them, such as a template that needs constant updating from the data\n         */\n        // region views are useful if you're constructing different components\n        // from a separate place and just want it to be in the attach pipeline\n        // very useful for componentizing your ui\n        // LeafView = factories.\n        // regionConstructor = ,\n        Region = factories.Events.extend('Region', {\n            tagName: 'div',\n            // constructor: function (secondary) {\n            //     var model = this;\n            //     factories.Events[CONSTRUCTOR].call(model, secondary);\n            //     //\n            //     return model;\n            // },\n            // 'directive:creation:regionManager': function () {\n            //     return NULL;\n            // },\n            // _ensureElement: function () {\n            //     this._setElement();\n            // },\n            // constructor: function (options) {\n            //     var view = this;\n            //     _View[CONSTRUCTOR].call(view, options);\n            //     return view;\n            // },\n            add: function (models_) {\n                var ret, _bufferedViews, region = this,\n                    bufferedViewsDirective = region.directive('bufferedViews');\n                bufferedViewsDirective.ensure();\n                Collection(models_).each(region.bufferView, region);\n                return ret;\n            },\n            // _add: function (view) {\n            //     // var parent = this,\n            //     //     regionManagerDirective = view.directive(REGION_MANAGER);\n            //     // Box[CONSTRUCTOR][PROTOTYPE]._add.call(parent, view);\n            //     // ensure the element buffer\n            //     // append to the view list buffer\n            //     // attached buffered element here so we don't have to loop through the list later\n            //     // view._setElement(view.el);\n            //     // parent.bufferView(view);\n            // },\n            bufferView: function (view) {\n                var bufferDirective = this.directive('bufferedViews'),\n                    el = view.el && view.el.unwrap();\n                if (el) {\n                    bufferDirective.els.appendChild(el);\n                    bufferDirective.views.push(view);\n                }\n            },\n            setElement: function () {\n                var manager, region = this,\n                    selector = region.selector,\n                    parent = region[PARENT][PARENT];\n                if (parent !== app) {\n                    manager = parent.$(selector);\n                } else {\n                    manager = $(selector)[INDEX](0);\n                }\n                region.directive(ELEMENT).set(manager);\n            },\n            renderChildren: function () {\n                var buffers = this;\n                duff(this.views, function (child) {\n                    if (result(child, 'filter')) {\n                        child[RENDER]();\n                        buffers.region.directive(REGION_MANAGER).list.add(child);\n                    }\n                });\n            },\n            render: function () {\n                var region = this,\n                    bufferDirective = region.directive('bufferedViews'),\n                    elementDirective = region.directive(ELEMENT);\n                region[IS_RENDERED] = BOOLEAN_FALSE;\n                // doc frags on regionviews, list of children to trigger events on\n                bufferDirective.ensure();\n                // request extra data or something before rendering: dom is still completely intact\n                region[DISPATCH_EVENT]('before:' + RENDER);\n                // unbinds and rebinds element only if it changes\n                // region._setElement();\n                // update new element's attributes\n                region.setElement();\n                // attrs = view.attributes();\n                elementDirective.setAttributes();\n                // puts children back inside parent\n                bufferDirective.attach();\n                // attach region element\n                // appends child elements\n                elementDirective.el.append(bufferDirective.els);\n                // mark the view as rendered\n                region[IS_RENDERED] = BOOLEAN_TRUE;\n                // reset buffered objects\n                bufferDirective.reset();\n                // dispatch the render event\n                region[DISPATCH_EVENT](RENDER);\n                return region;\n                // },\n                // _appendChildElements: function () {\n                //     var region = this,\n                //         buffered = region.directive('bufferedViews');\n                //     if (buffered && region.el) {\n                //         region.el.appendChild(buffered.els);\n                //     }\n            }\n        }, BOOLEAN_TRUE),\n        View = Region.extend('View', {\n            /**\n             * @func\n             * @name View # constructor\n             * @description constructor for new view object\n             * @param {Object | DOMM | Node} attributes - hash with non - circular data on it. Is set later with the Box constructor\n             * @param {Object} secondary - options such as defining the parent object, or the element if necessary\n             * @param {DOMM|Node} el - element or Node that is attached directly to the View object\n             * @returns {View} instance\n             */\n            filter: BOOLEAN_TRUE,\n            getRegion: getRegion,\n            constructor: function (secondary) {\n                var model = this;\n                factories.Events[CONSTRUCTOR].call(model, secondary);\n                model.directive(ELEMENT).ensure();\n                model.directive(REGION_MANAGER).establish(result(model, 'regions'));\n                return model;\n            },\n            $: function (selector) {\n                return this.el.find(selector);\n            },\n            template: function () {\n                return EMPTY_STRING;\n            },\n            setElement: function (element) {\n                var view = this,\n                    previousElement = view.el,\n                    elementDirective = view.directive(ELEMENT);\n                // detaches events with this view's namespace\n                elementDirective.set(element);\n                if (previousElement !== view.el) {\n                    elementDirective.undelegate(previousElement);\n                    elementDirective.delegate();\n                }\n                // attaches events with this view's namespace\n                return view;\n            },\n            render: function () {\n                var ret, view = this,\n                    regionsManagerDirective = view.checkDirective(REGION_MANAGER),\n                    element = view.directive(ELEMENT);\n                view[IS_RENDERED] = BOOLEAN_FALSE;\n                // prep the object with extra members (doc frags on regionviews,\n                // list of children to trigger events on)\n                // request extra data or something before rendering: dom is still completely intact\n                view[DISPATCH_EVENT]('before:' + RENDER);\n                // unbinds and rebinds element only if it changes\n                view.setElement(view.el);\n                // update new element's attributes\n                element.setAttributes();\n                // renders the html\n                element.render(result(view, 'template', view.model && view.model.toJSON()));\n                // gathers the ui elements\n                view._bindUIElements();\n                // ties regions back to newly formed parent template\n                ret = regionsManagerDirective && regionsManagerDirective.establish();\n                // tie the children of the region the the region's el\n                view.directive(REGION_MANAGER).list.eachCall(RENDER);\n                // mark the view as rendered\n                view[IS_RENDERED] = BOOLEAN_TRUE;\n                // dispatch the render event\n                view[DISPATCH_EVENT](RENDER);\n                return view;\n            },\n            parentView: function () {\n                var found, view = this,\n                    parent = view[PARENT];\n                while (found && parent && !isInstance(parent, View)) {\n                    parent = parent[PARENT];\n                    if (isInstance(parent, View)) {\n                        found = parent;\n                    }\n                }\n                return found;\n            },\n            _bindUIElements: function () {\n                var view = this,\n                    _uiBindings = view._uiBindings || result(view, 'ui');\n                view.ui = view.ui || {};\n                if (_uiBindings) {\n                    return view;\n                }\n                // save it to skip the result call later\n                view._uiBindings = _uiBindings;\n                view.ui = map(_uiBindings, function (key, selector) {\n                    return view.$(selector);\n                });\n                return view;\n            },\n            _unBindUIElements: function () {\n                var view = this;\n                view.ui = view._uiBindings;\n            },\n            remove: function () {\n                var el, view = this;\n                Box[CONSTRUCTOR][PROTOTYPE].remove.apply(view, arguments);\n                // if you were not told to select something in\n                // _ensureElements then remove the view from the dom\n                view.detach();\n                return view;\n            },\n            _detachElement: function () {\n                var view = this,\n                    el = view.el && view.el[INDEX](0);\n                if (el && el[PARENT_NODE]) {\n                    el[PARENT_NODE].removeChild(el);\n                }\n            },\n            _removeViewElement: function (el, frag) {\n                var parent = this;\n                if (frag) {\n                    frag.appendChild(el);\n                } else {\n                    if (el[PARENT_NODE]) {\n                        el[PARENT_NODE].removeChild(el);\n                    }\n                }\n            },\n            detach: function () {\n                var view = this;\n                if (view.isDetaching) {\n                    return;\n                }\n                view.isDetaching = BOOLEAN_TRUE;\n                view[DISPATCH_EVENT]('before:detach');\n                view.isDetached = BOOLEAN_TRUE;\n                view._detachElement();\n            },\n            destroy: function (opts) {\n                var view = this;\n                view[IS_RENDERED] = BOOLEAN_FALSE;\n                view.detach();\n                // remove all events\n                // should internally call remove\n                Box[CONSTRUCTOR][PROTOTYPE].destroy.call(view);\n                return view;\n            },\n            rendered: function () {\n                return this[IS_RENDERED];\n            },\n            destroyed: function () {\n                return this.isDestroyed;\n            }\n        }, BOOLEAN_TRUE),\n        // ElementDirective = app.defineDirective('element', function (target) {\n        //     //\n        // }),\n        _View = factories.View,\n        ensureElement = function () {\n            var el, elementDirective = this,\n                view = elementDirective.view,\n                selector = elementDirective.selector || result(view, 'el');\n            if (selector) {\n                elementDirective.selector = selector;\n            }\n            if (!isInstance(selector, factories.DOMM)) {\n                if (isString(selector)) {\n                    // sets external element\n                    el = selector;\n                } else {\n                    // defauts back to wrapping the element\n                    // creates internal element\n                    el = elementDirective.create(result(view, 'tagName'));\n                    // subclassed to expand the attributes that can be used\n                }\n                elementDirective.set(el);\n            }\n        },\n        createElement = function (tag) {\n            return $('<' + tag + '>').index(0);\n        },\n        setElement = function (el) {\n            this.view.el = this.el = factories.DomManager.isInstance(el) ? el : $(el).index(0);\n        },\n        delegateElementEvents = function (bindings_) {\n            var key, method, match,\n                elementDirective = this,\n                view = elementDirective.view,\n                eventBindings = view.eventBindings || result(view, 'elementEvents'),\n                // bindings = bindings_ || eventBindings,\n                __events = {};\n            if (eventBindings) {\n                elementDirective.eventBindings = eventBindings;\n            }\n            if (!el) {\n                return elementDirective;\n            }\n            each(bindings, function (key, methods_) {\n                // assumes is array\n                var methods = gapSplit(methods_);\n                if (isFunction(methods_)) {\n                    methods = [methods_];\n                }\n                __events[makeDelegateEventKeys(view, key)] = map(methods, function (method, idx) {\n                    return bind(view[method] || method, view);\n                });\n            });\n            el.on(__events);\n            return elementDirective;\n        },\n        unDelegateElementEvents = function (el, bindings_) {\n            var key, method, match, elementDirective = this,\n                view = elementDirective.view,\n                eventBindings = elementDirective.eventBindings || result(view, 'elementEvents'),\n                // bindings = bindings_ || eventBindings,\n                __events = {};\n            if (eventBindings) {\n                elementDirective.eventBindings = eventBindings;\n            }\n            if (!el) {\n                return view;\n            }\n            each(bindings, function (key, methods_) {\n                var method = bind(isString(methods_) ? view[methods_] : methods_, view);\n                __events[makeDelegateEventKeys(view, key)] = method;\n            });\n            el.on(__events);\n            return view;\n        },\n        setElementAttributes = function () {\n            var elementDirective = this,\n                view = elementDirective.view,\n                attrs = result(view, 'elementAttributes');\n            if (view.className) {\n                attrs = attrs || {};\n                attrs['class'] = result(view, 'className');\n            }\n            if (attrs) {\n                elementDirective.el.attr(attrs);\n            }\n        },\n        renderElement = function (html) {\n            this.el.html(html || '');\n        };\n    app.defineDirective(ELEMENT, function (instance) {\n        return {\n            view: instance,\n            ensure: ensureElement,\n            create: createElement,\n            set: setElement,\n            render: renderElement,\n            setAttributes: setElementAttributes,\n            delegate: delegateElementEvents,\n            undelegate: unDelegateElementEvents\n        };\n    });\n    var establishRegion = function (key, selector) {\n            var regionManagerDirective = this,\n                parentView = regionManagerDirective[PARENT];\n            if (key) {\n                intendedObject(key, selector, function (key, selector) {\n                    var $selected, region = regionManagerDirective.list.get(key);\n                    if (!region) {\n                        region = regionManagerDirective.create(key, selector);\n                    }\n                    // region = this;\n                    if (parentView !== app) {\n                        $selected = parentView.$(selector)[INDEX](0);\n                    } else {\n                        $selected = $(selector)[INDEX](0);\n                    }\n                    if ($selected) {\n                        region.el = $selected;\n                    }\n                });\n            }\n            return regionManagerDirective;\n        },\n        removeRegion = function (region_) {\n            // var regionManager = this;\n            // var region = isString(region_) ? regionManager.get(region_) : region_;\n            // regionManager.remove(region);\n            // regionManager.unRegister(region.id, region);\n        },\n        createRegion = function (where, region_) {\n            var key, regionManagerDirective = this,\n                parent = regionManagerDirective[PARENT],\n                // assume that it is a region\n                region = region_;\n            if (isInstance(region, Region)) {\n                return region;\n            }\n            region = Region({\n                id: where,\n                selector: isString(region) ? region : EMPTY_STRING,\n                parent: regionManagerDirective\n            });\n            key = REGION_MANAGER;\n            // if (parent !== app) {\n            //     // key = CHILDREN;\n            //     parent.add(region);\n            // }\n            regionManagerDirective.list.push(region);\n            regionManagerDirective.list.register('id', where, region);\n            return region;\n        },\n        bufferedEnsure = function () {\n            var buffers = this,\n                _bufferedViews = isArray(buffers.views) ? 1 : buffers.resetViews(),\n                _bufferedEls = isFragment(buffers.els) ? 1 : buffers.resetEls();\n        },\n        bufferedReset = function () {\n            this.resetEls();\n            this.resetViews();\n        },\n        bufferedElsReset = function () {\n            this.els = createDocumentFragment();\n        },\n        bufferedViewsReset = function () {\n            this.views = [];\n        },\n        bufferedAttach = function () {\n            var buffers = this;\n            duff(this.views, function (child) {\n                if (result(child, 'filter')) {\n                    child[RENDER]();\n                    buffers.region.directive(REGION_MANAGER).list.add(child);\n                }\n            });\n        };\n    app.defineDirective(REGION_MANAGER, function (instance) {\n        return {\n            list: Collection(),\n            parent: instance,\n            create: createRegion,\n            establish: establishRegion,\n            remove: removeRegion,\n            add: addRegion\n        };\n    });\n    app.defineDirective('bufferedViews', function (instance) {\n        return {\n            region: instance,\n            els: createDocumentFragment(),\n            views: [],\n            reset: bufferedReset,\n            ensure: bufferedEnsure,\n            resetViews: bufferedViewsReset,\n            resetEls: bufferedElsReset,\n            attach: bufferedAttach\n        };\n    });\n    _.exports({\n        compile: compile\n    });\n    app.extend({\n        _addToHash: Box[CONSTRUCTOR][PROTOTYPE]._addToHash,\n        // getRegion: viewGetRegionPlacer(REGION_MANAGER),\n        getRegion: getRegion,\n        addRegion: addRegion\n        // addRegion: function (id, selector) {\n        //     var app = this;\n        //     // ensure region manager\n        //     // var blank = app.getRegion();\n        //     this.directive(REGION_MANAGER).establish(id, selector);\n        //     // var regionManager = app[REGION_MANAGER];\n        //     // regionManager[PARENT] = app;\n        //     // regionManager[ESTABLISH_REGIONS](id, selector);\n        //     return app;\n        // }\n    });\n});","application.scope().module('Buster', function (module, app, _, factories, $) {\n    var isReceiving = 0,\n        get = _.get,\n        duff = _.duff,\n        collection = factories.Collection,\n        gapSplit = _.gapSplit,\n        associator = _.associator,\n        unitsToNum = _.unitsToNum,\n        roundFloat = _.roundFloat,\n        isFunction = _.isFunction,\n        extend = _.extend,\n        console = _.console,\n        reference = _.reference,\n        now = _.now,\n        parse = _.parse,\n        foldl = _.foldl,\n        stringify = _.stringify,\n        COMPONENT = 'component',\n        RESPONSE_OPTIONS = 'responseOptions',\n        MARGIN_BOTTOM = 'marginBottom',\n        MARGIN_RIGHT = 'marginRight',\n        MIN_HEIGHT = 'minHeight',\n        MAX_HEIGHT = 'maxHeight',\n        MIN_WIDTH = 'minWidth',\n        MAX_WIDTH = 'minWidth',\n        BEFORE_RESPONDED = 'before:responded',\n        QUEUED_MESSAGE_INDEX = 'queuedMessageIndex',\n        pI = _.pI,\n        _setupInit = function (e) {\n            var i, currentCheck, src, parentEl, frameWin, frameEl, allFrames, tippyTop, spFacts, spOFacts, shouldRespond, sameSide, topDoc, wrapper, buster = this,\n                frame = e.frame,\n                data = e.data(),\n                packet = data.packet,\n                responder = e.responder,\n                attrs = get(buster),\n                parts = buster.parts;\n            if (app.topAccess) {\n                tippyTop = win[TOP];\n                topDoc = tippyTop.document;\n                wrapper = topDoc.body;\n            }\n            if (!frame) {\n                if (!data.toInner) {\n                    /**\n                     * when the buster has to go through an unfriendly iframe, it has to find the iframe it belonged to from the top document\n                     * @private\n                     * @arg {string} url that is the iframe. also, secondarily checks the window objects in the while loop\n                     */\n                    buster.el = (function (specFrame) {\n                        var frame, frameWin, src, currentCheck, i,\n                            frames = topDoc.getElementsByTagName('iframe'),\n                            srcEl = e.srcElement;\n                        if (specFrame) {\n                            for (i in frames) {\n                                frame = frames[i];\n                                frameWin = frame.contentWindow;\n                                src = frame.src;\n                                if (src === specFrame) {\n                                    currentCheck = srcEl;\n                                    while (currentCheck !== tippyTop) {\n                                        if (frameWin === currentCheck) {\n                                            return frame;\n                                        }\n                                        currentCheck = currentCheck[PARENT];\n                                    }\n                                }\n                            }\n                        }\n                        return 0;\n                    }(attrs.srcOrigin));\n                }\n                if (data.toInner) {\n                    buster.el = document.body;\n                }\n                if (buster.el) {\n                    buster.el = $(buster.el);\n                    buster.set({\n                        sameSide: 0,\n                        id: data.from,\n                        referrer: reference(parts.doc)\n                    });\n                    extend(parts, {\n                        srcElement: e.source,\n                        top: tippyTop || {},\n                        doc: topDoc || {},\n                        wrapper: wrapper || {}\n                    });\n                    shouldRespond = 1;\n                    attrs.isConnected = 1;\n                }\n            }\n            if (frame) {\n                buster.el = frame;\n                buster.responder = e.responder;\n                shouldRespond = 1;\n                buster.set({\n                    sameSide: 1,\n                    referrer: packet.referrer\n                });\n                extend(buster.parts, {\n                    srcElement: e.srcElement,\n                    wrapper: wrapper,\n                    top: tippyTop,\n                    doc: topDoc\n                });\n            }\n            if (shouldRespond) {\n                parentEl = buster.el[PARENT]();\n                buster.respond(data, {\n                    parent: {\n                        height: parentEl[HEIGHT](),\n                        width: parentEl[WIDTH](),\n                        style: {\n                            height: parentEl.index(0).style[HEIGHT],\n                            width: parentEl.index(0).style[WIDTH]\n                        }\n                    }\n                });\n            }\n        },\n        /**\n         * single handler for all busters under same window makes it easy to remove from window when the time comes to unload\n         * @private\n         * @arg {event} event object passed in by browser\n         */\n        receive = function (evt) {\n            var buster, bustersCache, data = parse(evt.data),\n                postTo = data.postTo;\n            if (data && postTo && !app.isDestroying) {\n                bustersCache = associator.get(postTo);\n                if (bustersCache) {\n                    buster = bustersCache.buster;\n                    if (buster && buster.run) {\n                        buster.run(data, evt);\n                    }\n                }\n            }\n        },\n        /**\n         * single function to stringify and post message an object to the other side\n         * @private\n         * @arg {object} object to be stringified and sent to the receive function,\n         * either through a post message, or through a setTimeout\n         * @arg {buster}\n         */\n        postMessage = function (base, buster) {\n            var busterAttrs = buster.directive(DATA),\n                sameSide = busterAttrs.sameSide,\n                parts = buster.parts,\n                message = stringify(base),\n                timestamp = now(),\n                doReceive = function () {\n                    receive({\n                        data: message,\n                        frame: buster.el,\n                        responder: receive,\n                        srcElement: win,\n                        timestamp: timestamp\n                    });\n                };\n            if (sameSide) {\n                if (busterAttrs.referrer) {\n                    throw new Error('missing referrer: ' + buster.get('sessionId'));\n                } else {\n                    parts.sendWin.postMessage(message, busterAttrs.referrer);\n                }\n            }\n            if (sameSide) {\n                doReceive();\n            }\n            return timestamp;\n        },\n        /**\n         * object for 4 different setup cases. probably belongs elsewhere\n         * @private\n         * @arg {buster}\n         */\n        setups = {\n            /**\n             * @private\n             */\n            toInner: function (buster) {\n                var attrs = buster.directive(DATA),\n                    parts = buster.parts;\n                parts.sendWin = buster[PARENT].el.index(0).contentWindow;\n                attrs.referrer = attrs.referrer || reference(parts.doc);\n                attrs.sameSide = !buster[PARENT][PARENT].get('unfriendlyCreative');\n            },\n            /**\n             * @private\n             */\n            fromInner: function (buster) {\n                var attrs = buster.directive(DATA),\n                    parts = buster.parts;\n                parts.sendWin = parts.receiveWin[PARENT];\n                attrs.referrer = attrs.referrer || reference(parts.doc);\n            },\n            notInner: {\n                /**\n                 * @private\n                 */\n                noAccess: function (buster) {\n                    var url, attrs = buster.directive(DATA),\n                        parts = buster.parts,\n                        doc = parts.doc,\n                        iframe = doc.createElement('iframe'),\n                        allMods = _.clone(app.allModules);\n                    allMods.push('initPublisherConfig');\n                    if (!attrs.busterLocation) {\n                        return;\n                    }\n                    iframe.style.display = 'none';\n                    url = attrs.referrer + attrs.busterLocation;\n                    iframe.src = _.stringifyQuery({\n                        url: attrs.referrer + attrs.busterLocation,\n                        query: {\n                            origin: doc.location.href,\n                            sessionId: attrs.sessionId,\n                            src: app.BASEURL + buster.get('scriptUrl') + app.addVersionNumber(allMods).join()\n                        }\n                    });\n                    parts.wrapper.appendChild(iframe);\n                    parts.sendWin = iframe.contentWindow;\n                    buster.el = $(iframe);\n                    promise.Ajax(url).failure(function () {\n                        var time = 2000;\n                        if (_.isMobile) {\n                            time = 10000;\n                        }\n                        setTimeout(function () {\n                            // handle no buster file here\n                            var ret, ad = buster[PARENT],\n                                adAttrs = ad.directive(DATA),\n                                banner = ad.children.index(1),\n                                panel = ad.children.index(2);\n                            if (!ad.busterLoaded) {\n                                if (!banner) {\n                                    banner = panel;\n                                }\n                                ret = panel.destroy && panel.destroy();\n                                buster.unSendAll();\n                                buster.on('message:queued', buster.unSendAll);\n                            }\n                        }, time);\n                    });\n                },\n                /**\n                 * @private\n                 */\n                topAccess: function (buster) {\n                    var commands, newParent = buster.el.index(0),\n                        attrs = buster.directive(DATA);\n                    // if preventselfinit is true, then that means that\n                    // this is being triggered by the buster file\n                    if (!attrs.preventSelfInit) {\n                        if (attrs.publisherConfig) {\n                            // // does need some special functions\n                            _.Ajax('http:' + app.SERVERURL + app.SCRIPTPATH + attrs.publisherConfig).success(function (responseText) {\n                                new Function.constructor('return ' + responseText)();\n                                buster.begin();\n                            });\n                        } else {\n                            // doesn't need any special functions\n                            buster.addCommand(factories.publisherConfig());\n                            buster.begin();\n                        }\n                    } else {\n                        buster.addCommand(factories.publisherConfig());\n                    }\n                }\n            }\n        },\n        containerSize = function (components) {\n            return components.foldr(function (memo, idx, com) {\n                var preventScrollCounter = 0,\n                    hPushCount = 0,\n                    vPushCount = 0,\n                    calced = com.calculatedSize,\n                    verticalPush = com.pushVertical,\n                    horizontalPush = com.pushHorizontal;\n                if (verticalPush !== EMPTY_STRING) {\n                    vPushCount++;\n                }\n                if (horizontalPush !== EMPTY_STRING) {\n                    hPushCount++;\n                }\n                if (com.isShowing && com.container === 'ad') {\n                    if (com.preventScroll) {\n                        preventScrollCounter = 1;\n                    }\n                    memo = {\n                        top: Math.min(memo[TOP], calced[TOP]),\n                        left: Math.min(memo[LEFT], calced[LEFT]),\n                        right: Math.max(memo[RIGHT], (calced[LEFT] + calced[WIDTH])),\n                        bottom: Math.max(memo[BOTTOM], (calced[TOP] + calced[HEIGHT])),\n                        zIndex: Math.max(memo.zIndex, (+com.zIndex || 0)),\n                        marginRight: Math.max(memo[MARGIN_RIGHT], horizontalPush || 0),\n                        marginBottom: Math.max(memo[MARGIN_BOTTOM], verticalPush || 0),\n                        vPushCount: vPushCount + memo.vPushCount,\n                        hPushCount: hPushCount + memo.hPushCount,\n                        transitionDuration: Math.max(memo.transitionDuration, com.duration),\n                        preventScrollCount: memo.preventScrollCount + preventScrollCounter\n                    };\n                }\n                return memo;\n            }, {\n                top: BIG_INTEGER,\n                left: BIG_INTEGER,\n                right: NEGATIVE_BIG_INTEGER,\n                bottom: NEGATIVE_BIG_INTEGER,\n                marginBottom: 0,\n                marginRight: 0,\n                zIndex: 0,\n                vPushCount: 0,\n                hPushCount: 0,\n                transitionDuration: 0,\n                preventScrollCount: 0\n            });\n        },\n        /**\n         * @class Buster\n         * @augments Model\n         * @augments Box\n         * @augments View\n         * @classDesc constructor for buster objects, which have the ability to talk across windows\n         */\n        Message = factories.Container.extend('Message', {\n            initialize: function () {\n                var message = this;\n                message.deferredHandlers = [];\n                message.respondHandlers = [];\n            },\n            packet: function (data) {\n                var ret = this;\n                if (arguments[0]) {\n                    this.set('packet', data || {});\n                } else {\n                    ret = parse(stringify(this.get('packet')));\n                }\n                return ret;\n            },\n            defaults: function () {\n                return {\n                    command: 'null',\n                    packet: {}\n                };\n            },\n            deferred: function (fn) {\n                this.on('deferred', fn);\n                return this;\n            },\n            respond: function (fn) {\n                var message = this,\n                    buster = message[PARENT];\n                if (isFunction(fn)) {\n                    message.respondHandlers.push(bind(fn, message));\n                }\n                if (message[RESPONSE_OPTIONS]) {\n                    while (message.respondHandlers[0]) {\n                        handler = message.respondHandlers.shift();\n                        handler(message[RESPONSE_OPTIONS]);\n                    }\n                }\n                return message;\n            }\n        }),\n        Buster = factories.Buster = factories.Box.extend('Buster', {\n            Model: Message,\n            events: {\n                unload: 'destroy',\n                'change:isConnected': function () {\n                    this.set(QUEUED_MESSAGE_INDEX, 1);\n                },\n                'change:isConnected child:added': 'flush'\n            },\n            parentEvents: function () {\n                return {\n                    destroy: 'destroy'\n                };\n            },\n            /**\n             * @func\n             * @name Buster#destroy\n             */\n            currentPoint: function () {\n                var currentPoint = this.get('currentPoint');\n                return currentPoint ? {\n                    source: currentPoint.source,\n                    srcElement: currentPoint.srcElement,\n                    originTimestamp: currentPoint.timestamp,\n                    frame: currentPoint.frame,\n                    responder: currentPoint.responder\n                } : {};\n            },\n            destroy: function () {\n                var buster = this,\n                    attrs = buster.directive(DATA);\n                buster.set('isConnected', BOOLEAN_FALSE);\n                clearTimeout(attrs.__lastMouseMovingTimeout__);\n                _.AF.remove(attrs.elQueryId);\n                _.AF.remove(attrs.componentTransitionAFID);\n                buster.parts = {};\n                associator.remove(buster.id);\n                factories.Box[CONSTRUCTOR][PROTOTYPE].destroy.apply(this, arguments);\n                return buster;\n            },\n            tellMouseMovement: function () {\n                if (this.get('mouseMoveDataObject')) {\n                    this.respond(this.get('mouseMoveDataObject'));\n                }\n            },\n            /**\n             * @func\n             * @name Buster#defaults\n             */\n            defaults: function () {\n                return {\n                    currentState: 'collapse',\n                    connectedUnder: [],\n                    isConnected: 0,\n                    sameSide: 0,\n                    queuedMessageIndex: 0,\n                    sent: []\n                };\n            },\n            // belongs on the outside\n            _stateCss: function (set0) {\n                var busterAttrs = this.directive(DATA),\n                    _sizing = busterAttrs._sizing,\n                    margin = {\n                        transitionProperty: 'all'\n                    };\n                if (_sizing) {\n                    if (_sizing.vPushCount) {\n                        margin[MARGIN_BOTTOM] = busterAttrs.pushVerticalVal;\n                        margin.transitionDuration = _sizing.transitionDuration;\n                    } else {\n                        if (set0) {\n                            margin[MARGIN_BOTTOM] = 0;\n                        } else {\n                            margin[MARGIN_BOTTOM] = 'auto';\n                        }\n                    }\n                    if (_sizing.hPushCount) {\n                        margin[MARGIN_RIGHT] = busterAttrs.pushHorizontalVal;\n                        margin.transitionDuration = _sizing.transitionDuration;\n                    } else {\n                        if (set0) {\n                            margin[MARGIN_RIGHT] = 0;\n                        } else {\n                            margin[MARGIN_RIGHT] = 'auto';\n                        }\n                    }\n                }\n                return margin;\n            },\n            /**\n             * initial setup for all busters\n             * @func\n             * @name Buster#initialize\n             */\n            initialize: function (opts, options) {\n                var receiveWin, registered, buster = this,\n                    attrs = buster.directive(DATA);\n                buster[COMPONENTS] = collection();\n                buster.showing = collection();\n                buster.on(BEFORE_RESPONDED, attrs.every);\n                buster.addCommand({\n                    initialize: _setupInit,\n                    begin: this.begin,\n                    update: function (e) {\n                        this.respond(e.data());\n                    },\n                    unload: function () {\n                        this.destroy();\n                    }\n                    // ,\n                    // belongs on the outside\n                    // updateAttributes: function (e) {\n                    //     var buster = this,\n                    //         data = e.data(),\n                    //         packet = data.packet;\n                    //     buster.set(packet.update);\n                    //     duff(packet[COMPONENTS], function (com) {\n                    //         var component = buster[COMPONENT](com.registeredAs);\n                    //         if (!component) {\n                    //             buster[COMPONENTS].add(com);\n                    //         } else {\n                    //             extend(component, com);\n                    //         }\n                    //     });\n                    //     buster[COMPONENTS].each(function (com) {\n                    //         if (_.posit(packet.showing, com.registeredAs)) {\n                    //             com.isShowing = BOOLEAN_TRUE;\n                    //         } else {\n                    //             com.isShowing = BOOLEAN_FALSE;\n                    //         }\n                    //     });\n                    //     if (packet.shouldRespond) {\n                    //         buster.respond();\n                    //     }\n                    // }\n                });\n                buster.allListeners = collection();\n                attrs.frame = NULL;\n                buster.el = $(buster.parts.frame);\n                registered = associator.get(attrs.id);\n                registered.buster = buster;\n                registered.postListener = receive;\n                receiveWin = $(buster.parts.receiveWin);\n                receiveWin.on('message', receive);\n                buster.allListeners.push({\n                    els: receiveWin,\n                    fn: receive,\n                    name: 'message'\n                });\n                if (attrs.type === 'buster') {\n                    if (!attrs.sameSide) {\n                        setups.notInner.noAccess(buster);\n                    } else {\n                        setups.notInner.topAccess(buster);\n                    }\n                }\n                // always assume the need to bust for these two\n                if (attrs.type !== 'buster') {\n                    if (attrs.toInner) {\n                        setups.toInner(buster);\n                    }\n                    if (attrs.fromInner) {\n                        setups.fromInner(buster);\n                    }\n                }\n                return buster;\n            },\n            /**\n             * quick get parser to figure out if the wrapper, the frame element, it's parent, the document, or an other item is being selected by a post message\n             * @arg {string} target selector\n             * @returns {DOMM} with targets\n             * @func\n             * @name Buster#getTargets\n             */\n            // getTargets: function (target) {\n            //     var buster = this,\n            //         attrs = buster.directive(DATA),\n            //         parts = buster.parts,\n            //         top = parts[TOP],\n            //         targets = [],\n            //         wrapper = parts.wrapper;\n            //     if (!target) {\n            //         targets = [top];\n            //     }\n            //     if (target === 'wrapper') {\n            //         targets = [wrapper];\n            //     }\n            //     if (target === 'self') {\n            //         targets = buster.el;\n            //     }\n            //     if (target === DOCUMENT) {\n            //         targets = [parts.doc];\n            //     }\n            //     if (target === PARENT) {\n            //         targets = buster.el[PARENT]();\n            //     }\n            //     if (!targets[LENGTH]) {\n            //         targets = parts.doc.querySelectorAll(target);\n            //     }\n            //     return $(targets);\n            // },\n            /**\n             * tries to flush the cache. only works if the isConnected attribute is set to true. If it is, then the post message pipeline begins\n             * @returns {buster} returns this;\n             * @func\n             * @name Buster#flush\n             */\n            flush: function () {\n                var n, item, gah, childrenLen, queuedMsg, nuData, i = 0,\n                    buster = this,\n                    currentIdx = buster.get(QUEUED_MESSAGE_INDEX),\n                    connected = buster.get('isConnected'),\n                    initedFrom = buster.get('initedFromPartner'),\n                    flushing = buster.get('flushing');\n                if (!initedFrom || connected && ((connected || !currentIdx) && !flushing)) {\n                    buster.set('flushing', BOOLEAN_TRUE);\n                    childrenLen = buster.children[LENGTH]();\n                    queuedMsg = buster.children.index(currentIdx);\n                    while (queuedMsg && currentIdx < childrenLen) {\n                        queuedMsg.set('runCount', 0);\n                        postMessage(queuedMsg, buster);\n                        if (currentIdx) {\n                            currentIdx = (buster.get(QUEUED_MESSAGE_INDEX) + 1) || 0;\n                            buster.set(QUEUED_MESSAGE_INDEX, currentIdx);\n                            queuedMsg = buster.children.index(currentIdx);\n                        } else {\n                            childrenLen = BOOLEAN_FALSE;\n                        }\n                    }\n                    buster.set('flushing', BOOLEAN_FALSE);\n                    if (buster.get('isConnected')) {\n                        if (buster.children[LENGTH]() > buster.get(QUEUED_MESSAGE_INDEX)) {\n                            buster.flush();\n                        }\n                    }\n                }\n                return buster;\n            },\n            /**\n             * basic send message function, adds to queue, then calls flush\n             * @arg {string} can be string or object. if object, must have command property as string\n             * @arg {object} base object to be sent\n             * @returns {buster}\n             * @func\n             * @name Buster#send\n             */\n            send: function (command, packet, extra) {\n                var buster = this,\n                    defaultObj = buster.defaultMessage(),\n                    message = buster.add(extend({\n                        command: command,\n                        packet: packet\n                    }, defaultObj, extra));\n                return buster.directive(CHILDREN).index(defaultObj.index);\n            },\n            /**\n             * shorthand for creating a function that gets called after the buster's partner has responded\n             * @func\n             * @name Buster#sync\n             */\n            sync: function (fn) {\n                return this.send('update').respond(fn);\n            },\n            /**\n             * if a buster is found on the receive function, by the data's postTo property, then the run method is called\n             * @arg {object} the parsed data object\n             * @arg {event} the event object that wrapped the stringified data object\n             * @returns {buster}\n             * @func\n             * @name Buster#run\n             */\n            run: function (data, currentPoint_) {\n                var packet, format, retVal, responded, onResponse, originalMessage, responseType, methodName, buster = this,\n                    attrs = buster.directive(DATA),\n                    currentPoint = attrs.currentPoint = currentPoint_,\n                    event = currentPoint,\n                    messages = attrs.sent,\n                    runCount = data.runCount,\n                    children = buster.children,\n                    eventname = 'respond',\n                    args = toArray(arguments);\n                if (runCount) {\n                    originalMessage = children.index(data.index);\n                    if (!originalMessage) {\n                        return buster;\n                    }\n                    // found the message that i originally sent you\n                    // packet = originalMessage.packet;\n                    // allow the buster to set some things up\n                    buster[DISPATCH_EVENT](BEFORE_RESPONDED);\n                    if (runCount === 1) {\n                        // stash it for later\n                        originalMessage[RESPONSE_OPTIONS] = data;\n                    } else {\n                        eventname = 'deferred';\n                    }\n                    originalMessage[DISPATCH_EVENT](eventname);\n                } else {\n                    buster[DISPATCH_EVENT]('receive:' + data.command);\n                    buster[DISPATCH_EVENT]('receive');\n                }\n                return buster;\n            },\n            /**\n             * skip the queue, and simply send a message\n             * @arg {object} message object to be sent\n             * @arg {object} optional object that is the original object. Usually only applicable when passed in through the send function, so that the response event can have all of the correct information\n             * @returns {buster}\n             * @func\n             * @name Buster#sendMessage\n             */\n            // sendMessage: function (message) {\n            //     var buster = this;\n            //     // set again to make sure that it has all the right info\n            //     // message.set(buster.defaultMessage());\n            //     postMessage(_.fullClone(message), buster);\n            //     return buster;\n            // },\n            /**\n             * creates a default message based on the attributes of the buster\n             * @returns {object} blank / default message object\n             * @func\n             * @name Buster#defaultMessage\n             */\n            defaultMessage: function () {\n                var attrs = this.directive(DATA);\n                return {\n                    from: attrs.id,\n                    postTo: attrs.postTo,\n                    sameSide: attrs.sameSide,\n                    fromInner: attrs.fromInner,\n                    toInner: attrs.toInner,\n                    index: this.children[LENGTH](),\n                    preventResponse: BOOLEAN_FALSE\n                };\n            },\n            /**\n             * @func\n             * @name Buster#shouldUpdate\n             */\n            // shouldUpdate: function (args) {\n            //     var ret, buster = this,\n            //         attrs = buster.directive(DATA),\n            //         lastUpdate = attrs.lastRespondUpdate,\n            //         lastFrameRect = attrs.lastFrameRect,\n            //         top = buster.parts[TOP] || {},\n            //         width = top.innerWidth,\n            //         height = top.innerHeight,\n            //         nowish = now();\n            //     if (lastUpdate > nowish - 1000 && _.isObject(lastFrameRect)) {\n            //         ret = !(lastFrameRect[BOTTOM] < -height * 0.5 || lastFrameRect.top > height * 1.5 || lastFrameRect[RIGHT] < -width * 0.5 || lastFrameRect[LEFT] > width * 1.5);\n            //     } else {\n            //         ret = 1;\n            //     }\n            //     clearTimeout(attrs.lastUpdateThrottledId);\n            //     if (!ret) {\n            //         attrs.lastUpdateThrottledId = setTimeout(function () {\n            //             buster.respond.apply(buster, args);\n            //         }, -(nowish - lastUpdate - 1000));\n            //     }\n            //     return !buster.startThrottle || ret;\n            // },\n            /**\n             * respond trigger.\n             * @arg {object} original data object (same pointer) that was sent over\n             * @arg {object} extend object, that will be applied to a base object, that is created by the responseExtend attribute set on the buster object\n             * @returns {buster}\n             * @func\n             * @name Buster#respond\n             */\n            respond: function (data, extendObj) {\n                var lastRespondUpdate, message, buster = this,\n                    attrs = buster.directive(DATA),\n                    sameSide = attrs.sameSide,\n                    base = {};\n                if (!extendObj || !_.isObject(extendObj)) {\n                    extendObj = {};\n                }\n                if (buster.el && (!data.canThrottle || buster.shouldUpdate(arguments))) {\n                    // on the inner functions, we don't want to allow this\n                    // module to be present, so the inner does not influence the outer\n                    if (attrs.responseExtend) {\n                        base = attrs.responseExtend(buster, data);\n                    }\n                    ++data.runCount;\n                    base = {\n                        from: data.postTo,\n                        postTo: data.from,\n                        index: data.index,\n                        isResponse: 1,\n                        isDeferred: data.isDeferred,\n                        runCount: data.runCount,\n                        command: data.command,\n                        packet: extend(base, extendObj)\n                    };\n                    // used for throttling\n                    attrs.lastRespondUpdate = postMessage(base, buster);\n                    buster[DISPATCH_EVENT]('respond:' + data.command);\n                    if (data.isDeferred) {\n                        buster[DISPATCH_EVENT]('deferred:' + data.command);\n                    }\n                    data.isDeferred = 1;\n                }\n                return buster;\n            },\n            /**\n             * @returns {object} client rect duplicate of element\n             * @func\n             * @name Buster#getFrameRect\n             */\n            // getFrameRect: function () {\n            //     var clientRect = this.directive(DATA).lastFrameRect = this.el.clientRect();\n            //     return clientRect;\n            // },\n            /**\n             * @returns {object} client rect duplicate of parent element\n             * @func\n             * @name Buster#getParentRect\n             */\n            // getParentRect: function () {\n            //     var parentRect = this.directive(DATA).lastParentRect = this.el[PARENT]().clientRect();\n            //     return parentRect;\n            // },\n            // updateTopData: function () {\n            //     var buster = this,\n            //         attrs = get(buster),\n            //         parts = buster.parts,\n            //         topWin = parts.top || {},\n            //         location = topWin.location || {\n            //             hash: EMPTY_STRING,\n            //             pathname: EMPTY_STRING,\n            //             protocol: EMPTY_STRING,\n            //             search: EMPTY_STRING\n            //         },\n            //         topData = attrs.topData = {\n            //             innerHeight: topWin.innerHeight || 0,\n            //             outerHeight: topWin.outerHeight || 0,\n            //             innerWidth: topWin.innerWidth || 0,\n            //             outerWidth: topWin.outerWidth || 0,\n            //             scrollX: topWin.scrollX || 0,\n            //             scrollY: topWin.scrollY || 0,\n            //             location: {\n            //                 hash: location.hash.slice(1),\n            //                 host: location.host,\n            //                 href: location.href,\n            //                 origin: location.origin,\n            //                 pathname: location.pathname.slice(1),\n            //                 port: location.port,\n            //                 protocol: location.protocol.slice(0, location.protocol[LENGTH] - 1),\n            //                 search: location.search.slice(1)\n            //             }\n            //         };\n            //     return topData;\n            // },\n            /**\n             * gets the wrapper info, such as scroll height, id, and the classname\n             * @returns {object} key value pairs of all of the data that defines the wrapper\n             * @func\n             * @name Buster#wrapperInfo\n             */\n            // wrapperInfo: function () {\n            //     var info, buster = this,\n            //         parts = buster.parts,\n            //         el = parts.wrapper || {},\n            //         doc = parts.doc || {\n            //             body: {}\n            //         },\n            //         root = doc.body.parentNode,\n            //         getBoundingClientRect = {},\n            //         attrs = get(buster);\n            //     if (el.tagName) {\n            //         getBoundingClientRect = $(el).clientRect();\n            //     }\n            //     info = attrs.wrapperInfo = {\n            //         readyState: (doc.readyState === 'complete'),\n            //         scrollHeight: el.scrollHeight,\n            //         scrollWidth: el.scrollWidth,\n            //         scrollLeft: el.scrollLeft,\n            //         scrollTop: el.scrollTop,\n            //         className: el.className,\n            //         pageTitle: doc.title,\n            //         id: el.id,\n            //         height: pI(getBoundingClientRect[HEIGHT]),\n            //         bottom: pI(getBoundingClientRect[BOTTOM]),\n            //         width: pI(getBoundingClientRect[WIDTH]),\n            //         right: pI(getBoundingClientRect[RIGHT]),\n            //         left: pI(getBoundingClientRect[LEFT]),\n            //         top: pI(getBoundingClientRect[TOP])\n            //     };\n            //     return info;\n            // },\n            /**\n             * @returns {object} position in document as calculated by the buster attributes\n             * @func\n             * @name Buster#positionInDocument\n             */\n            // positionInDocument: function () {\n            //     var attrs = this.directive(DATA),\n            //         wrapperInfo = attrs.wrapperInfo,\n            //         contentRect = attrs.lastParentRect,\n            //         pos = attrs.lastPosInDoc = {\n            //             top: pI(contentRect[TOP] - wrapperInfo[TOP]),\n            //             bottom: pI(wrapperInfo[HEIGHT] - contentRect[TOP] - wrapperInfo.scrollTop - contentRect[HEIGHT]),\n            //             left: pI(contentRect[LEFT] - wrapperInfo[LEFT]),\n            //             right: pI(wrapperInfo[WIDTH] - contentRect[RIGHT] - wrapperInfo.scrollLeft - wrapperInfo[LEFT])\n            //         };\n            //     return pos;\n            // },\n            // calculateSizes: function () {\n            //     var buster = this,\n            //         attrs = get(buster),\n            //         parentStyle = attrs.lastParentStyle = buster.el[PARENT]().getStyle(),\n            //         comSizes = attrs[COMPONENTS] = buster[COMPONENTS].map(function (idx, com) {\n            //             return buster.calculateSize(com);\n            //         });\n            //     return comSizes;\n            // },\n            // calculateContainerSize: function (components) {\n            //     var buster = this,\n            //         attrs = get(buster),\n            //         parentRect = attrs.lastParentRect,\n            //         sizing = containerSize(components || buster[COMPONENTS]);\n            //     attrs._sizing = sizing;\n            //     attrs.containerSize = {\n            //         top: sizing[TOP],\n            //         left: sizing[LEFT],\n            //         width: sizing[RIGHT] - sizing[LEFT],\n            //         height: sizing[BOTTOM] - sizing[TOP]\n            //     };\n            //     attrs.pushVerticalVal = Math.min(Math.max(sizing[BOTTOM] - parentRect[BOTTOM], 0), sizing[MARGIN_BOTTOM]);\n            //     attrs.pushHorizontalVal = Math.min(Math.max(sizing[RIGHT] - parentRect[RIGHT], 0), sizing[MARGIN_RIGHT]);\n            //     sizing = attrs.containerCss = {\n            //         top: sizing[TOP] - parentRect[TOP],\n            //         left: sizing[LEFT] - parentRect[LEFT],\n            //         width: sizing[RIGHT] - sizing[LEFT],\n            //         height: sizing[BOTTOM] - sizing[TOP],\n            //         zIndex: sizing.zIndex || 'inherit'\n            //     };\n            //     return sizing;\n            // },\n            // calculateSize: function (component) {\n            //     var buster = this,\n            //         attrs = get(buster),\n            //         expansion = factories.expansion[component.dimensionType || 'match'],\n            //         parentRect = attrs.lastParentRect,\n            //         parentStyle = attrs.lastParentStyle,\n            //         method = (expansion || factories.expansion.match),\n            //         result = method.call(buster, component, parentRect, parentStyle, buster.parts[TOP]),\n            //         // these are always relative to the viewport\n            //         calcSize = component.calculatedSize = _.floor({\n            //             top: result[TOP],\n            //             left: result[LEFT],\n            //             width: result[WIDTH],\n            //             height: result[HEIGHT]\n            //         }, 2);\n            //     return calcSize;\n            // },\n            /**\n             * starts a relationship between two busters. simplifies the initialization process.\n             * @returns {number} just for responding to the original message in case there's a handler\n             * @func\n             * @name Buster#begin\n             */\n            begin: function () {\n                var buster = this,\n                    attrs = buster.directive(DATA),\n                    message = buster.send('initialize', {\n                        referrer: attrs.publisher\n                    });\n                message.respond(function (e) {\n                    var data = e.data(),\n                        packet = data.packet;\n                    buster.set('isConnected', BOOLEAN_TRUE);\n                });\n                return message;\n            }\n        }, BOOLEAN_TRUE);\n    if (app.topAccess()) {\n        $(win[TOP]).on('message', receive);\n    }\n    _.exports({\n        containerSize: containerSize\n    });\n});","});"],"sourceRoot":"/source/"}